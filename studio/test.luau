
-- bundled with tk (pronounced tick) by 'spin the hexagon'
-- rights are reserved, but not by us
-- you can mess around as much as you want, we (STH) don't care, the game devs might.
-- https://github.com/spin-the-hexagon/tk
-- [tkpack]
-- basically the webpack runtime, but TK
-- made with <3 by spin-the-hexagon
--
-- no rights reserved
-- do whatever you want

 local tkpack = {}

tkpack.moduleTable = {}
tkpack.includedModules = {}
tkpack.moduleReturns = {}

function tkpack.indexOf(array: { any }, item: any)
	for real, index in array do
		if item == real then
			return index
		end
	end

	return -1
 end

 function tkpack.declare(modulePath: string, init: () -> any)
	tkpack.moduleTable[modulePath] = init
 end

 function tkpack.include(modulePath: string)
	if tkpack.indexOf(tkpack.includedModules, modulePath) ~= -1 then
		return tkpack.moduleReturns[modulePath]
	end

	tkpack.includedModules[#tkpack.includedModules] = modulePath

	tkpack.moduleReturns[modulePath] = tkpack.moduleTable[modulePath]()

	return tkpack.moduleReturns[modulePath]
end

-- [/tkpack]

-- D:\Programming\toolkit\studio\src\index.luau
 tkpack.declare("game.TK",function()
    local CoreGui=game:GetService("CoreGui");
    local React=tkpack.include("game.Packages.react");
    local ReactRoblox=tkpack.include("game.Packages.react-roblox");
    print("HELLO!!!");
    function App()
        return React.createElement("TextLabel",{["Size"]=UDim2.new(0,200,0,50),["Position"]=UDim2.new(0.5,-(100),0.5,-(25)),["Text"]="Hello, React for Roblox!",["BackgroundColor3"]=Color3.fromRGB(255,255,255),["TextColor3"]=Color3.fromRGB(0,0,0),["TextScaled"]=true})
    end;
    ReactRoblox.createRoot(CoreGui):render(React.createElement(App))

end)
-- D:\Programming\toolkit\studio\packages\react.lua
 tkpack.declare("game.Packages.react",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react")

end)
-- D:\Programming\toolkit\studio\packages\react-roblox.lua
 tkpack.declare("game.Packages.react-roblox",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    type("not printable... yet");
    local React=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.React");
    type("not printable... yet");
    type("not printable... yet");
    local ReactLazy=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactLazy");
    type("not printable... yet");
    local SharedModule=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return React

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox",function()
    local HostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    return tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRoblox")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\luau-polyfill.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill",function()
    return tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\React.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.React",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    type("not printable... yet");
    local createMutableSource=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactMutableSource");
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSharedInternals;
    local ReactBaseClasses=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactBaseClasses");
    local ReactChildren=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactChildren");
    local ReactElementValidator=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElementValidator");
    local ReactElement=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElement");
    local ReactCreateRef=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactCreateRef");
    local ReactForwardRef=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactForwardRef");
    local ReactHooks=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactHooks");
    local ReactMemo=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactMemo");
    local ReactContext=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactContext");
    local ReactLazy=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactLazy");
    type("not printable... yet");
    local ReactBinding=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactBinding.roblox");
    local ReactNone=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.None.roblox");
    local SharedModule=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    local ReactSymbols=SharedModule.ReactSymbols;
    local shouldValidate=(_G.__DEV__)or(_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__);
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local createElement=if shouldValidate then ReactElementValidator.createElementWithValidation else ReactElement.createElement;
    local cloneElement=if shouldValidate then ReactElementValidator.cloneElementWithValidation else ReactElement.cloneElement;
    return{["Children"]=ReactChildren,["createMutableSource"]=createMutableSource,["createRef"]=ReactCreateRef.createRef,["Component"]=ReactBaseClasses.Component,["PureComponent"]=ReactBaseClasses.PureComponent,["createContext"]=ReactContext.createContext,["forwardRef"]=ReactForwardRef.forwardRef,["lazy"]=ReactLazy.lazy,["memo"]=ReactMemo.memo,["useCallback"]=ReactHooks.useCallback,["useContext"]=ReactHooks.useContext,["useEffect"]=ReactHooks.useEffect,["useImperativeHandle"]=ReactHooks.useImperativeHandle,["useDebugValue"]=ReactHooks.useDebugValue,["useLayoutEffect"]=ReactHooks.useLayoutEffect,["useMemo"]=ReactHooks.useMemo,["useMutableSource"]=ReactHooks.useMutableSource,["useReducer"]=ReactHooks.useReducer,["useRef"]=ReactHooks.useRef,["useBinding"]=ReactHooks.useBinding,["useState"]=ReactHooks.useState,["Fragment"]=ReactSymbols.REACT_FRAGMENT_TYPE,["Profiler"]=ReactSymbols.REACT_PROFILER_TYPE,["StrictMode"]=ReactSymbols.REACT_STRICT_MODE_TYPE,["unstable_DebugTracingMode"]=ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE,["Suspense"]=ReactSymbols.REACT_SUSPENSE_TYPE,["createElement"]=createElement,["cloneElement"]=cloneElement,["isValidElement"]=ReactElement.isValidElement,["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"]=ReactSharedInternals,["unstable_LegacyHidden"]=ReactSymbols.REACT_LEGACY_HIDDEN_TYPE,["createBinding"]=ReactBinding.create,["joinBindings"]=ReactBinding.join,["None"]=ReactNone,["__subscribeToBinding"]=ReactBinding.subscribe,["Event"]=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").Event,["Change"]=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").Change,["Tag"]=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").Tag,["unstable_parseReactError"]=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").parseReactError}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactLazy.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactLazy",function()
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    local console=Shared.console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local inspect=LuauPolyfill.util.inspect;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local Uninitialized=-(1);
    local Pending=0;
    local Resolved=1;
    local Rejected=2;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    function lazyInitializer(payload)
        if(payload._status)==(Uninitialized)then
             local ctor=payload._result;
            local thenable=ctor();
            local pending=payload;
            pending._status=Pending;
            pending._result=thenable;
            thenable:andThen(function(moduleObject)
                if(payload._status)==(Pending)then
                     local defaultExport=moduleObject.default;
                    if _G.__DEV__ then
                         if(defaultExport)==(nil)then
                             console.error("lazy: Expected the result of a dynamic import() call. Instead received: `%s`\x0a\x0aYour code should look like: \x0a  local MyComponent = lazy(function() return reqquire(script.Parent.MyComponent) end)",inspect(moduleObject))
                        end
                     end;
                    local resolved=payload;
                    resolved._status=Resolved;
                    resolved._result=defaultExport
                 end
             end,function(error_)
                if(payload._status)==(Pending)then
                     local rejected=payload;
                    rejected._status=Rejected;
                    rejected._result=error_
                 end
             end)
        end;
        if(payload._status)==(Resolved)then
             return payload._result
         else
             error(payload._result)
        end
     end;
    local exports={};
    exports.lazy=function(ctor)
        local payload={["_status"]=-(1),["_result"]=ctor};
        local lazyType={["\x24\x24typeof"]=REACT_LAZY_TYPE,["_payload"]=payload,["_init"]=lazyInitializer};
        if _G.__DEV__ then
             local defaultProps;
            local propTypes;
            setmetatable(lazyType,{["__index"]=function(self,key)
                if(key)==("defaultProps")then
                     return defaultProps
                 end;
                if(key)==("propTypes")then
                     return propTypes
                 end;
                return
             end,["__newindex"]=function(self,key,value)
                if(key)==("defaultProps")then
                     console.error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps=value;
                    setmetatable(self,{["__index"]=function()
                        
                    end,["__newindex"]=function()
                        
                    end})
                end;
                if(key)==("propTypes")then
                     console.error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes=value;
                    setmetatable(self,{["__index"]=function()
                        
                    end,["__newindex"]=function()
                        
                    end})
                end
             end})
        end;
        return lazyType
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\shared.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.shared",function()
    return tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRobloxHostTypes.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox",function()
    local ReactReconciler=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRoblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRoblox",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared");
    type("not printable... yet");
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    local ReactRobloxRoot;
    ReactRobloxRoot=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxRoot");
    local createRoot=ReactRobloxRoot.createRoot;
    local createBlockingRoot=ReactRobloxRoot.createBlockingRoot;
    local createLegacyRoot=ReactRobloxRoot.createLegacyRoot;
    local isValidContainer=ReactRobloxRoot.isValidContainer;
    local ReactReconciler=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.ReactReconciler.roblox");
    local batchedUpdates=ReactReconciler.batchedUpdates;
    local flushSync=ReactReconciler.flushSync;
    local injectIntoDevTools=ReactReconciler.injectIntoDevTools;
    local flushPassiveEffects=ReactReconciler.flushPassiveEffects;
    local IsThisRendererActing=ReactReconciler.IsThisRendererActing;
    local createPortalImpl=ReactReconciler.createPortal;
    local ReactVersion=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactVersion;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").invariant;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactFeatureFlags;
    local enableNewReconciler=ReactFeatureFlags.enableNewReconciler;
    local ReactRobloxComponentTree=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponentTree");
    local getInstanceFromNode=ReactRobloxComponentTree.getInstanceFromNode;
    local getNodeFromInstance=ReactRobloxComponentTree.getNodeFromInstance;
    local getFiberCurrentPropsFromNode=ReactRobloxComponentTree.getFiberCurrentPropsFromNode;
    local getClosestInstanceFromNode=ReactRobloxComponentTree.getClosestInstanceFromNode;
    local Event=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").Event;
    local Change=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").Change;
    local Tag=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").Tag;
    local function createPortal(children,container,key)
        invariant(isValidContainer(container),"Target container is not a Roblox Instance.");
        return createPortalImpl(children,container,nil,key)
    end;
    local Internals={["Events"]={["getInstanceFromNode"]=getInstanceFromNode,["getNodeFromInstance"]=getNodeFromInstance,["getFiberCurrentPropsFromNode"]=getFiberCurrentPropsFromNode,["flushPassiveEffects"]=flushPassiveEffects,["IsThisRendererActing"]=IsThisRendererActing}};
    local exports={["createPortal"]=createPortal,["unstable_batchedUpdates"]=batchedUpdates,["flushSync"]=flushSync,["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"]=Internals,["version"]=ReactVersion,["createRoot"]=createRoot,["createBlockingRoot"]=createBlockingRoot,["createLegacyRoot"]=createLegacyRoot,["Event"]=Event,["Change"]=Change,["Tag"]=Tag,["unstable_isNewReconciler"]=enableNewReconciler,["act"]=function(_)
        error("ReactRoblox.act is only available in testing environments, not production. Enable the `__ROACT_17_MOCK_SCHEDULER__` global in your test configuration in order to use `act`.")
    end};
    if _G.__ROACT_17_MOCK_SCHEDULER__ then
         exports.act=ReactReconciler.act
     end;
    local _foundDevTools=injectIntoDevTools({["findFiberByHostInstance"]=getClosestInstanceFromNode,["bundleType"]=if _G.__DEV__ then 1 else 0,["version"]=ReactVersion,["rendererPackageName"]="ReactRoblox"});
    if _G.__DEV__ then
        
     end;
    exports.robloxReactProfiling=ReactReconciler.robloxReactProfiling;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill",function()
    local Boolean=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.boolean");
    local Collections=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.collections");
    local Console=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.console");
    local Math=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.math");
    local Number=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.number");
    local String=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.string");
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.symbol-luau");
    local Timers=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.timers");
    local types=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.es7-types");
    local AssertionError=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.AssertionError");
    local Error=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Error");
    local PromiseModule=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Promise");
    local extends=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.extends");
    local instanceof=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.instance-of");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{["Array"]=Collections.Array,["AssertionError"]=AssertionError,["Boolean"]=Boolean,["console"]=Console,["Error"]=Error,["extends"]=extends,["instanceof"]=instanceof,["Math"]=Math,["Number"]=Number,["Object"]=Collections.Object,["Map"]=Collections.Map,["coerceToMap"]=Collections.coerceToMap,["coerceToTable"]=Collections.coerceToTable,["Set"]=Collections.Set,["WeakMap"]=Collections.WeakMap,["String"]=String,["Symbol"]=Symbol,["setTimeout"]=Timers.setTimeout,["clearTimeout"]=Timers.clearTimeout,["setInterval"]=Timers.setInterval,["clearInterval"]=Timers.clearInterval,["util"]={["inspect"]=Collections.inspect}}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactMutableSource.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactMutableSource",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local function createMutableSource(source,getVersion)
        local mutableSource={["_getVersion"]=getVersion,["_source"]=source,["_workInProgressVersionPrimary"]=nil,["_workInProgressVersionSecondary"]=nil};
        if _G.__DEV__ then
             mutableSource._currentPrimaryRenderer=nil;
            mutableSource._currentSecondaryRenderer=nil
         end;
        return mutableSource
     end;
    return createMutableSource

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactBaseClasses.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactBaseClasses",function()
    local __DEV__=_G.__DEV__;
    local __COMPAT_WARNINGS__=_G.__COMPAT_WARNINGS__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local SharedModule=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    local ReactNoopUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactNoopUpdateQueue");
    local emptyObject={};
    if __DEV__ then
         Object.freeze(emptyObject)
    end;
    local UninitializedState=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").UninitializedState;
    local componentClassPrototype={["isReactComponent"]=true};
    local function trimPath(path)
        local pascalFile=string.match(path,"%.%u[%.%w]-\x24");
        if pascalFile then
             return string.gsub(pascalFile,"^%.","")
        end;
        return path
     end;
    local function warnAboutExistingLifecycle(componentName,newName,existingName)
        console.warn("%s already defined '%s', but it also defining the deprecated Roact method '%s'. %s should only implement one of these methods, preferably using the non-deprecated name.",componentName,existingName,newName,componentName)
    end;
    local function warnAboutDeprecatedLifecycleName(componentName,newName,existingName)
        if(__DEV__)and(__COMPAT_WARNINGS__)then
             local path,linenum=debug.info(3,"sln");
            console.warn("%s is using method '%s', which is no longer supported and should be updated to '%s'\x0aFile: %s:%s",componentName,newName,existingName,trimPath(path),tostring(linenum))
        end
     end;
    local lifecycleNames={["didMount"]="componentDidMount",["shouldUpdate"]="shouldComponentUpdate",["willUpdate"]="UNSAFE_componentWillUpdate",["didUpdate"]="componentDidUpdate",["willUnmount"]="componentWillUnmount"};
    local function handleNewLifecycle(self,key,value)
        if(lifecycleNames[key])~=(nil)then
             if(self[lifecycleNames[key]])~=(nil)then
                 warnAboutExistingLifecycle(self.__componentName,key,lifecycleNames[key])
            elseif((key)==("willUpdate"))and(self["componentWillUpdate"])then
                 warnAboutExistingLifecycle(self.__componentName,key,"UNSAFE_componentWillUpdate")
            else
                 warnAboutDeprecatedLifecycleName(self.__componentName,key,lifecycleNames[key])
            end;
            key=lifecycleNames[key]
        end;
        rawset(self,key,value)
    end;
    local componentClassMetatable={["__newindex"]=handleNewLifecycle,["__index"]=componentClassPrototype,["__tostring"]=function(self)
        return self.__componentName
     end};
    type("not printable... yet");
    local Component=(setmetatable({["__componentName"]="Component"},componentClassMetatable));
    local InstancePoolSize=if not(_G.__TESTEZ_RUNNING_TEST__)then 900 else 0;
    local InstancePoolIndex=1;
    local InstancePool=table.create(InstancePoolSize);
    for i=1,InstancePoolSize do
         table.insert(InstancePool,{["props"]=nil,["context"]=nil,["state"]=UninitializedState,["__refs"]=emptyObject,["__updater"]=ReactNoopUpdateQueue})
    end;
    local function setStateInInit(componentInstance,statePayload,callback)
        if(__DEV__)and(((callback))~=(nil))then
             console.warn("Received a `callback` argument to `setState` during initialization of \"%s\". The callback behavior is not supported when using `setState` in `init`.\x0a\x0aConsider defining similar behavior in a `compontentDidMount` method instead.",componentInstance.__componentName)
        end;
        local typeStatePayload=(statePayload)and(type(statePayload));
        if((statePayload)==(nil))or((((typeStatePayload)~=("table"))and((typeStatePayload)~=("function"))))then
             error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.")
        end;
        local prevState=componentInstance.state;
        local partialState;
        if(typeStatePayload)==("function")then
             partialState=statePayload(prevState,componentInstance.props)
        else
             partialState=statePayload
         end;
        componentInstance.state=Object.assign({},prevState,partialState)
    end;
    function Component:extend(name)
        if(name)==(nil)then
             if __COMPAT_WARNINGS__ then
                 console.warn("Component:extend() accepting no arguments is deprecated, and will not be supported in a future version of Roact. Please provide an explicit name.")
            end;
            name=""
        elseif(type(name))~=("string")then
             error("Component class name must be a string")
        end;
        local class={["__componentName"]=name,["setState"]=self.setState,["forceUpdate"]=self.forceUpdate,["init"]=nil};
        class.__index=class;
        function class.__ctor(props,context,updater)
            local instance;
            if(InstancePoolIndex)<=(InstancePoolSize)then
                 instance=InstancePool[InstancePoolIndex];
                instance.props=props;
                instance.context=context;
                InstancePool[InstancePoolIndex]=nil;
                InstancePoolIndex+=1
             else
                 instance={["props"]=props,["context"]=context,["state"]=UninitializedState,["__refs"]=emptyObject,["__updater"]=(updater)or(ReactNoopUpdateQueue)}
            end;
            instance=setmetatable(instance,class);
            if(class.init)and((type(class.init))==("function"))then
                 instance.setState=setStateInInit;
                class.init(instance,props,context);
                instance.setState=nil
             end;
            return(instance)
        end;
        setmetatable(class,getmetatable(self));
        return(class)
    end;
    function Component:setState(partialState,callback)
        if(((partialState)~=(nil))and((type(partialState))~=("table")))and((type(partialState))~=("function"))then
             error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.")
        end;
        self.__updater.enqueueSetState(self,partialState,callback,"setState")
    end;
    function Component:forceUpdate(callback)
        self.__updater.enqueueForceUpdate(self,callback,"forceUpdate")
    end;
    if __DEV__ then
         local deprecatedAPIs={["isMounted"]={"isMounted","Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."},["replaceState"]={"replaceState","Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."}};
        local defineDeprecationWarning=function(methodName,info)
            (Component)[methodName]=function()
                console.warn("%s(...) is deprecated in plain JavaScript React classes. %s",info[1],info[2]);
                return nil
             end
         end;
        for fnName,_ in deprecatedAPIs do
             if(deprecatedAPIs[fnName])~=(nil)then
                 defineDeprecationWarning(fnName,deprecatedAPIs[fnName])
            end
         end
     end;
    local PureComponent=Component:extend("PureComponent");
    (PureComponent).extend=Component.extend;
    local pureComponentClassPrototype={["isReactComponent"]=true,["isPureReactComponent"]=true};
    setmetatable(PureComponent,{["__newindex"]=handleNewLifecycle,["__index"]=pureComponentClassPrototype,["__tostring"]=function(self)
        return self.__componentName
     end});
    return{["Component"]=Component,["PureComponent"]=PureComponent}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactChildren.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactChildren",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").invariant;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local getIteratorFn=ReactSymbols.getIteratorFn;
    local REACT_ELEMENT_TYPE=ReactSymbols.REACT_ELEMENT_TYPE;
    local REACT_PORTAL_TYPE=ReactSymbols.REACT_PORTAL_TYPE;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    type("not printable... yet");
    type("not printable... yet");
    local ReactElement=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElement");
    local isValidElement=ReactElement.isValidElement;
    local cloneAndReplaceKey=ReactElement.cloneAndReplaceKey;
    local SEPARATOR=".";
    local SUBSEPARATOR=":";
    local function escape(key)
        local escapedString=string.gsub(key,"=","=0");
        escapedString=string.gsub(escapedString,":","=2");
        return("\x24")..(escapedString)
    end;
    local function escapeUserProvidedKey(text)
        return text
     end;
    local function getElementKey(element,index)
        if(((typeof(element))==("table"))and((element)~=(nil)))and((element.key)~=(nil))then
             return escape(tostring(element.key))
        end;
        return tostring(index)
    end;
    local function mapIntoArray(children,array,escapedPrefix,nameSoFar,callback)
        local type=typeof(children);
        if(((type)==("nil"))or((type)==("boolean")))or((type)==("userdata"))then
             children=nil
         end;
        local invokeCallback=false;
        if(children)==(nil)then
             invokeCallback=true
         else
             if((type)==("string"))or((type)==("number"))then
                 invokeCallback=true
             elseif(type)==("table")then
                 local childrenType=(children)["\x24\x24typeof"];
                if((childrenType)==(REACT_ELEMENT_TYPE))or((childrenType)==(REACT_PORTAL_TYPE))then
                     invokeCallback=true
                 end
             end
         end;
        if invokeCallback then
             local child=children;
            local mappedChild=callback(child);
            local childKey=if(nameSoFar)==("")then(SEPARATOR)..(getElementKey(child,1))else nameSoFar;
            if Array.isArray(mappedChild)then
                 local escapedChildKey="";
                if(childKey)~=(nil)then
                     escapedChildKey=(escapeUserProvidedKey(childKey))..("/")
                end;
                mapIntoArray(mappedChild,array,escapedChildKey,"",function(c)
                    return c
                 end)
            elseif(mappedChild)~=(nil)then
                 if isValidElement(mappedChild)then
                     local mappedChildKey=(mappedChild).key;
                    mappedChild=cloneAndReplaceKey(mappedChild,(escapedPrefix)..(((if(mappedChildKey)and(((not(child))or(((child).key)~=(mappedChildKey))))then(escapeUserProvidedKey(tostring(mappedChildKey)))..("/")else""))..(childKey)))
                end;
                table.insert(array,mappedChild)
            end;
            return 1
         end;
        local child;
        local nextName;
        local subtreeCount=0;
        local nextNamePrefix=if(nameSoFar)==("")then SEPARATOR else(nameSoFar)..(SUBSEPARATOR);
        if Array.isArray(children)then
             for i=1,#((children))do
                 child=(children)[i];
                nextName=(nextNamePrefix)..(getElementKey(child,i));
                subtreeCount+=mapIntoArray(child,array,escapedPrefix,nextName,callback)
            end
         else
             local iteratorFn=getIteratorFn(children);
            if(typeof(iteratorFn))==("function")then
                 local iterableChildren=children;
                local iterator=iteratorFn(iterableChildren);
                local step;
                local ii=1;
                step=iterator.next();
                while not(step.done)do
                     child=step.value;
                    nextName=(nextNamePrefix)..(getElementKey(child,ii));
                    ii+=1;
                    subtreeCount+=mapIntoArray(child,array,escapedPrefix,nextName,callback);
                    step=iterator.next()
                end
             end
         end;
        return subtreeCount
     end;
    type("not printable... yet");
    local function mapChildren(children,func,context)
        if(children)==(nil)then
             return nil
         end;
        local result={};
        local count=1;
        mapIntoArray(children,result,"","",function(child)
            local mapFuncResult=func(child,count);
            count+=1;
            return mapFuncResult
         end);
        return result
     end;
    local function countChildren(children)
        local n=0;
        mapChildren(children,function()
            n+=1;
            return
         end);
        return n
     end;
    type("not printable... yet");
    local function forEachChildren(children,forEachFunc,forEachContext)
        mapChildren(children,function(...)
            forEachFunc(...);
            return
         end,forEachContext)
    end;
    local function toArray(children)
        return(mapChildren(children,function(child)
            return child
         end))or({})
    end;
    local function onlyChild(children)
        invariant(isValidElement(children),"React.Children.only expected to receive a single React element child.");
        return children
     end;
    return{["forEach"]=forEachChildren,["map"]=mapChildren,["count"]=countChildren,["only"]=onlyChild,["toArray"]=toArray}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactElementValidator.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElementValidator",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    type("not printable... yet");
    local Boolean=LuauPolyfill.Boolean;
    local Object=LuauPolyfill.Object;
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local inspect=LuauPolyfill.util.inspect;
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local isValidElementType=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").isValidElementType;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").getComponentName;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local getIteratorFn=ReactSymbols.getIteratorFn;
    local _REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local _REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_FRAGMENT_TYPE=ReactSymbols.REACT_FRAGMENT_TYPE;
    local REACT_ELEMENT_TYPE=ReactSymbols.REACT_ELEMENT_TYPE;
    local warnAboutSpreadingKeyToJSX=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactFeatureFlags.warnAboutSpreadingKeyToJSX;
    local checkPropTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").checkPropTypes;
    local ReactCurrentOwner=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSharedInternals.ReactCurrentOwner;
    local ReactElement=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElement");
    local isValidElement=ReactElement.isValidElement;
    local createElement=ReactElement.createElement;
    local cloneElement=ReactElement.cloneElement;
    local jsxDEV=ReactElement.jsxDEV;
    local setExtraStackFrame=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSharedInternals.ReactDebugCurrentFrame.setExtraStackFrame;
    local describeUnknownElementTypeFrameInDEV=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV;
    local exports={};
    local function setCurrentlyValidatingElement(element)
        if _G.__DEV__ then
             if element then
                 local owner=element._owner;
                local ownerArgument;
                if owner then
                     ownerArgument=owner.type
                 end;
                local stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,ownerArgument);
                (setExtraStackFrame)(stack)
            else
                (setExtraStackFrame)(nil)
            end
         end
     end;
    local propTypesMisspellWarningShown;
    if _G.__DEV__ then
         propTypesMisspellWarningShown=false
     end;
    local function hasOwnProperty(object,key)
        return(object[key])~=(nil)
    end;
    local function getDeclarationErrorAddendum()
        if ReactCurrentOwner.current then
             local name=getComponentName(ReactCurrentOwner.current.type);
            if name then
                 return("\x0a\x0aCheck the render method of `")..((name)..("`."))
            end
         end;
        return""
    end;
    local function getSourceInfoErrorAddendum(source)
        if(source)~=(nil)then
             local fileName=string.gsub(source.fileName,"^.*[\\/]","");
            local lineNumber=source.lineNumber;
            return("\x0a\x0aCheck your code at ")..((fileName)..((":")..((lineNumber)..("."))))
        end;
        return""
    end;
    local function getSourceInfoErrorAddendumForProps(elementProps)
        if(elementProps)~=(nil)then
             return getSourceInfoErrorAddendum(elementProps.__source)
        end;
        return""
    end;
    local ownerHasKeyUseWarning={};
    local function getCurrentComponentErrorInfo(parentType)
        local info=getDeclarationErrorAddendum();
        if not(Boolean.toJSBoolean(info))then
             local parentName=if(typeof(parentType))==("string")then parentType else if(typeof(parentType))==("table")then(parentType.displayName)or(parentType.name)else nil;
            if(not(parentName))and((typeof(parentType))==("function"))then
                 local functionName=debug.info(parentType,"n");
                parentName=if(functionName)~=("")then functionName else nil
             end;
            if parentName then
                 info=string.format("\x0a\x0aCheck the top-level render call using <%s>.",parentName)
            end
         end;
        return info
     end;
    local function validateExplicitKey(element,parentType,tableKey)
        if((element._store)==(nil))or(element._store.validated)then
             return
         end;
        (element._store).validated=true;
        if(((element.key)~=(nil)))~=(((tableKey)~=(nil)))then
             return
         end;
        local currentComponentErrorInfo=getCurrentComponentErrorInfo(parentType);
        if ownerHasKeyUseWarning[currentComponentErrorInfo]then
             return
         end;
        ownerHasKeyUseWarning[currentComponentErrorInfo]=true;
        local childOwner="";
        if((element)and(element._owner))and((element._owner)~=(ReactCurrentOwner.current))then
             childOwner=string.format(" It was passed a child from %s.",tostring(getComponentName(element._owner.type)))
        end;
        if _G.__DEV__ then
             setCurrentlyValidatingElement(element);
            if((element.key)~=(nil))and((tableKey)~=(nil))then
                 console.error("Child element received a \"key\" prop (\"%s\") in addition to a key in the \"children\" table of its parent (\"%s\"). Please provide only one key definition. When both are present, the \"key\" prop will take precedence.%s%s See https://reactjs.org/link/warning-keys for more information.",tostring(element.key),tostring(tableKey),currentComponentErrorInfo,childOwner)
            else
                 console.error("Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.",currentComponentErrorInfo,childOwner)
            end;
            setCurrentlyValidatingElement(nil)
        end
     end;
    local function validateChildKeys(node,parentType)
        if(typeof(node))~=("table")then
             return
         end;
        if Array.isArray(node)then
             for i=1,#(node)do
                 local child=node[i];
                if isValidElement(child)then
                     validateExplicitKey(child,parentType)
                end
             end
         elseif isValidElement(node)then
             if node._store then
                 node._store.validated=true
             end
         elseif node then
             local iteratorFn=getIteratorFn(node);
            if(typeof(iteratorFn))==("function")then
                 if(iteratorFn)~=(node.entries)then
                     local iterator=iteratorFn(node);
                    local step=iterator.next();
                    while not(step.done)do
                         if isValidElement(step.value)then
                             validateExplicitKey(step.value,parentType,step.key)
                        end;
                        step=iterator.next()
                    end
                 end
             end
         end
     end;
    local function validatePropTypes(element)
        if(_G.__DEV__)or(_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             local type=element.type;
            if((type)==(nil))or((typeof(type))==("string"))then
                 return
             end;
            local propTypes;
            local validateProps;
            if(typeof(type))==("function")then
                 return
             elseif(typeof(type))==("table")then
                 propTypes=type.propTypes;
                validateProps=type.validateProps
             else
                 return
             end;
            if(propTypes)or(validateProps)then
                 local name=getComponentName(type);
                checkPropTypes(propTypes,validateProps,element.props,"prop",name,element)
            elseif(((type).PropTypes)~=(nil))and(not(propTypesMisspellWarningShown))then
                 propTypesMisspellWarningShown=true;
                local name=getComponentName(type);
                console.error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",(name)or("Unknown"))
            end;
            if((type).getDefaultProps)~=(nil)then
                 console.error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")
            end
         end
     end;
    local function validateFragmentProps(fragment)
        if _G.__DEV__ then
             local keys=Object.keys(fragment.props);
            for i=1,#(keys)do
                 local key=keys[i];
                if((key)~=("children"))and((key)~=("key"))then
                     setCurrentlyValidatingElement(fragment);
                    console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",key);
                    setCurrentlyValidatingElement(nil);
                    break
                 end
             end;
            if(fragment.ref)~=(nil)then
                 setCurrentlyValidatingElement(fragment);
                console.error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement(nil)
            end
         end
     end;
    local function jsxWithValidation(type,props,key,isStaticChildren,source,self)
        local validType=isValidElementType(type);
        if not(validType)then
             local info="";
            if((type)==(nil))or((((typeof(type))==("table"))and((#(Object.keys(type)))==(0))))then
                 info..=(" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
            end;
            local sourceInfo=getSourceInfoErrorAddendum(source);
            if sourceInfo then
                 info..=sourceInfo
             else
                 info..=getDeclarationErrorAddendum()
            end;
            local typeString;
            if(type)==(nil)then
                 typeString="nil"
            elseif Array.isArray(type)then
                 typeString="array"
            elseif((typeof(type))==("table"))and((type["\x24\x24typeof"])==(REACT_ELEMENT_TYPE))then
                 typeString=string.format("<%s />",(getComponentName(type.type))or("Unknown"));
                info..=" Did you accidentally export a JSX literal or Element instead of a component?"
            else
                 typeString=typeof(type);
                info..=("\x0a")..(inspect(type))
            end;
            if _G.__DEV__ then
                 console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)
            end
         end;
        local element=jsxDEV(type,props,key,source,self);
        if(element)==(nil)then
             return element
         end;
        if validType then
             local children=props.children;
            if(children)~=(nil)then
                 if isStaticChildren then
                     if Array.isArray(children)then
                         for i=1,#(children)do
                             validateChildKeys(children[i],type)
                        end;
                        Object.freeze(children)
                    else
                         if _G.__DEV__ then
                             console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.")
                        end
                     end
                 else
                     validateChildKeys(children,type)
                end
             end
         end;
        if _G.__DEV__ then
             if warnAboutSpreadingKeyToJSX then
                 if hasOwnProperty(props,"key")then
                     console.error("React.jsx: Spreading a key to JSX is a deprecated pattern. Explicitly pass a key after spreading props in your JSX call. E.g. <%s {...props} key={key} />",(getComponentName(type))or("ComponentName"))
                end
             end
         end;
        if(type)==(REACT_FRAGMENT_TYPE)then
             validateFragmentProps((element))
        else
             validatePropTypes((element))
        end;
        return element
     end;
    exports.jsxWithValidation=jsxWithValidation;
    exports.jsxWithValidationStatic=function(type,props,key)
        return jsxWithValidation(type,props,key,true)
    end;
    exports.jsxWithValidationDynamic=function(type,props,key)
        return jsxWithValidation(type,props,key,false)
    end;
    local function createElementWithValidation(type_,props,...)
        local validType=isValidElementType(type_);
        if not(validType)then
             local info="";
            if((type_)==(nil))or((((typeof(type_))==("table"))and((#(Object.keys(type_)))==(0))))then
                 info..=(" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
            end;
            local sourceInfo=getSourceInfoErrorAddendumForProps(props);
            if sourceInfo then
                 info..=sourceInfo
             else
                 info..=getDeclarationErrorAddendum()
            end;
            local typeString;
            if(type_)==(nil)then
                 typeString="nil"
            elseif Array.isArray(type_)then
                 typeString="array"
            elseif(((type_)~=(nil))and((typeof(type_))==("table")))and((type_["\x24\x24typeof"])==(REACT_ELEMENT_TYPE))then
                 typeString=string.format("<%s />",(getComponentName((type_).type))or("Unknown"));
                info..=" Did you accidentally export a JSX literal or Element instead of a component?"
            else
                 typeString=typeof(type_);
                if(type_)~=(nil)then
                     info..=("\x0a")..(inspect(type_))
                end
             end;
            if _G.__DEV__ then
                 console.error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)
            end
         end;
        local element=createElement(type_,props,...);
        if(element)==(nil)then
             return element
         end;
        if validType then
             for i=1,select("\x23",...)do
                 validateChildKeys(select(i,...),type_)
            end
         end;
        if(type_)==(REACT_FRAGMENT_TYPE)then
             validateFragmentProps(element)
        else
             validatePropTypes(element)
        end;
        return element
     end;
    exports.createElementWithValidation=createElementWithValidation;
    exports.cloneElementWithValidation=function(element,props,...)
        local arguments={element,props,...};
        local newElement=cloneElement(element,props,...);
        for i=3,#(arguments)do
             validateChildKeys(arguments[i],newElement.type)
        end;
        validatePropTypes(newElement);
        return newElement
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactElement.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactElement",function()
    local __DEV__=_G.__DEV__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Error=LuauPolyfill.Error;
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactLazy=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactLazy");
    type("not printable... yet");
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").getComponentName;
    local REACT_ELEMENT_TYPE=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols.REACT_ELEMENT_TYPE;
    local ReactCurrentOwner=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSharedInternals.ReactCurrentOwner;
    local RESERVED_PROPS={["key"]=true,["ref"]=true,["__self"]=true,["__source"]=true};
    local specialPropKeyWarningShown,specialPropRefWarningShown,didWarnAboutStringRefs;
    if __DEV__ then
         didWarnAboutStringRefs={}
    end;
    local exports={};
    local function hasValidRef(config)
        if __DEV__ then
             if((config.ref)~=(nil))and((type(config.ref))==("table"))then
                 if(config.ref).isReactWarning then
                     return false
                 end
             end
         end;
        return(config.ref)~=(nil)
    end;
    local function hasValidKey(config)
        if __DEV__ then
             if((config.key)~=(nil))and((type(config.key))==("table"))then
                 if(config.key).isReactWarning then
                     return false
                 end
             end
         end;
        return(config.key)~=(nil)
    end;
    local reactWarning={["isReactWarning"]=true};
    local function defineKeyPropWarningGetter(props,displayName)
        local warnAboutAccessingKey=function()
            if __DEV__ then
                 if not(specialPropKeyWarningShown)then
                     specialPropKeyWarningShown=true;
                    console.error("%s: `key` is not a prop. Trying to access it will result in `nil` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName)
                end
             end
         end;
        props.key=nil;
        setmetatable(props,{["__index"]=function(t,k)
            if(k)==("key")then
                 warnAboutAccessingKey();
                return reactWarning
             end;
            return nil
         end})
    end;
    local function defineRefPropWarningGetter(props,displayName)
        local warnAboutAccessingRef=function()
            if __DEV__ then
                 if not(specialPropRefWarningShown)then
                     specialPropRefWarningShown=true;
                    console.error("%s: `ref` is not a prop. Trying to access it will result in `nil` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName)
                end
             end
         end;
        props.ref=nil;
        setmetatable(props,{["__index"]=function(t,k)
            if(k)==("ref")then
                 warnAboutAccessingRef();
                return reactWarning
             end;
            return nil
         end})
    end;
    local function warnIfStringRefCannotBeAutoConverted(config)
        if __DEV__ then
             if((type(config.ref))==("string"))and(ReactCurrentOwner.current)then
                 local componentName=getComponentName(ReactCurrentOwner.current.type);
                if not(didWarnAboutStringRefs[componentName])then
                     error(string.format("Component \"%s\" contains the string ref \"%s\". Support for string refs has been removed. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref",(componentName)or("Unknown"),config.ref))
                end
             end
         end
     end;
    local function ReactElement(type_,key,ref,self,source,owner,props)
        local element={["type"]=type_,["key"]=key,["ref"]=ref,["props"]=props,["_owner"]=owner};
        element["\x24\x24typeof"]=REACT_ELEMENT_TYPE;
        if __DEV__ then
             local nonEnumerable={["validated"]=false};
            element._store=setmetatable({},{["__index"]=nonEnumerable,["__newindex"]=function(table,key,value)
                if(key)==("validated")then
                     nonEnumerable.validated=value
                 else
                     rawset(table,key,value)
                end
             end});
            setmetatable(element,{["__index"]={["_self"]=self,["_source"]=source}})
        end;
        return element
     end;
    exports.jsx=function(type,config,maybeKey)
        error("JSX is currently unsupported")
    end;
    exports.jsxDEV=function(type,config,maybeKey,source,self)
        error("JSX is currently unsupported");
        return nil
     end;
    local function createElement(type_,config,...)
        local props=if(config)~=(nil)then table.clone(config)else{};
        local key;
        local ref;
        local self;
        local source;
        if(config)~=(nil)then
             if hasValidRef(config)then
                 ref=((config)).ref;
                if __DEV__ then
                     warnIfStringRefCannotBeAutoConverted((config))
                end
             end;
            if hasValidKey(config)then
                 local configKey=(config).key;
                if(type(configKey))==("number")then
                     key=configKey
                 else
                     key=tostring(configKey)
                end
             end;
            source=if(((config)).__source)==(nil)then nil else((config)).__source;
            if(props.key)~=(nil)then
                 props.key=nil
             end;
            if(props.ref)~=(nil)then
                 props.ref=nil
             end;
            if(props.__self)~=(nil)then
                 props.__self=nil
             end;
            if(props.__source)~=(nil)then
                 props.__source=nil
             end
         end;
        local childrenLength=select("\x23",...);
        if(childrenLength)==(1)then
             props.children=select(1,...)
        elseif(childrenLength)>(1)then
             local childArray=table.create(childrenLength);
            for i=1,childrenLength do
                 local toInsert=select(i,...);
                table.insert(childArray,toInsert)
            end;
            if __DEV__ then
                 table.freeze(childArray)
            end;
            props.children=childArray
         end;
        if((type(type_))==("table"))and((type_).defaultProps)then
             local defaultProps=(type_).defaultProps;
            for propName,_ in(defaultProps)do
                 if(props[propName])==(nil)then
                     props[propName]=((defaultProps))[propName]
                end
             end
         end;
        if __DEV__ then
             if(key)or(ref)then
                 local displayName;
                if(type(type_))==("function")then
                     displayName=(debug.info(type_,"n"))or("<function>")
                elseif(type(type_))==("table")then
                     displayName=((((type_).displayName)or((type_).name)))or("Unknown")
                else
                     displayName=type_
                 end;
                if key then
                     defineKeyPropWarningGetter(props,displayName)
                end;
                if ref then
                     defineRefPropWarningGetter(props,displayName)
                end
             end;
            if(source)==(nil)then
                 source={["fileName"]=debug.info(3,"s"),["lineNumber"]=debug.info(3,"l")}
            end
         end;
        return ReactElement(type_,key,ref,self,source,ReactCurrentOwner.current,props)
    end;
    exports.createElement=createElement;
    exports.cloneAndReplaceKey=function(oldElement,newKey)
        local newElement=ReactElement(oldElement.type,newKey,oldElement.ref,oldElement._self,oldElement._source,oldElement._owner,oldElement.props);
        return newElement
     end;
    exports.cloneElement=function(element,config,...)
        if(element)==(nil)then
             error(Error.new(("React.cloneElement(...): The argument must be a React element, but you passed ")..(tostring(element))))
        end;
        local elementProps=element.props;
        local props=if(elementProps)~=(nil)then table.clone(elementProps)else{};
        local key=element.key;
        local ref=element.ref;
        local source=element._source;
        local owner=element._owner;
        if(config)~=(nil)then
             local configRef=config.ref;
            if(configRef)~=(nil)then
                 ref=configRef;
                owner=ReactCurrentOwner.current
             else
                 hasValidRef(config)
            end;
            local configKey=config.key;
            if(configKey)~=(nil)then
                 if(type(configKey))==("number")then
                     key=configKey
                 else
                     key=(configKey)or("nil")
                end
             else
                 hasValidKey((config))
            end
         end;
        local elementType=element.type;
        local defaultProps=if(type(elementType))==("table")then elementType.defaultProps else nil;
        if(config)~=(nil)then
             for propName,_ in config do
                 if(((config)[propName])~=(nil))and(not(RESERVED_PROPS[propName]))then
                     if(((config)[propName])==(nil))and((defaultProps)~=(nil))then
                        (props)[propName]=(defaultProps)[propName]
                    else
                        (props)[propName]=(config)[propName]
                    end
                 end
             end
         end;
        local childrenLength=select("\x23",...);
        if(childrenLength)==(1)then
             props.children=select(1,...)
        elseif(childrenLength)>(1)then
            (props).children={...}
        end;
        return ReactElement(element.type,key,ref,nil,source,owner,(props))
    end;
    exports.isValidElement=function(object)
        return((type(object))==("table"))and((object["\x24\x24typeof"])==(REACT_ELEMENT_TYPE))
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactCreateRef.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactCreateRef",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    local Binding=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactBinding.roblox");
    local exports={};
    exports.createRef=function()
        local binding,_=Binding.create(nil);
        local ref={};
        if _G.__DEV__ then
             binding._source=debug.traceback("Ref created at:",1)
        end;
        setmetatable(ref,{["__index"]=function(self,key)
            if(key)==("current")then
                 return binding:getValue()
            else
                 return(binding)[key]
            end
         end,["__newindex"]=function(self,key,value)
            if(key)==("current")then
                 Binding.update(binding,value)
            end;
            (binding)[key]=value
         end,["__tostring"]=function(self)
            return string.format("Ref(%s)",tostring(binding:getValue()))
        end});
        return(ref)
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactForwardRef.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactForwardRef",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local exports={};
    exports.forwardRef=function(render)
        if _G.__DEV__ then
             if((typeof(render))==("table"))and(((render)["\x24\x24typeof"])==(REACT_MEMO_TYPE))then
                 console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).")
            elseif(typeof(render))~=("function")then
                 console.error("forwardRef requires a render function but was given %s.",typeof(render))
            else
                 local argumentCount,_variadic=debug.info(render,"a");
                if((argumentCount)~=(0))and((argumentCount)~=(2))then
                     console.error("forwardRef render functions accept exactly two parameters: props and ref. %s",(function()
                        if(argumentCount)==(1)then
                             return"Did you forget to use the ref parameter?"
                        end;
                        return"Any additional parameter will be undefined."
                    end)())
                end
             end
         end;
        local elementType={["\x24\x24typeof"]=REACT_FORWARD_REF_TYPE,["render"]=render};
        if _G.__DEV__ then
             local ownName;
            setmetatable(elementType,{["__index"]=function(self,key)
                if(key)==("displayName")then
                     return ownName
                 end;
                return rawget(self,key)
            end,["__newindex"]=function(self,key,value)
                if(key)==("displayName")then
                     ownName=value
                 else
                     rawset(self,key,value)
                end
             end})
        end;
        return elementType
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactHooks.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactHooks",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    local ReactCurrentDispatcher=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSharedInternals.ReactCurrentDispatcher;
    type("not printable... yet");
    type("not printable... yet");
    local function resolveDispatcher()
        local dispatcher=ReactCurrentDispatcher.current;
        if _G.__DEV__ then
             if(dispatcher)==(nil)then
                 console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\x0a1. You might have mismatching versions of React and the renderer (such as React DOM)\x0a2. You might be breaking the Rules of Hooks\x0a3. You might have more than one copy of React in the same app\x0aSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.")
            end
         end;
        return dispatcher
     end;
    local exports={};
    local function useContext(Context,unstable_observedBits,...)
        local dispatcher=resolveDispatcher();
        if _G.__DEV__ then
             if(unstable_observedBits)~=(nil)then
                 console.error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s",unstable_observedBits,(((((typeof(unstable_observedBits))==("number"))and(Array.isArray({...}))))and("\x0a\x0aDid you call Array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks"))or(""))
            end;
            if((Context)._context)~=(nil)then
                 local realContext=(Context)._context;
                if(realContext.Consumer)==(Context)then
                     console.error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?")
                elseif(realContext.Provider)==(Context)then
                     console.error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?")
                end
             end
         end;
        return dispatcher.useContext(Context,unstable_observedBits)
    end;
    exports.useContext=useContext;
    local function useState(initialState,...)
        local dispatcher=resolveDispatcher();
        return dispatcher.useState(initialState,...)
    end;
    exports.useState=useState;
    local function useReducer(reducer,initialArg,init)
        local dispatcher=resolveDispatcher();
        return dispatcher.useReducer(reducer,initialArg,init)
    end;
    exports.useReducer=useReducer;
    local function useRef(initialValue)
        local dispatcher=resolveDispatcher();
        return dispatcher.useRef(initialValue)
    end;
    exports.useRef=useRef;
    local function useBinding(initialValue)
        local dispatcher=resolveDispatcher();
        return dispatcher.useBinding(initialValue)
    end;
    exports.useBinding=useBinding;
    local function useEffect(create,deps)
        local dispatcher=resolveDispatcher();
        return dispatcher.useEffect(create,deps)
    end;
    exports.useEffect=useEffect;
    local function useLayoutEffect(create,deps)
        local dispatcher=resolveDispatcher();
        return dispatcher.useLayoutEffect(create,deps)
    end;
    exports.useLayoutEffect=useLayoutEffect;
    local function useCallback(callback,deps)
        local dispatcher=resolveDispatcher();
        return dispatcher.useCallback(callback,deps)
    end;
    exports.useCallback=useCallback;
    local function useMemo(create,deps)
        local dispatcher=resolveDispatcher();
        return dispatcher.useMemo(create,deps)
    end;
    exports.useMemo=useMemo;
    local function useImperativeHandle(ref,create,deps)
        local dispatcher=resolveDispatcher();
        return dispatcher.useImperativeHandle(ref,create,deps)
    end;
    exports.useImperativeHandle=useImperativeHandle;
    local function useDebugValue(value,formatterFn)
        if _G.__DEV__ then
             local dispatcher=resolveDispatcher();
            return dispatcher.useDebugValue(value,formatterFn)
        end;
        return nil
     end;
    exports.useDebugValue=useDebugValue;
    exports.emptyObject={};
    exports.useOpaqueIdentifier=function()
        local dispatcher=resolveDispatcher();
        return dispatcher.useOpaqueIdentifier()
    end;
    exports.useMutableSource=function(source,getSnapshot,subscribe)
        local dispatcher=resolveDispatcher();
        return dispatcher.useMutableSource(source,getSnapshot,subscribe)
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactMemo.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactMemo",function()
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    local console=Shared.console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local Object=LuauPolyfill.Object;
    local inspect=LuauPolyfill.util.inspect;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactSymbols=Shared.ReactSymbols;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_ELEMENT_TYPE=ReactSymbols.REACT_ELEMENT_TYPE;
    local isValidElementType=Shared.isValidElementType;
    local getComponentName=Shared.getComponentName;
    local exports={};
    exports.memo=function(type_,compare)
        if _G.__DEV__ then
             local validType=isValidElementType(type_);
            if not(validType)then
                 local info="";
                if((type_)==(nil))or((((typeof(type_))==("table"))and((#(Object.keys(type_)))==(0))))then
                     info=(info)..((" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."))
                end;
                local typeString;
                if(type_)==(nil)then
                     typeString="nil"
                elseif Array.isArray(type_)then
                     typeString="array"
                elseif(((type_)~=(nil))and((typeof(type_))==("table")))and(((type_)["\x24\x24typeof"])==(REACT_ELEMENT_TYPE))then
                     typeString=string.format("<%s />",(getComponentName((type_).type))or("UNKNOWN"));
                    info=" Did you accidentally export a JSX literal or Element instead of a component?"
                else
                     typeString=typeof(type_);
                    if(type_)~=(nil)then
                         info=("\x0a")..(inspect(type_))
                    end
                 end;
                console.error("memo: The first argument must be a component. Instead received: `%s`.%s",typeString,info)
            end
         end;
        local elementType={["\x24\x24typeof"]=REACT_MEMO_TYPE,["type"]=type_,["compare"]=(compare)or(nil)};
        if _G.__DEV__ then
             local name;
            setmetatable(elementType,{["__index"]=function(self,key)
                if(key)==("displayName")then
                     return name
                 end;
                return rawget(self,key)
            end,["__newindex"]=function(self,key,value)
                if(key)==("displayName")then
                     name=value;
                    if((typeof(type_))==("table"))and(((type_).displayName)==(nil))then
                        (type_).displayName=name
                     end
                 else
                     rawset(self,key,value)
                end
             end})
        end;
        return elementType
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactContext.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactContext",function()
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    local console=Shared.console;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local REACT_PROVIDER_TYPE=ReactSymbols.REACT_PROVIDER_TYPE;
    local REACT_CONTEXT_TYPE=ReactSymbols.REACT_CONTEXT_TYPE;
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    exports.createContext=function(defaultValue,calculateChangedBits)
        local context={["\x24\x24typeof"]=REACT_CONTEXT_TYPE,["_calculateChangedBits"]=calculateChangedBits,["_currentValue"]=defaultValue,["_currentValue2"]=defaultValue,["_threadCount"]=0,["Provider"]=(nil),["Consumer"]=(nil),["displayName"]=nil,["_currentRenderer"]=nil,["_currentRenderer2"]=nil};
        context.Provider={["\x24\x24typeof"]=REACT_PROVIDER_TYPE,["_context"]=context};
        local hasWarnedAboutDisplayNameOnConsumer=false;
        if _G.__DEV__ then
             local Consumer={["\x24\x24typeof"]=REACT_CONTEXT_TYPE,["_context"]=context,["_calculateChangedBits"]=context._calculateChangedBits};
            setmetatable(Consumer,{["__index"]=function(self,key)
                if(key)==("_currentValue")then
                     return context._currentValue
                 elseif(key)==("_currentValue2")then
                     return context._currentValue2
                 elseif(key)==("_threadCount")then
                     return context._threadCount
                 elseif(key)==("displayName")then
                     return context.displayName
                 end;
                return nil
             end,["__newindex"]=function(self,key,value)
                if(key)==("_currentValue")then
                     context._currentValue=value
                 elseif(key)==("_currentValue2")then
                     context._currentValue2=value
                 elseif(key)==("_threadCount")then
                     context._threadCount=value
                 elseif(key)==("displayName")then
                     if not(hasWarnedAboutDisplayNameOnConsumer)then
                         console.warn(("Setting `displayName` on Context.Consumer has no effect. ")..(("You should set it directly on the context with Context.displayName = ")..((value)..("."))));
                        hasWarnedAboutDisplayNameOnConsumer=true
                     end
                 end
             end});
            context.Consumer=(Consumer)
        else
             context.Consumer=context
         end;
        if _G.__DEV__ then
             context._currentRenderer=nil;
            context._currentRenderer2=nil
         end;
        return context
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactBinding.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactBinding.roblox",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").ReactSymbols;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local Symbol=LuauPolyfill.Symbol;
    local createSignal=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react.createSignal.roblox");
    local BindingImpl=Symbol("BindingImpl");
    type("not printable... yet");
    local BindingInternalApi={};
    local bindingPrototype={};
    function bindingPrototype.getValue(binding)
        return BindingInternalApi.getValue(binding)
    end;
    function bindingPrototype.map(binding,predicate)
        return BindingInternalApi.map(binding,predicate)
    end;
    local BindingPublicMeta={["__index"]=bindingPrototype,["__tostring"]=function(self)
        return string.format("RoactBinding(%s)",tostring(self:getValue()))
    end};
    function BindingInternalApi.update(binding,newValue)
        return(binding[BindingImpl]).update(newValue)
    end;
    function BindingInternalApi.subscribe(binding,callback)
        return(binding[BindingImpl]).subscribe(callback)
    end;
    function BindingInternalApi.getValue(binding)
        return(binding[BindingImpl]):getValue()
    end;
    function BindingInternalApi.create(initialValue)
        local subscribe,fire=createSignal();
        local impl={["value"]=initialValue,["subscribe"]=subscribe};
        function impl.update(newValue)
            impl.value=newValue;
            fire(newValue)
        end;
        function impl.getValue()
            return impl.value
         end;
        local source;
        if _G.__DEV__ then
             source=debug.traceback("Binding created at:",3)
        end;
        return(setmetatable({["\x24\x24typeof"]=ReactSymbols.REACT_BINDING_TYPE,[BindingImpl]=impl,["_source"]=source},BindingPublicMeta)),impl.update
     end;
    function BindingInternalApi.map(upstreamBinding,predicate)
        if _G.__DEV__ then
             assert(((typeof(upstreamBinding))==("table"))and((upstreamBinding["\x24\x24typeof"])==(ReactSymbols.REACT_BINDING_TYPE)),"Expected `self` to be a binding");
            assert((typeof(predicate))==("function"),"Expected arg \x231 to be a function")
        end;
        local impl={};
        function impl.subscribe(callback)
            return BindingInternalApi.subscribe(upstreamBinding,function(newValue)
                callback(predicate(newValue))
            end)
        end;
        function impl.update(newValue)
            error("Bindings created by Binding:map(fn) cannot be updated directly",2)
        end;
        function impl.getValue()
            return predicate(upstreamBinding:getValue())
        end;
        local source;
        if _G.__DEV__ then
             source=debug.traceback("Mapped binding created at:",3)
        end;
        return(setmetatable({["\x24\x24typeof"]=ReactSymbols.REACT_BINDING_TYPE,[BindingImpl]=impl,["_source"]=source},BindingPublicMeta))
    end;
    function BindingInternalApi.join(upstreamBindings)
        if _G.__DEV__ then
             assert((typeof(upstreamBindings))==("table"),"Expected arg \x231 to be of type table");
            for key,value in upstreamBindings do
                 if((typeof(value))~=("table"))or(((value)["\x24\x24typeof"])~=(ReactSymbols.REACT_BINDING_TYPE))then
                     local message=("Expected arg \x231 to contain only bindings, but key %q had a non-binding value"):format(tostring(key));
                    error(message,2)
                end
             end
         end;
        local impl={};
        local function getValue()
            local value={};
            for key,upstream in pairs(upstreamBindings)do
                 value[key]=upstream:getValue()
            end;
            return value
         end;
        function impl.subscribe(callback)
            local disconnects={};
            for key,upstream in upstreamBindings do
                 disconnects[key]=BindingInternalApi.subscribe(upstream,function(newValue)
                    callback(getValue())
                end)
            end;
            return function()
                if(disconnects)==(nil)then
                     return
                 end;
                for _,disconnect in disconnects do
                     disconnect()
                end;
                disconnects=nil
             end
         end;
        function impl.update(newValue)
            error("Bindings created by joinBindings(...) cannot be updated directly",2)
        end;
        function impl.getValue()
            return getValue()
        end;
        local source;
        if _G.__DEV__ then
             source=debug.traceback("Joined binding created at:",2)
        end;
        return(setmetatable({["\x24\x24typeof"]=ReactSymbols.REACT_BINDING_TYPE,[BindingImpl]=impl,["_source"]=source},BindingPublicMeta))
    end;
    return BindingInternalApi

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\None.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.None.roblox",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.luau-polyfill");
    return LuauPolyfill.Object.None

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactTypes");
    local flowtypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.flowtypes.roblox");
    local ReactElementType=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactElementType");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig");
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals");
    local ErrorHandling=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ErrorHandling.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{["checkPropTypes"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.checkPropTypes"),["console"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console"),["ConsolePatchingDev"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ConsolePatchingDev.roblox"),["consoleWithStackDev"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.consoleWithStackDev"),["enqueueTask"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.enqueueTask.roblox"),["ExecutionEnvironment"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ExecutionEnvironment"),["formatProdErrorMessage"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.formatProdErrorMessage"),["getComponentName"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.getComponentName"),["invariant"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant"),["invokeGuardedCallbackImpl"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invokeGuardedCallbackImpl"),["isValidElementType"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.isValidElementType"),["objectIs"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.objectIs"),["ReactComponentStackFrame"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactComponentStackFrame"),["ReactElementType"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactElementType"),["ReactErrorUtils"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactErrorUtils"),["ReactFeatureFlags"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFeatureFlags"),["ReactInstanceMap"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactInstanceMap"),["ReactSharedInternals"]=ReactSharedInternals,["ReactFiberHostConfig"]=ReactFiberHostConfig,["ReactSymbols"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSymbols"),["ReactVersion"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactVersion"),["shallowEqual"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.shallowEqual"),["UninitializedState"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.UninitializedState.roblox"),["ReactTypes"]=ReactTypes,["describeError"]=ErrorHandling.describeError,["errorToString"]=ErrorHandling.errorToString,["parseReactError"]=ErrorHandling.parseReactError,["Symbol"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Symbol.roblox"),["Type"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Type.roblox"),["Change"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Change"),["Event"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Event"),["Tag"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Tag")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-reconciler.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\shared.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared",function()
    return tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRobloxRoot.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxRoot",function()
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReconcilerTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRobloxComponentTree=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponentTree");
    local markContainerAsRoot=ReactRobloxComponentTree.markContainerAsRoot;
    local unmarkContainerAsRoot=ReactRobloxComponentTree.unmarkContainerAsRoot;
    local ReactFiberReconciler=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.ReactReconciler.roblox");
    local createContainer=ReactFiberReconciler.createContainer;
    local updateContainer=ReactFiberReconciler.updateContainer;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").invariant;
    local enableEagerRootListeners=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactFeatureFlags.enableEagerRootListeners;
    local flushSync=ReactFiberReconciler.flushSync;
    local flushPassiveEffects=ReactFiberReconciler.flushPassiveEffects;
    local BlockingRoot=ReactFiberReconciler.ReactRootTags.BlockingRoot;
    local ConcurrentRoot=ReactFiberReconciler.ReactRootTags.ConcurrentRoot;
    local LegacyRoot=ReactFiberReconciler.ReactRootTags.LegacyRoot;
    local createRootImpl;
    local ReactRobloxRoot={};
    ReactRobloxRoot.__index=ReactRobloxRoot;
    function ReactRobloxRoot.new(container,options)
        local root=(setmetatable({},ReactRobloxRoot));
        root._internalRoot=createRootImpl(container,ConcurrentRoot,options);
        return root
     end;
    local function createBlockingRoot(container,tag,options)
        local root=(setmetatable({},ReactRobloxRoot));
        root._internalRoot=createRootImpl(container,tag,options);
        return root
     end;
    function ReactRobloxRoot:render(children)
        local root=self._internalRoot;
        updateContainer(children,root,nil)
    end;
    function ReactRobloxRoot:unmount()
        local root=self._internalRoot;
        local container=root.containerInfo;
        flushSync(function()
            updateContainer(nil,root,nil,function()
                unmarkContainerAsRoot(container)
            end)
        end);
        flushPassiveEffects()
    end;
    createRootImpl=function(container,tag,options)
        local hydrate=((options)~=(nil))and((options.hydrate)==(true));
        local hydrationCallbacks=if(options)~=(nil)then options.hydrationOptions else nil;
        local mutableSources=(((((options)~=(nil))and((options.hydrationOptions)~=(nil)))and(options.hydrationOptions.mutableSources)))or(nil);
        local root=createContainer(container,tag,hydrate,hydrationCallbacks);
        markContainerAsRoot(root.current,container);
        if enableEagerRootListeners then
            
         end;
        if mutableSources then
            
         end;
        return root
     end;
    local exports={};
    local function isValidContainer(node)
        return(typeof(node))==("Instance")
    end;
    exports.isValidContainer=isValidContainer;
    exports.createRoot=function(container,options)
        invariant(isValidContainer(container),"createRoot(...): Target container is not a Roblox Instance.");
        warnIfReactDOMContainerInDEV(container);
        return ReactRobloxRoot.new(container,options)
    end;
    exports.createBlockingRoot=function(container,options)
        invariant(isValidContainer(container),"createRoot(...): Target container is not a Roblox Instance.");
        warnIfReactDOMContainerInDEV(container);
        return createBlockingRoot(container,BlockingRoot,options)
    end;
    exports.createLegacyRoot=function(container,options)
        return createBlockingRoot(container,LegacyRoot,options)
    end;
    function warnIfReactDOMContainerInDEV(container)
        if _G.__DEV__ then
            
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\ReactReconciler.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.ReactReconciler.roblox",function()
    local initializeReconciler=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler");
    local ReactRobloxHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostConfig");
    return initializeReconciler(ReactRobloxHostConfig)

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRobloxComponentTree.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponentTree",function()
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-reconciler");
    type("not printable... yet");
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared");
    type("not printable... yet");
    local ReactWorkTags;
    local HostComponent;
    local HostText;
    local HostRoot;
    local SuspenseComponent;
    local getParentSuspenseInstance;
    local invariant=Shared.invariant;
    local exports={};
    local containerToRoot={};
    local instanceToFiber={};
    local instanceToProps={};
    local randomKey=string.sub(tostring(math.random()),3);
    local internalInstanceKey=("__reactFiber\x24")..(randomKey);
    local internalContainerInstanceKey=("__reactContainer\x24")..(randomKey);
    exports.precacheFiberNode=function(hostInst,node)
        instanceToFiber[node]=hostInst
     end;
    exports.uncacheFiberNode=function(node)
        instanceToFiber[node]=nil;
        instanceToProps[node]=nil
     end;
    exports.markContainerAsRoot=function(hostRoot,node)
        containerToRoot[node]=hostRoot
     end;
    exports.unmarkContainerAsRoot=function(node)
        containerToRoot[node]=nil
     end;
    exports.isContainerMarkedAsRoot=function(node)
        return not(not(containerToRoot[node]))
    end;
    exports.getClosestInstanceFromNode=function(targetNode)
        local targetInst=instanceToFiber[targetNode];
        if targetInst then
             return targetInst
         end;
        local parentNode=targetNode.Parent;
        while parentNode do
             targetInst=instanceToFiber[parentNode];
            if targetInst then
                 local alternate=targetInst.alternate;
                if((targetInst.child)~=(nil))or((((alternate)~=(nil))and((alternate.child)~=(nil))))then
                     if(getParentSuspenseInstance)==(nil)then
                         getParentSuspenseInstance=(tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostConfig")).getParentSuspenseInstance
                     end;
                    local suspenseInstance=getParentSuspenseInstance(targetNode);
                    while(suspenseInstance)~=(nil)do
                         local targetSuspenseInst=instanceToFiber[suspenseInstance];
                        if targetSuspenseInst then
                             return targetSuspenseInst
                         end;
                        suspenseInstance=getParentSuspenseInstance(suspenseInstance)
                    end
                 end;
                return targetInst
             end;
            targetNode=parentNode;
            parentNode=targetNode.Parent
         end;
        return nil
     end;
    exports.getInstanceFromNode=function(node)
        if(ReactWorkTags)==(nil)then
             local ReactReconciler=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.ReactReconciler.roblox");
            ReactWorkTags=ReactReconciler.ReactWorkTags;
            HostComponent=ReactWorkTags.HostComponent;
            HostText=ReactWorkTags.HostComponent;
            HostRoot=ReactWorkTags.HostComponent;
            SuspenseComponent=ReactWorkTags.HostComponent
         end;
        local inst=((node)[internalInstanceKey])or((node)[internalContainerInstanceKey]);
        if inst then
             if((((inst.tag)==(HostComponent))or((inst.tag)==(HostText)))or((inst.tag)==(SuspenseComponent)))or((inst.tag)==(HostRoot))then
                 return inst
             else
                 return nil
             end
         end;
        return nil
     end;
    exports.getNodeFromInstance=function(inst)
        if((inst.tag)==(HostComponent))or((inst.tag)==(HostText))then
             return inst.stateNode
         end;
        invariant(false,"getNodeFromInstance: Invalid argument.");
        error("getNodeFromInstance: Invalid argument.")
    end;
    exports.getFiberCurrentPropsFromNode=function(node)
        return instanceToProps[node]
    end;
    exports.updateFiberProps=function(node,props)
        instanceToProps[node]=props
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\boolean.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.boolean",function()
    return tkpack.include("game.Packages._Index.jsdotlua_boolean@1.2.7.boolean")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\collections.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.collections",function()
    return tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\console.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.console",function()
    return tkpack.include("game.Packages._Index.jsdotlua_console@1.2.7.console")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\math.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.math",function()
    return tkpack.include("game.Packages._Index.jsdotlua_math@1.2.7.math")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\number.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.number",function()
    return tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\string.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.string",function()
    return tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\symbol-luau.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.symbol-luau",function()
    return tkpack.include("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\timers.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.timers",function()
    return tkpack.include("game.Packages._Index.jsdotlua_timers@1.2.7.timers")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\es7-types.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.es7-types",function()
    return tkpack.include("game.Packages._Index.jsdotlua_es7-types@1.2.7.es7-types")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\AssertionError\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.AssertionError",function()
    local AssertionErrorModule=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.AssertionError.AssertionError.global");
    type("not printable... yet");
    return AssertionErrorModule.AssertionError

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\Error\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Error",function()
    local Error=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Error.Error.global");
    type("not printable... yet");
    return Error

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\Promise.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Promise",function()
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\extends.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.extends",function()
    return function(parent,childName,constructor)
        local Child={};
        Child.__index=Child;
        Child.__tostring=function(self)
            return getmetatable(parent).__tostring(self)
        end;
        local mt={};
        Child.new=function(...)
            local self={};
            constructor(self,...);
            return setmetatable(self,Child)
        end;
        if((typeof(getmetatable(parent)))==("table"))and(getmetatable(parent).__call)then
             mt.__call=function(_,...)
                return Child.new(...)
            end
         end;
        mt.__index=parent;
        mt.__tostring=function(self)
            if(self)==(Child)then
                 return tostring(childName)
            end;
            return getmetatable(parent).__tostring(self)
        end;
        setmetatable(Child,mt);
        return Child
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\instance-of.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.instance-of",function()
    return tkpack.include("game.Packages._Index.jsdotlua_instance-of@1.2.7.instance-of")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\ReactNoopUpdateQueue.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.ReactNoopUpdateQueue",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.shared").console;
    local didWarnStateUpdateForUnmountedComponent={};
    local function warnNoop(publicInstance,callerName)
        if _G.__DEV__ then
             local componentName=(publicInstance.__componentName)or("ReactClass");
            local warningKey=(componentName)..((".")..(callerName));
            if didWarnStateUpdateForUnmountedComponent[warningKey]then
                 return
             end;
            console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `self.state` directly with the desired state in the %s component's `init` method.",callerName,componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey]=true
         end
     end;
    local ReactNoopUpdateQueue={["isMounted"]=function(publicInstance)
        return false
     end,["enqueueForceUpdate"]=function(publicInstance,callback,callerName)
        warnNoop(publicInstance,"forceUpdate")
    end,["enqueueReplaceState"]=function(publicInstance,completeState,callback,callerName)
        warnNoop(publicInstance,"replaceState")
    end,["enqueueSetState"]=function(publicInstance,partialState,callback,callerName)
        warnNoop(publicInstance,"setState")
    end};
    return ReactNoopUpdateQueue

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react@17.2.1\react\src\createSignal.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react@17.2.1.react.createSignal.roblox",function()
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local function createSignal()
        local connections={};
        local suspendedConnections={};
        local firing=false;
        local function subscribe(callback)
            assert((typeof(callback))==("function"),"Can only subscribe to signals with a function.");
            local connection={["callback"]=callback,["disconnected"]=false};
            if(firing)and(not(connections[callback]))then
                 suspendedConnections[callback]=connection
             end;
            connections[callback]=connection;
            local function disconnect()
                assert(not(connection.disconnected),"Listeners can only be disconnected once.");
                connection.disconnected=true;
                connections[callback]=nil;
                suspendedConnections[callback]=nil
             end;
            return disconnect
         end;
        local function fire(...)
            firing=true;
            for callback,connection in connections do
                 if(not(connection.disconnected))and(not(suspendedConnections[callback]))then
                     callback(...)
                end
             end;
            firing=false;
            table.clear(suspendedConnections)
        end;
        return subscribe,fire
     end;
    return createSignal

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\luau-polyfill.lua
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill",function()
    return tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactTypes.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactTypes",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local flowtypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.flowtypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    exports.DiscreteEvent=0;
    exports.UserBlockingEvent=1;
    exports.ContinuousEvent=2;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\flowtypes.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.flowtypes.roblox",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactElementType.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactElementType",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    local flowtypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.flowtypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactFiberHostConfig\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig",function()
    type("not printable... yet");
    type("not printable... yet");
    return{["WithNoHydration"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoHydration"),["WithNoPersistence"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoPersistence"),["WithNoTestSelectors"]=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoTestSelectors")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill").console;
    local function onlyInTestError(functionName)
        return function()
            console.error((functionName)..(" is only available in tests, not in production"))
        end
     end;
    local ReactCurrentDispatcher=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentDispatcher");
    type("not printable... yet");
    local ReactCurrentBatchConfig=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentBatchConfig");
    local ReactCurrentOwner=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentOwner");
    local ReactDebugCurrentFrame=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactDebugCurrentFrame");
    local IsSomeRendererActing=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.IsSomeRendererActing");
    local ReactSharedInternals={["ReactCurrentDispatcher"]=ReactCurrentDispatcher,["ReactCurrentBatchConfig"]=ReactCurrentBatchConfig,["ReactCurrentOwner"]=ReactCurrentOwner,["IsSomeRendererActing"]=IsSomeRendererActing,["ReactDebugCurrentFrame"]=if _G.__DEV__ then ReactDebugCurrentFrame else{["setExtraStackFrame"]=function(_)
        onlyInTestError("setExtraStackFrame")
    end}};
    return ReactSharedInternals

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ErrorHandling.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ErrorHandling.roblox",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Error=LuauPolyfill.Error;
    local inspect=LuauPolyfill.util.inspect;
    local DIVIDER="\x0a------ Error caught by React ------\x0a";
    local function describeError(e)
        if(typeof(e))==("string")then
             local _,endOfStackFrame=string.find(e,":[%d]+: ");
            local message=if endOfStackFrame then string.sub(e,(endOfStackFrame)+(1))else e;
            local err=LuauPolyfill.Error.new(message);
            err.stack=debug.traceback(nil,2);
            return err
         end;
        return e
     end;
    local function errorToString(error_)
        local errorString;
        if(typeof(error_))==("table")then
             if((error_).message)and((error_).stack)then
                 errorString=(DIVIDER)..(((error_).message)..((DIVIDER)..(tostring((error_).stack))))
            else
                 errorString=inspect(error_)
            end
         else
             errorString=inspect(error_)
        end;
        return errorString
     end;
    local function parseReactError(error_)
        local split=string.split(error_,DIVIDER);
        if(#(split))==(3)then
             local rethrow,message,stack=table.unpack(split);
            local newError=Error.new(message);
            newError.stack=stack;
            return newError,rethrow
         else
             local newError=Error.new(error_);
            newError.stack=nil;
            return newError,""
        end
     end;
    return{["describeError"]=describeError,["errorToString"]=errorToString,["parseReactError"]=parseReactError,["__ERROR_DIVIDER"]=DIVIDER}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\checkPropTypes.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.checkPropTypes",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local Error=LuauPolyfill.Error;
    type("not printable... yet");
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console");
    local loggedTypeFailures={};
    local ReactComponentStackFrame=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactComponentStackFrame");
    local describeUnknownElementTypeFrameInDEV=ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals");
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ErrorHandling.roblox").describeError;
    local ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;
    local function setCurrentlyValidatingElement(element)
        if _G.__DEV__ then
             if element then
                 local owner=element._owner;
                local stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,if(owner)~=(nil)then owner.type else nil);
                (ReactDebugCurrentFrame.setExtraStackFrame)(stack)
            else
                (ReactDebugCurrentFrame.setExtraStackFrame)(nil)
            end
         end
     end;
    local function checkPropTypes(propTypes,validateProps,props,location,componentName,element)
        if(_G.__DEV__)or(_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if(propTypes)and(validateProps)then
                 console.warn(("You've defined both propTypes and validateProps on ")..(((componentName)or("a component"))))
            end;
            if validateProps then
                 if(typeof(validateProps))~=("function")then
                     console.error(("validateProps must be a function, but it is a %s.\x0aCheck the definition of the component %q."):format(typeof(validateProps),(componentName)or("")))
                else
                     local success,failureReason=validateProps(props);
                    if not(success)then
                         failureReason=(failureReason)or("<Validator function did not supply a message>");
                        local message=string.format("validateProps failed on a %s type in %s: %s",location,(componentName)or("<UNKNOWN Component>"),tostring(failureReason));
                        error(message)
                    end
                 end
             end;
            if propTypes then
                 assert((typeof(propTypes))==("table"),"propTypes needs to be a table");
                for typeSpecName,_ in propTypes do
                     local _,result=xpcall(function()
                        if(typeof(propTypes[typeSpecName]))~=("function")then
                             local err=Error.new((((componentName)or("React class")))..((": ")..((location)..((" type `")..((typeSpecName)..(("` is invalid; ")..(("it must be a function, usually from the `prop-types` package, but received `")..((typeof(propTypes[typeSpecName]))..("`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.")))))))));
                            err.name="Invariant Violation";
                            error(err)
                        end;
                        return(propTypes[typeSpecName])(props,typeSpecName,componentName,location,nil,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")
                    end,describeError);
                    local isErrorObject=(typeof(result))==("table");
                    if((result)~=(nil))and(not(isErrorObject))then
                         setCurrentlyValidatingElement(element);
                        console.error(string.format("%s: type specification of %s `%s` is invalid; the type checker function must return `nil` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",(componentName)or("React class"),location,typeSpecName,typeof(result)));
                        setCurrentlyValidatingElement(nil)
                    end;
                    if(isErrorObject)and((loggedTypeFailures[(result).message])==(nil))then
                         loggedTypeFailures[tostring((result).message)]=true;
                        setCurrentlyValidatingElement(element);
                        console.warn(string.format("Failed %s type: %s",location,tostring((result).message)));
                        setCurrentlyValidatingElement(nil)
                    end
                 end
             end
         end
     end;
    return checkPropTypes

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\console.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local console=LuauPolyfill.console;
    local consoleWithStackDev=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.consoleWithStackDev");
    if _G.__DEV__ then
         local newConsole=setmetatable({["warn"]=consoleWithStackDev.warn,["error"]=consoleWithStackDev.error},{["__index"]=console});
        return newConsole
     end;
    return console

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ConsolePatchingDev.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ConsolePatchingDev.roblox",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console");
    local disabledDepth=0;
    local prevLog;
    local prevInfo;
    local prevWarn;
    local prevError;
    local prevGroup;
    local prevGroupCollapsed;
    local prevGroupEnd;
    local disabledLog=function()
        
    end;
    local exports={};
    exports.disabledLog=disabledLog;
    exports.disableLogs=function()
        if _G.__DEV__ then
             if(disabledDepth)==(0)then
                 prevLog=console.log;
                prevInfo=console.info;
                prevWarn=console.warn;
                prevError=console.error;
                prevGroup=console.group;
                prevGroupCollapsed=console.groupCollapsed;
                prevGroupEnd=console.groupEnd;
                console.info=disabledLog;
                console.log=disabledLog;
                console.warn=disabledLog;
                console.error=disabledLog;
                console.group=disabledLog;
                console.groupCollapsed=disabledLog;
                console.groupEnd=disabledLog
             end;
            disabledDepth=(disabledDepth)+(1)
        end
     end;
    exports.reenableLogs=function()
        if _G.__DEV__ then
             disabledDepth=(disabledDepth)-(1);
            if(disabledDepth)==(0)then
                 console.log=prevLog;
                console.info=prevInfo;
                console.warn=prevWarn;
                console.error=prevError;
                console.group=prevGroup;
                console.groupCollapsed=prevGroupCollapsed;
                console.groupEnd=prevGroupEnd
             end;
            if(disabledDepth)<(0)then
                 console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")
            end
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\consoleWithStackDev.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.consoleWithStackDev",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local console=LuauPolyfill.console;
    local Array=LuauPolyfill.Array;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals");
    local printWarning;
    local exports={};
    exports.warn=function(format,...)
        if _G.__DEV__ then
             printWarning("warn",format,{...})
        end
     end;
    exports.error=function(format,...)
        if _G.__DEV__ then
             printWarning("error",format,{...})
        end
     end;
    function printWarning(level,format,args)
        if _G.__DEV__ then
             local ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;
            local stack=ReactDebugCurrentFrame.getStackAddendum();
            if(stack)~=("")then
                 format..="%s";
                args=Array.slice(args,1);
                table.insert(args,stack)
            end;
            local argsWithFormat=Array.map(args,tostring);
            table.insert(argsWithFormat,1,("Warning: ")..(format));
            console[level](unpack(argsWithFormat))
        end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\enqueueTask.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.enqueueTask.roblox",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local setTimeout=LuauPolyfill.setTimeout;
    return function(task)
        return setTimeout(task,0)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ExecutionEnvironment.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ExecutionEnvironment",function()
    local exports={};
    exports.canUseDOM=function()
        return false
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\formatProdErrorMessage.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.formatProdErrorMessage",function()
    local HttpService=game:GetService("HttpService");
    local function formatProdErrorMessage(code,...)
        local url=("https://reactjs.org/docs/error-decoder.html?invariant=")..(tostring(code));
        local argsLength=select("\x23",...);
        for i=1,argsLength,1 do
             url=(url)..(("&args[]=")..(HttpService:UrlEncode(select(i,...))))
        end;
        return string.format("Minified React error \x23%d; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings.",code,url)
    end;
    return formatProdErrorMessage

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\getComponentName.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.getComponentName",function()
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console");
    type("not printable... yet");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSymbols");
    local REACT_CONTEXT_TYPE=ReactSymbols.REACT_CONTEXT_TYPE;
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local REACT_FRAGMENT_TYPE=ReactSymbols.REACT_FRAGMENT_TYPE;
    local REACT_PORTAL_TYPE=ReactSymbols.REACT_PORTAL_TYPE;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_PROFILER_TYPE=ReactSymbols.REACT_PROFILER_TYPE;
    local REACT_PROVIDER_TYPE=ReactSymbols.REACT_PROVIDER_TYPE;
    local REACT_STRICT_MODE_TYPE=ReactSymbols.REACT_STRICT_MODE_TYPE;
    local REACT_SUSPENSE_TYPE=ReactSymbols.REACT_SUSPENSE_TYPE;
    local REACT_SUSPENSE_LIST_TYPE=ReactSymbols.REACT_SUSPENSE_LIST_TYPE;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local REACT_BLOCK_TYPE=ReactSymbols.REACT_BLOCK_TYPE;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactTypes");
    type("not printable... yet");
    type("not printable... yet");
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ErrorHandling.roblox").describeError;
    local function getWrappedName(outerType,innerType,wrapperName)
        local functionName="<function>";
        if(typeof(innerType))==("table")then
             functionName=((innerType.displayName)or(innerType.name))or("")
        end;
        return(outerType.displayName)or(((((functionName)~=(""))and(string.format("%s(%s)",wrapperName,functionName)))or(wrapperName)))
    end;
    local function getContextName(type)
        return(type.displayName)or("Context")
    end;
    local function getComponentName(type)
        if(type)==(nil)then
             return nil
         end;
        local typeofType=typeof(type);
        if _G.__DEV__ then
             if((typeofType)==("table"))and((typeof(type.tag))==("number"))then
                 console.warn("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.")
            end
         end;
        if(typeofType)==("function")then
             local name=debug.info((type),"n");
            if(name)and((string.len(name))>(0))then
                 return name
             else
                 return nil
             end
         end;
        if(typeofType)==("string")then
             return(type)
        end;
        if(type)==(REACT_FRAGMENT_TYPE)then
             return"Fragment"
        elseif(type)==(REACT_PORTAL_TYPE)then
             return"Portal"
        elseif(type)==(REACT_PROFILER_TYPE)then
             return"Profiler"
        elseif(type)==(REACT_STRICT_MODE_TYPE)then
             return"StrictMode"
        elseif(type)==(REACT_SUSPENSE_TYPE)then
             return"Suspense"
        elseif(type)==(REACT_SUSPENSE_LIST_TYPE)then
             return"SuspenseList"
        end;
        if(typeofType)==("table")then
             local typeProp=type["\x24\x24typeof"];
            if(typeProp)==(REACT_CONTEXT_TYPE)then
                 local context=type;
                return(getContextName(context))..(".Consumer")
            elseif(typeProp)==(REACT_PROVIDER_TYPE)then
                 local provider=type;
                return(getContextName(provider._context))..(".Provider")
            elseif(typeProp)==(REACT_FORWARD_REF_TYPE)then
                 return getWrappedName(type,type.render,"ForwardRef")
            elseif(typeProp)==(REACT_MEMO_TYPE)then
                 return getComponentName(type.type)
            elseif(typeProp)==(REACT_BLOCK_TYPE)then
                 return getComponentName(type._render)
            elseif(typeProp)==(REACT_LAZY_TYPE)then
                 local lazyComponent=type;
                local payload=lazyComponent._payload;
                local init=lazyComponent._init;
                local ok,result=xpcall(init,describeError,payload);
                if ok then
                     return getComponentName(result)
                else
                     return nil
                 end
             else
                 if type.displayName then
                     return type.displayName
                 end;
                if type.name then
                     return type.name
                 end;
                local mt=getmetatable(type);
                if(mt)and(rawget(mt,"__tostring"))then
                     return tostring(type)
                end
             end
         end;
        return nil
     end;
    return getComponentName

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\invariant.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local Error=LuauPolyfill.Error;
    local function invariant(condition,format,...)
        if not(condition)then
             error(Error(string.format(format,...)))
        end
     end;
    return invariant

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\invokeGuardedCallbackImpl.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invokeGuardedCallbackImpl",function()
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ErrorHandling.roblox").describeError;
    local function invokeGuardedCallbackProd(reporter,name,func,context,...)
        local ok,result;
        if not(_G.__YOLO__)then
             if(context)==(nil)then
                 ok,result=xpcall(func,describeError,...)
            else
                 ok,result=xpcall(func,describeError,context,...)
            end
         else
             ok=true;
            if(context)==(nil)then
                 func(...)
            else
                 func(context,...)
            end
         end;
        if not(ok)then
             reporter.onError(result)
        end
     end;
    local invokeGuardedCallbackImpl=invokeGuardedCallbackProd;
    if _G.__DEV__ then
        
     end;
    return invokeGuardedCallbackImpl

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\isValidElementType.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.isValidElementType",function()
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSymbols");
    local REACT_CONTEXT_TYPE=ReactSymbols.REACT_CONTEXT_TYPE;
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local REACT_FRAGMENT_TYPE=ReactSymbols.REACT_FRAGMENT_TYPE;
    local REACT_PROFILER_TYPE=ReactSymbols.REACT_PROFILER_TYPE;
    local REACT_PROVIDER_TYPE=ReactSymbols.REACT_PROVIDER_TYPE;
    local REACT_DEBUG_TRACING_MODE_TYPE=ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE;
    local REACT_STRICT_MODE_TYPE=ReactSymbols.REACT_STRICT_MODE_TYPE;
    local REACT_SUSPENSE_TYPE=ReactSymbols.REACT_SUSPENSE_TYPE;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local REACT_FUNDAMENTAL_TYPE=ReactSymbols.REACT_FUNDAMENTAL_TYPE;
    local REACT_BLOCK_TYPE=ReactSymbols.REACT_BLOCK_TYPE;
    local REACT_SERVER_BLOCK_TYPE=ReactSymbols.REACT_SERVER_BLOCK_TYPE;
    local REACT_LEGACY_HIDDEN_TYPE=ReactSymbols.REACT_LEGACY_HIDDEN_TYPE;
    return function(type)
        local typeofType=typeof(type);
        if((typeofType)==("string"))or((typeofType)==("function"))then
             return true
         end;
        if((((((type)==(REACT_FRAGMENT_TYPE))or((type)==(REACT_PROFILER_TYPE)))or((type)==(REACT_DEBUG_TRACING_MODE_TYPE)))or((type)==(REACT_STRICT_MODE_TYPE)))or((type)==(REACT_SUSPENSE_TYPE)))or((type)==(REACT_LEGACY_HIDDEN_TYPE))then
             return true
         end;
        if(typeofType)==("table")then
             if type.isReactComponent then
                 return true
             end;
            if((((((((type["\x24\x24typeof"])==(REACT_LAZY_TYPE))or((type["\x24\x24typeof"])==(REACT_MEMO_TYPE)))or((type["\x24\x24typeof"])==(REACT_PROVIDER_TYPE)))or((type["\x24\x24typeof"])==(REACT_CONTEXT_TYPE)))or((type["\x24\x24typeof"])==(REACT_FORWARD_REF_TYPE)))or((type["\x24\x24typeof"])==(REACT_FUNDAMENTAL_TYPE)))or((type["\x24\x24typeof"])==(REACT_BLOCK_TYPE)))or((type[1])==(REACT_SERVER_BLOCK_TYPE))then
                 return true
             end
         end;
        return false
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\objectIs.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.objectIs",function()
    local function is(x,y)
        return(((x)==(y))and((((x)~=(0))or(((1)/(x))==((1)/(y))))))or(((x)~=(x))and((y)~=(y)))
    end;
    local objectIs=is;
    return objectIs

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactComponentStackFrame.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactComponentStackFrame",function()
    type("not printable... yet");
    type("not printable... yet");
    local ReactElementType=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactElementType");
    type("not printable... yet");
    local flowtypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.flowtypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSymbols");
    local REACT_SUSPENSE_TYPE=ReactSymbols.REACT_SUSPENSE_TYPE;
    local REACT_SUSPENSE_LIST_TYPE=ReactSymbols.REACT_SUSPENSE_LIST_TYPE;
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_BLOCK_TYPE=ReactSymbols.REACT_BLOCK_TYPE;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local ConsolePatchingDev=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ConsolePatchingDev.roblox");
    local disableLogs=ConsolePatchingDev.disableLogs;
    local reenableLogs=ConsolePatchingDev.reenableLogs;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals");
    local ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;
    local prefix="    in ";
    local describeComponentFrame;
    local describeFunctionComponentFrame;
    local function describeOwner(owner)
        if(type(owner))==("function")then
             return debug.info(owner,"n")
        elseif(type(owner))==("table")then
             return tostring(owner)
        end;
        return nil
     end;
    local function describeBuiltInComponentFrame(name,source,owner)
        local ownerName;
        if(_G.__DEV__)and(owner)then
             ownerName=describeOwner(owner)
        end;
        return describeComponentFrame(name,source,ownerName)
    end;
    local reentry=false;
    local componentFrameCache;
    if _G.__DEV__ then
         componentFrameCache=setmetatable({},{["__mode"]="k"})
    end;
    local function describeNativeComponentFrame(fn,construct)
        if(not(fn))or(reentry)then
             return""
        end;
        if _G.__DEV__ then
             local frame=componentFrameCache[fn];
            if(frame)~=(nil)then
                 return frame
             end
         end;
        local control;
        reentry=true;
        local previousDispatcher;
        if _G.__DEV__ then
             previousDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=nil;
            disableLogs()
        end;
        local traceback;
        local _,sample=xpcall(function()
            if construct then
                
             else
                 local _,x=pcall(function()
                    traceback=debug.traceback();
                    error({["stack"]=traceback})
                end);
                control=x;
                (fn)()
            end
         end,function(message)
            return{["message"]=message,["stack"]=traceback}
        end);
        local earlyOutValue;
        if((sample)and(control))and((type(sample.stack))==("string"))then
             local sampleLines=string.split(sample.stack,"\x0a");
            local controlLines=string.split(control.stack,"\x0a");
            local sampleIndex=(#(sampleLines))-(1);
            local controlIndex=(#(controlLines))-(1);
            while(((sampleIndex)>=(2))and((controlIndex)>=(0)))and((sampleLines[sampleIndex])~=(controlLines[controlIndex]))do
                 controlIndex=(controlIndex)-(1)
            end;
            while((sampleIndex)>=(3))and((controlIndex)>=(1))do
                 sampleIndex=(sampleIndex)-(1);
                controlIndex=(controlIndex)-(1);
                if(sampleLines[sampleIndex])~=(controlLines[controlIndex])then
                     if((sampleIndex)~=(1))or((controlIndex)~=(1))then
                         repeat
                             sampleIndex=(sampleIndex)-(1);
                            controlIndex=(controlIndex)-(1);
                            if((controlIndex)<(0))or((sampleLines[sampleIndex])~=(controlLines[controlIndex]))then
                                 local frame=("\x0a")..((prefix)..(sampleLines[sampleIndex]));
                                if _G.__DEV__ then
                                     componentFrameCache[fn]=frame
                                 end;
                                earlyOutValue=frame
                             end
                         until not((((sampleIndex)>=(3))and((controlIndex)>=(1))))
                    end;
                    break
                 end
             end
         end;
        reentry=false;
        if _G.__DEV__ then
             ReactCurrentDispatcher.current=previousDispatcher;
            reenableLogs()
        end;
        if(earlyOutValue)~=(nil)then
             return earlyOutValue
         end;
        local name=if(type(fn))==("function")then debug.info(fn,"n")else if(type(fn))==("table")then tostring(fn)else"";
        local syntheticFrame="";
        if((name)~=(nil))and((name)~=(""))then
             syntheticFrame=describeBuiltInComponentFrame(name)
        end;
        if _G.__DEV__ then
             componentFrameCache[fn]=syntheticFrame
         end;
        return syntheticFrame
     end;
    local BEFORE_SLASH_PATTERN="^(.*)[\\/]";
    function describeComponentFrame(name,source,ownerName)
        local sourceInfo="";
        if(_G.__DEV__)and(source)then
             local path=source.fileName;
            local fileName=string.gsub(path,BEFORE_SLASH_PATTERN,"");
            if string.match(fileName,"^init%.")then
                 local pathBeforeSlash=string.match(path,BEFORE_SLASH_PATTERN);
                if(pathBeforeSlash)and((#(pathBeforeSlash))~=(0))then
                     local folderName=string.gsub(pathBeforeSlash,BEFORE_SLASH_PATTERN,"");
                    fileName=(folderName)..(("/")..(fileName))
                end
             end;
            sourceInfo=(" (at ")..((fileName)..((":")..((source.lineNumber)..(")"))))
        elseif ownerName then
             sourceInfo=(" (created by ")..((ownerName)..(")"))
        end;
        return("\x0a    in ")..((((name)or("Unknown")))..(sourceInfo))
    end;
    local function describeClassComponentFrame(ctor,source,owner)
        local name=tostring(ctor);
        local ownerName;
        if(_G.__DEV__)and(owner)then
             ownerName=describeOwner(owner)
        end;
        return describeComponentFrame(name,source,ownerName)
    end;
    function describeFunctionComponentFrame(fn,source,ownerFn)
        if not(fn)then
             return""
        end;
        local name=if(type(fn))==("function")then debug.info(fn,"n")else tostring(fn);
        local ownerName;
        if(_G.__DEV__)and(ownerFn)then
             ownerName=describeOwner(ownerFn)
        end;
        return describeComponentFrame(name,source,ownerName)
    end;
    local function describeUnknownElementTypeFrameInDEV(type_,source,ownerFn)
        if not(_G.__DEV__)then
             return""
        end;
        if(type_)==(nil)then
             return""
        end;
        if((type(type_))==("table"))and((type(type_.__ctor))==("function"))then
             return describeClassComponentFrame(type_,source,ownerFn)
        end;
        if(type(type_))==("function")then
             return describeFunctionComponentFrame(type_,source,ownerFn)
        end;
        if(type(type_))==("string")then
             return describeBuiltInComponentFrame(type_,source,ownerFn)
        end;
        if(type_)==(REACT_SUSPENSE_TYPE)then
             return describeBuiltInComponentFrame("Suspense",source,ownerFn)
        elseif(type_)==(REACT_SUSPENSE_LIST_TYPE)then
             return describeBuiltInComponentFrame("SuspenseList",source,ownerFn)
        end;
        if(type(type_))==("table")then
             local typeProp=type_["\x24\x24typeof"];
            if(typeProp)==(REACT_FORWARD_REF_TYPE)then
                 return describeFunctionComponentFrame(type_.render,source,ownerFn)
            elseif(typeProp)==(REACT_MEMO_TYPE)then
                 return describeUnknownElementTypeFrameInDEV(type_.type,source,ownerFn)
            elseif(typeProp)==(REACT_BLOCK_TYPE)then
                 return describeFunctionComponentFrame(type_._render,source,ownerFn)
            elseif(typeProp)==(REACT_LAZY_TYPE)then
                 local lazyComponent=type_;
                local payload=lazyComponent._payload;
                local init=lazyComponent._init;
                local ok,result=pcall(function()
                    describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)
                end);
                if ok then
                     return result
                 end
             end
         end;
        return""
    end;
    return{["describeComponentFrame"]=describeComponentFrame,["describeBuiltInComponentFrame"]=describeBuiltInComponentFrame,["describeNativeComponentFrame"]=describeNativeComponentFrame,["describeClassComponentFrame"]=describeClassComponentFrame,["describeFunctionComponentFrame"]=describeFunctionComponentFrame,["describeUnknownElementTypeFrameInDEV"]=describeUnknownElementTypeFrameInDEV}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactErrorUtils.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactErrorUtils",function()
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant");
    local invokeGuardedCallbackImpl=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invokeGuardedCallbackImpl");
    local clearCaughtError;
    local hasError=false;
    local caughtError;
    local hasRethrowError=false;
    local rethrowError;
    local reporter={["onError"]=function(err)
        hasError=true;
        caughtError=err
     end};
    local exports={};
    exports.invokeGuardedCallback=function(...)
        hasError=false;
        caughtError=nil;
        invokeGuardedCallbackImpl(reporter,...)
    end;
    exports.invokeGuardedCallbackAndCatchFirstError=function(...)
        exports.invokeGuardedCallback(...);
        if hasError then
             local err=clearCaughtError();
            if not(hasRethrowError)then
                 hasRethrowError=true;
                rethrowError=err
             end
         end
     end;
    exports.rethrowCaughtError=function()
        if hasRethrowError then
             local err=rethrowError;
            hasRethrowError=false;
            rethrowError=nil;
            error(err)
        end
     end;
    exports.hasCaughtError=function()
        return hasError
     end;
    clearCaughtError=function()
        if hasError then
             local err=caughtError;
            hasError=false;
            caughtError=nil;
            return err
         else
             invariant(false,"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            return nil
         end
     end;
    exports.clearCaughtError=clearCaughtError;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactFeatureFlags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFeatureFlags",function()
    local exports={};
    exports.enableFilterEmptyStringAttributesDOM=true;
    exports.enableDebugTracing=false;
    exports.enableSchedulingProfiler=(_G.__PROFILE__)and(_G.__EXPERIMENTAL__);
    exports.debugRenderPhaseSideEffectsForStrictMode=_G.__DEV__;
    exports.replayFailedUnitOfWorkWithInvokeGuardedCallback=_G.__DEV__;
    exports.warnAboutDeprecatedLifecycles=true;
    exports.enableProfilerTimer=_G.__PROFILE__;
    exports.enableProfilerCommitHooks=false;
    exports.enableSchedulerTracing=_G.__PROFILE__;
    exports.enableSuspenseServerRenderer=_G.__EXPERIMENTAL__;
    exports.enableSelectiveHydration=_G.__EXPERIMENTAL__;
    exports.enableBlocksAPI=_G.__EXPERIMENTAL__;
    exports.enableLazyElements=_G.__EXPERIMENTAL__;
    exports.enableSchedulerDebugging=false;
    exports.disableJavaScriptURLs=false;
    exports.enableFundamentalAPI=false;
    exports.enableScopeAPI=false;
    exports.enableCreateEventHandleAPI=false;
    exports.warnAboutUnmockedScheduler=false;
    exports.enableSuspenseCallback=false;
    exports.warnAboutDefaultPropsOnFunctionComponents=false;
    exports.disableSchedulerTimeoutBasedOnReactExpirationTime=false;
    exports.enableTrustedTypesIntegration=false;
    exports.warnAboutSpreadingKeyToJSX=true;
    exports.enableComponentStackLocations=true;
    exports.enableNewReconciler=true;
    exports.skipUnmountedBoundaries=true;
    exports.disableInputAttributeSyncing=true;
    exports.warnAboutStringRefs=false;
    exports.disableLegacyContext=false;
    exports.disableTextareaChildren=false;
    exports.disableModulePatternComponents=false;
    exports.warnUnstableRenderSubtreeIntoContainer=false;
    exports.enableLegacyFBSupport=true;
    exports.deferRenderPhaseUpdateToNextBatch=false;
    exports.decoupleUpdatePriorityFromScheduler=true;
    exports.enableDiscreteEventFlushingChange=false;
    exports.enableEagerRootListeners=false;
    exports.enableDoubleInvokingEffects=false;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactInstanceMap.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactInstanceMap",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    local Error=LuauPolyfill.Error;
    local inspect=LuauPolyfill.util.inspect;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.getComponentName");
    local exports={};
    local function isValidFiber(fiber)
        return((((fiber.tag)~=(nil))and((fiber.subtreeFlags)~=(nil)))and((fiber.lanes)~=(nil)))and((fiber.childLanes)~=(nil))
    end;
    exports.remove=function(key)
        key._reactInternals=nil
     end;
    exports.get=function(key)
        local value=key._reactInternals;
        if not(isValidFiber(value))then
             error(Error.new(("invalid fiber in ")..((((getComponentName(key))or("UNNAMED Component")))..((" during get from ReactInstanceMap! ")..(inspect(value))))))
        elseif((value.alternate)~=(nil))and(not(isValidFiber(value.alternate)))then
             error(Error.new(("invalid alternate fiber (")..((((getComponentName(key))or("UNNAMED alternate")))..((") in ")..((((getComponentName(key))or("UNNAMED Component")))..((" during get from ReactInstanceMap! ")..(inspect(value.alternate))))))))
        end;
        return value
     end;
    exports.has=function(key)
        return(key._reactInternals)~=(nil)
    end;
    exports.set=function(key,value)
        local parent=value;
        local message;
        while(parent)~=(nil)do
             if not(isValidFiber(parent))then
                 message=("invalid fiber in ")..((((getComponentName(key))or("UNNAMED Component")))..((" being set in ReactInstanceMap! ")..((inspect(parent))..("\x0a"))));
                if(value)~=(parent)then
                     message..=(" (from original fiber ")..((((getComponentName(key))or("UNNAMED Component")))..(")"))
                end;
                error(Error.new(message))
            elseif(((parent).alternate)~=(nil))and(not(isValidFiber((parent).alternate)))then
                 message=("invalid alternate fiber (")..((((getComponentName(key))or("UNNAMED alternate")))..((") in ")..((((getComponentName(key))or("UNNAMED Component")))..((" being set in ReactInstanceMap! ")..((inspect((parent).alternate))..("\x0a"))))));
                if(value)~=(parent)then
                     message..=(" (from original fiber ")..((((getComponentName(key))or("UNNAMED Component")))..(")"))
                end;
                error(Error.new(message))
            end;
            parent=(parent).return_
         end;
        (key)._reactInternals=value
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSymbols.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSymbols",function()
    local exports={};
    exports.REACT_ELEMENT_TYPE=60103;
    exports.REACT_PORTAL_TYPE=60106;
    exports.REACT_FRAGMENT_TYPE=60107;
    exports.REACT_STRICT_MODE_TYPE=60108;
    exports.REACT_PROFILER_TYPE=60114;
    exports.REACT_PROVIDER_TYPE=60109;
    exports.REACT_CONTEXT_TYPE=60110;
    exports.REACT_FORWARD_REF_TYPE=60112;
    exports.REACT_SUSPENSE_TYPE=60113;
    exports.REACT_SUSPENSE_LIST_TYPE=60120;
    exports.REACT_MEMO_TYPE=60115;
    exports.REACT_LAZY_TYPE=60116;
    exports.REACT_BLOCK_TYPE=60121;
    exports.REACT_SERVER_BLOCK_TYPE=60122;
    exports.REACT_FUNDAMENTAL_TYPE=60117;
    exports.REACT_SCOPE_TYPE=60119;
    exports.REACT_OPAQUE_ID_TYPE=60128;
    exports.REACT_DEBUG_TRACING_MODE_TYPE=60129;
    exports.REACT_OFFSCREEN_TYPE=60130;
    exports.REACT_LEGACY_HIDDEN_TYPE=60131;
    exports.REACT_BINDING_TYPE=60132;
    type("not printable... yet");
    exports.getIteratorFn=function(maybeIterable)
        if(typeof(maybeIterable))==("table")then
             if(maybeIterable["\x24\x24typeof"])==(exports.REACT_PORTAL_TYPE)then
                 return nil
             end;
            return function()
                local currentKey,currentValue;
                return{["next"]=function()
                    currentKey,currentValue=next(maybeIterable,currentKey);
                    return{["done"]=(currentValue)==(nil),["key"]=currentKey,["value"]=currentValue}
                end}
            end
         end;
        return nil
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactVersion.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactVersion",function()
    return"17.2.1"

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\shallowEqual.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.shallowEqual",function()
    local is=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.objectIs");
    local function shallowEqual(objA,objB)
        if is(objA,objB)then
             return true
         end;
        if((((typeof(objA))~=("table"))or((objA)==(nil)))or((typeof(objB))~=("table")))or((objB)==(nil))then
             return false
         end;
        for key,value in objA do
             if not(is(objB[key],value))then
                 return false
             end
         end;
        for key,value in objB do
             if not(is(objA[key],value))then
                 return false
             end
         end;
        return true
     end;
    return shallowEqual

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\UninitializedState.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.UninitializedState.roblox",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.console");
    local UninitializedState={};
    setmetatable(UninitializedState,{["__index"]=function(table,key)
        if _G.__DEV__ then
             console.warn("Attempted to access uninitialized state. Use setState to initialize state")
        end;
        return nil
     end,["__newindex"]=function(table,key)
        if _G.__DEV__ then
             console.error("Attempted to directly mutate state. Use setState to assign new values to state.")
        end;
        return nil
     end,["__tostring"]=function(self)
        return"<uninitialized component state>"
    end,["__metatable"]="UninitializedState"});
    return UninitializedState

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\Symbol.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Symbol.roblox",function()
    local Symbol={};
    function Symbol.named(name)
        assert((type(name))==("string"),"Symbols must be created using a string name!");
        local self=newproxy(true);
        local wrappedName=string.format("Symbol(%s)",name);
        getmetatable(self).__tostring=function()
            return wrappedName
         end;
        return self
     end;
    return Symbol

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\Type.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Type.roblox",function()
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Symbol.roblox");
    local Type=newproxy(true);
    local TypeInternal={};
    local function addType(name)
        TypeInternal[name]=Symbol.named(("Roact")..(name))
    end;
    addType("HostChangeEvent");
    addType("HostEvent");
    function TypeInternal.of(value)
        if(typeof(value))~=("table")then
             return nil
         end;
        return value[Type]
    end;
    getmetatable(Type).__index=TypeInternal;
    getmetatable(Type).__tostring=function()
        return"RoactType"
    end;
    return Type

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\PropMarkers\Change.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Change",function()
    local Type=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Type.roblox");
    local Change={};
    local changeMetatable={["__tostring"]=function(self)
        return string.format("RoactHostChangeEvent(%s)",self.name)
    end};
    setmetatable(Change,{["__index"]=function(self,propertyName)
        local changeListener={[Type]=Type.HostChangeEvent,["name"]=propertyName};
        setmetatable(changeListener,changeMetatable);
        Change[propertyName]=changeListener;
        return changeListener
     end});
    return Change

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\PropMarkers\Event.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Event",function()
    local Type=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Type.roblox");
    local Event={};
    local eventMetatable={["__tostring"]=function(self)
        return string.format("RoactHostEvent(%s)",self.name)
    end};
    setmetatable(Event,{["__index"]=function(self,eventName)
        local event={[Type]=Type.HostEvent,["name"]=eventName};
        setmetatable(event,eventMetatable);
        Event[eventName]=event;
        return event
     end});
    return Event

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\PropMarkers\Tag.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.PropMarkers.Tag",function()
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.Symbol.roblox");
    local Tag=Symbol.named("RobloxTag");
    return Tag

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    local ReactRootTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local function initialize(config)
        local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
        for name,implementation in config do
             ReactFiberHostConfig[name]=implementation
         end;
        return tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberReconciler")
    end;
    return initialize

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRobloxHostConfig.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostConfig",function()
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(tostring(message)));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")),2)
    end;
    local CollectionService=game:GetService("CollectionService");
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.luau-polyfill");
    local inspect=LuauPolyfill.util.inspect;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").console;
    local Object=LuauPolyfill.Object;
    local setTimeout=LuauPolyfill.setTimeout;
    local clearTimeout=LuauPolyfill.clearTimeout;
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRobloxComponentTree=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponentTree");
    local precacheFiberNode=ReactRobloxComponentTree.precacheFiberNode;
    local uncacheFiberNode=ReactRobloxComponentTree.uncacheFiberNode;
    local updateFiberProps=ReactRobloxComponentTree.updateFiberProps;
    local ReactRobloxComponent=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponent");
    local setInitialProperties=ReactRobloxComponent.setInitialProperties;
    local diffProperties=ReactRobloxComponent.diffProperties;
    local updateProperties=ReactRobloxComponent.updateProperties;
    local cleanupHostComponent=ReactRobloxComponent.cleanupHostComponent;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactFeatureFlags;
    local enableCreateEventHandleAPI=ReactFeatureFlags.enableCreateEventHandleAPI;
    type("not printable... yet");
    type("not printable... yet");
    local function recursivelyUncacheFiberNode(node)
        if(typeof(node))~=("Instance")then
             return
         end;
        uncacheFiberNode(node);
        for _,child in node:GetDescendants()do
             uncacheFiberNode(child)
        end
     end;
    local exports={};
    Object.assign(exports,tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactFiberHostConfig.WithNoPersistence);
    exports.getRootHostContext=function(rootContainerInstance)
        return rootContainerInstance.ClassName
     end;
    exports.getChildHostContext=function(parentHostContext,type,rootContainerInstance)
        return parentHostContext
     end;
    exports.getPublicInstance=function(instance)
        return instance
     end;
    exports.prepareForCommit=function(containerInfo)
        local activeInstance;
        if enableCreateEventHandleAPI then
             unimplemented("enableCreateEventHandleAPI")
        end;
        return activeInstance
     end;
    exports.beforeActiveInstanceBlur=function()
        if enableCreateEventHandleAPI then
             unimplemented("enableCreateEventHandleAPI")
        end
     end;
    exports.afterActiveInstanceBlur=function()
        if enableCreateEventHandleAPI then
             unimplemented("enableCreateEventHandleAPI")
        end
     end;
    exports.resetAfterCommit=function(containerInfo)
        
    end;
    exports.createInstance=function(type_,props,rootContainerInstance,hostContext,internalInstanceHandle)
        local domElement=Instance.new(type_);
        if internalInstanceHandle.key then
             domElement.Name=internalInstanceHandle.key
         else
             local currentHandle=internalInstanceHandle.return_;
            while currentHandle do
                 if currentHandle.key then
                     domElement.Name=currentHandle.key;
                    break
                 end;
                currentHandle=currentHandle.return_
             end
         end;
        precacheFiberNode(internalInstanceHandle,domElement);
        updateFiberProps(domElement,props);
        return domElement
     end;
    exports.appendInitialChild=function(parentInstance,child)
        child.Parent=parentInstance
     end;
    exports.finalizeInitialChildren=function(domElement,type_,props,rootContainerInstance,hostContext)
        setInitialProperties(domElement,type_,props,rootContainerInstance);
        return false
     end;
    local function prepareUpdate(domElement,type_,oldProps,newProps,rootContainerInstance,hostContext)
        return diffProperties(domElement,type_,oldProps,newProps,rootContainerInstance)
    end;
    exports.prepareUpdate=prepareUpdate;
    exports.shouldSetTextContent=function(_type,_props)
        return false
     end;
    exports.createTextInstance=function(text,rootContainerInstance,hostContext,internalInstanceHandle)
        unimplemented("createTextInstance");
        return nil
     end;
    exports.isPrimaryRenderer=true;
    exports.warnsIfNotActing=true;
    exports.scheduleTimeout=setTimeout;
    exports.cancelTimeout=clearTimeout;
    exports.noTimeout=-(1);
    exports.supportsMutation=true;
    exports.commitMount=function(domElement,type,newProps,internalInstanceHandle)
        unimplemented("commitMount")
    end;
    exports.commitUpdate=function(domElement,updatePayload,type_,oldProps,newProps,internalInstanceHandle)
        updateFiberProps(domElement,newProps);
        updateProperties(domElement,updatePayload,oldProps)
    end;
    local function checkTags(instance)
        if(typeof(instance))~=("Instance")then
             console.warn("Could not check tags on non-instance %s.",inspect(instance));
            return
         end;
        if not(instance:IsDescendantOf(game))then
             if(#(CollectionService:GetTags(instance)))>(0)then
                 console.warn("Tags applied to orphaned %s \"%s\" cannot be accessed via CollectionService:GetTagged. If you're relying on tag behavior in a unit test, consider mounting your test root into the DataModel.",instance.ClassName,instance.Name)
            end
         end
     end;
    exports.appendChild=function(parentInstance,child)
        child.Parent=parentInstance;
        if _G.__DEV__ then
             checkTags(child)
        end
     end;
    exports.appendChildToContainer=function(container,child)
        local parentNode=container;
        exports.appendChild(parentNode,child)
    end;
    exports.insertBefore=function(parentInstance,child,_beforeChild)
        child.Parent=parentInstance;
        if _G.__DEV__ then
             checkTags(child)
        end
     end;
    exports.insertInContainerBefore=function(container,child,beforeChild)
        local parentNode=container;
        exports.insertBefore(parentNode,child,beforeChild)
    end;
    exports.removeChild=function(_parentInstance,child)
        recursivelyUncacheFiberNode(child);
        cleanupHostComponent(child);
        child.Parent=nil;
        child:Destroy()
    end;
    exports.removeChildFromContainer=function(_container,child)
        exports.removeChild(_container,child)
    end;
    exports.clearSuspenseBoundary=function(parentInstance,suspenseInstance)
        unimplemented("clearSuspenseBoundary")
    end;
    exports.clearSuspenseBoundaryFromContainer=function(container,suspenseInstance)
        unimplemented("clearSuspenseBoundaryFromContainer")
    end;
    exports.hideInstance=function(instance)
        unimplemented("hideInstance")
    end;
    exports.hideTextInstance=function(textInstance)
        unimplemented("hideTextInstance")
    end;
    exports.unhideInstance=function(instance,props)
        unimplemented("unhideInstance")
    end;
    exports.unhideTextInstance=function(textInstance,text)
        unimplemented("unhideTextInstance")
    end;
    exports.clearContainer=function(container)
        local parentInstance=container;
        for _,child in parentInstance:GetChildren()do
             exports.removeChild(parentInstance,child)
        end
     end;
    exports.preparePortalMount=function(portalInstance)
        
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_boolean@1.2.7\boolean\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_boolean@1.2.7.boolean",function()
    return{["toJSBoolean"]=tkpack.include("game.Packages._Index.jsdotlua_boolean@1.2.7.boolean.toJSBoolean")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections",function()
    local Array=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array");
    local Map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map");
    local Object=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object");
    local Set=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Set");
    local WeakMap=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.WeakMap");
    local inspect=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.inspect");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{["Array"]=Array,["Object"]=Object,["Map"]=Map.Map,["coerceToMap"]=Map.coerceToMap,["coerceToTable"]=Map.coerceToTable,["Set"]=Set,["WeakMap"]=WeakMap,["inspect"]=inspect}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_console@1.2.7\console\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_console@1.2.7.console",function()
    local makeConsoleImpl=tkpack.include("game.Packages._Index.jsdotlua_console@1.2.7.console.makeConsoleImpl");
    return makeConsoleImpl()

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_math@1.2.7\math\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_math@1.2.7.math",function()
    return{["clz32"]=tkpack.include("game.Packages._Index.jsdotlua_math@1.2.7.math.clz32")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number",function()
    return{["isFinite"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.isFinite"),["isInteger"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.isInteger"),["isNaN"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.isNaN"),["isSafeInteger"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.isSafeInteger"),["MAX_SAFE_INTEGER"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.MAX_SAFE_INTEGER"),["MIN_SAFE_INTEGER"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.MIN_SAFE_INTEGER"),["NaN"]=(0)/(0),["toExponential"]=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.toExponential")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string",function()
    return{["charCodeAt"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.charCodeAt"),["endsWith"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.endsWith"),["findOr"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.findOr"),["includes"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.includes"),["indexOf"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.indexOf"),["lastIndexOf"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.lastIndexOf"),["slice"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.slice"),["split"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.split"),["startsWith"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.startsWith"),["substr"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.substr"),["trim"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trim"),["trimEnd"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimEnd"),["trimStart"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimStart"),["trimRight"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimEnd"),["trimLeft"]=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimStart")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_symbol-luau@1.0.1\symbol-luau\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau",function()
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau.Symbol");
    type("not printable... yet");
    local GlobalRegistry=tkpack.include("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau.Registry.global");
    local SymbolObject=setmetatable({},{["__call"]=function(_,name)
        return Symbol.new(name)
    end});
    SymbolObject.for_=GlobalRegistry.getOrInit;
    return SymbolObject

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_timers@1.2.7\timers\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_timers@1.2.7.timers",function()
    local Object=tkpack.include("game.Packages._Index.jsdotlua_timers@1.2.7.collections").Object;
    local makeTimerImpl=tkpack.include("game.Packages._Index.jsdotlua_timers@1.2.7.timers.makeTimerImpl");
    local makeIntervalImpl=tkpack.include("game.Packages._Index.jsdotlua_timers@1.2.7.timers.makeIntervalImpl");
    type("not printable... yet");
    type("not printable... yet");
    return Object.assign({},makeTimerImpl(task.delay),makeIntervalImpl(task.delay))

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_es7-types@1.2.7\es7-types\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_es7-types@1.2.7.es7-types",function()
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\AssertionError\AssertionError.global.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.AssertionError.AssertionError.global",function()
    local Collections=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.collections");
    local Array=Collections.Array;
    local Object=Collections.Object;
    local Boolean=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.boolean");
    local String=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.string");
    local types=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.es7-types");
    local inspect=Collections.inspect;
    local Error=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Error");
    local instanceof=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.instance-of");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local process={["stderr"]={["isTTY"]=false,["columns"]=0,["hasColors"]=function(...)
        return true
     end}};
    function ErrorCaptureStackTrace(err,...)
        Error.captureStackTrace(err,...)
    end;
    local function removeColors(str)
        return str
     end;
    local blue="";
    local green="";
    local red="";
    local white="";
    local kReadableOperator={["deepStrictEqual"]="Expected values to be strictly deep-equal:",["strictEqual"]="Expected values to be strictly equal:",["strictEqualObject"]="Expected \"actual\" to be reference-equal to \"expected\":",["deepEqual"]="Expected values to be loosely deep-equal:",["notDeepStrictEqual"]="Expected \"actual\" not to be strictly deep-equal to:",["notStrictEqual"]="Expected \"actual\" to be strictly unequal to:",["notStrictEqualObject"]="Expected \"actual\" not to be reference-equal to \"expected\":",["notDeepEqual"]="Expected \"actual\" not to be loosely deep-equal to:",["notIdentical"]="Values have same structure but are not reference-equal:",["notDeepEqualUnequal"]="Expected values not to be loosely deep-equal:"};
    local kMaxShortLength=12;
    local function copyError(source)
        local keys=Object.keys(source);
        local target={};
        for _,key in keys do
             target[key]=source[key]
        end;
        target.message=source.message;
        return target
     end;
    local function inspectValue(val)
        return inspect(val,{["compact"]=false,["customInspect"]=false,["depth"]=1000,["maxArrayLength"]=math.huge,["showHidden"]=false,["showProxy"]=false,["sorted"]=true,["getters"]=true})
    end;
    local function createErrDiff(actual,expected,operator)
        local other="";
        local res="";
        local end_="";
        local skipped=false;
        local actualInspected=inspectValue(actual);
        local actualLines=String.split(actualInspected,"\x0a");
        local expectedLines=String.split(inspectValue(expected),"\x0a");
        local i=0;
        local indicator="";
        if((operator)==("strictEqual"))and(((((((typeof(actual))==("table"))and((actual)~=(nil)))and((typeof(expected))==("table")))and((expected)~=(nil)))or(((typeof(actual))==("function"))and((typeof(expected))==("function")))))then
             operator="strictEqualObject"
        end;
        if(((#(actualLines))==(1))and((#(expectedLines))==(1)))and((actualLines[1])~=(expectedLines[1]))then
             local c=false;
            local actualRaw=if c then removeColors(actualLines[1])else actualLines[1];
            local expectedRaw=if Boolean.toJSBoolean(c)then removeColors(expectedLines[1])else expectedLines[1];
            local inputLength=(string.len(actualRaw))+(string.len(expectedRaw));
            if(inputLength)<=(kMaxShortLength)then
                 if(((((typeof(actual))~=("table"))or((actual)==(nil))))and((((typeof(expected))~=("table"))or((expected)==(nil)))))and((((actual)~=(0))or((expected)~=(0))))then
                     return(("%s\x0a\x0a"):format(kReadableOperator[operator]))..(("%s !== %s\x0a"):format(actualLines[1],expectedLines[1]))
                end
             elseif(operator)~=("strictEqualObject")then
                 local maxLength=if process.stderr.isTTY then process.stderr.columns else 80;
                if(inputLength)<(maxLength)then
                     while(string.sub(actualRaw,(i)+(1),(i)+(1)))==(string.sub(expectedRaw,(i)+(1),(i)+(1)))do
                         i+=1
                     end;
                    if(i)>(2)then
                         indicator=("\x0a  %s^"):format(string.rep(" ",i));
                        i=0
                     end
                 end
             end
         end;
        local a=actualLines[#(actualLines)];
        local b=expectedLines[#(expectedLines)];
        while(a)==(b)do
             local i_=i;
            i+=1;
            if(i_)<(3)then
                 end_=("\x0a  %s%s"):format(a,end_)
            else
                 other=a
             end;
            table.remove(actualLines);
            table.remove(expectedLines);
            if((#(actualLines))==(0))or((#(expectedLines))==(0))then
                 break
             end;
            a=actualLines[#(actualLines)];
            b=expectedLines[#(expectedLines)]
        end;
        local maxLines=math.max(#(actualLines),#(expectedLines));
        if(maxLines)==(0)then
             local actualLines_=String.split(actualInspected,"\x0a");
            if(#(actualLines_))>(50)then
                 actualLines_[47]=("%s...%s"):format(blue,white);
                while(#(actualLines_))>(47)do
                     table.remove(actualLines_)
                end
             end;
            return(("%s\x0a\x0a"):format(kReadableOperator.notIdentical))..(("%s\x0a"):format(Array.join(actualLines_,"\x0a")))
        end;
        if(i)>=(5)then
             end_=("\x0a%s...%s%s"):format(blue,white,end_);
            skipped=true
         end;
        if(other)~=("")then
             end_=("\x0a  %s%s"):format(other,end_);
            other=""
        end;
        local printedLines=0;
        local identical=0;
        local msg=(kReadableOperator[operator])..(("\x0a%s+ actual%s %s- expected%s"):format(green,white,red,white));
        local skippedMsg=(" %s...%s Lines skipped"):format(blue,white);
        local lines=actualLines;
        local plusMinus=("%s+%s"):format(green,white);
        local maxLength=#(expectedLines);
        if(#(actualLines))<(maxLines)then
             lines=expectedLines;
            plusMinus=("%s-%s"):format(red,white);
            maxLength=#(actualLines)
        end;
        for ii=1,maxLines do
             i=ii;
            if(maxLength)<(ii)then
                 if(identical)>(2)then
                     if(identical)>(3)then
                         if(identical)>(4)then
                             if(identical)==(5)then
                                 res..=("\x0a  %s"):format(lines[((ii)-(3))]);
                                printedLines+=1
                             else
                                 res..=("\x0a%s...%s"):format(blue,white);
                                skipped=true
                             end
                         end;
                        res..=("\x0a  %s"):format(lines[((ii)-(2))]);
                        printedLines+=1
                     end;
                    res..=("\x0a  %s"):format(lines[((ii)-(1))]);
                    printedLines+=1
                 end;
                identical=0;
                if(lines)==(actualLines)then
                     res..=("\x0a%s %s"):format(plusMinus,lines[ii])
                else
                     other..=("\x0a%s %s"):format(plusMinus,lines[ii])
                end;
                printedLines+=1
             else
                 local expectedLine=expectedLines[ii];
                local actualLine=actualLines[ii];
                local divergingLines=((actualLine)~=(expectedLine))and(((not(Boolean.toJSBoolean(String.endsWith(actualLine,","))))or((String.slice(actualLine,0,-(1)))~=(expectedLine))));
                if((divergingLines)and(String.endsWith(expectedLine,",")))and((String.slice(expectedLine,0,-(1)))==(actualLine))then
                     divergingLines=false;
                    actualLine..=","
                end;
                if divergingLines then
                     if(identical)>(2)then
                         if(identical)>(3)then
                             if(identical)>(4)then
                                 if(identical)==(5)then
                                     res..=("\x0a  %s"):format(actualLines[(ii)-(3)]);
                                    printedLines+=1
                                 else
                                     res..=("\x0a%s...%s"):format(blue,white);
                                    skipped=true
                                 end
                             end;
                            res..=("\x0a  %s"):format(actualLines[(ii)-(2)]);
                            printedLines+=1
                         end;
                        res..=("\x0a  %s"):format(actualLines[(ii)-(1)]);
                        printedLines+=1
                     end;
                    identical=0;
                    res..=("\x0a%s+%s %s"):format(green,white,actualLine);
                    other..=("\x0a%s-%s %s"):format(red,white,expectedLine);
                    printedLines+=2
                 else
                     res..=other;
                    other="";
                    identical+=1;
                    if(identical)<=(2)then
                         res..=("\x0a  %s"):format(actualLine);
                        printedLines+=1
                     end
                 end
             end;
            if((printedLines)>(50))and((ii)<((maxLines)-(2)))then
                 return(("%s%s\x0a%s\x0a%s...%s%s\x0a"):format(msg,skippedMsg,res,blue,white,other))..(("%s...%s"):format(blue,white))
            end
         end;
        return("%s%s\x0a%s%s%s%s"):format(msg,if skipped then skippedMsg else"",res,other,end_,indicator)
    end;
    type("not printable... yet");
    type("not printable... yet");
    local AssertionError=(setmetatable({},{["__index"]=Error}));
    AssertionError.__index=AssertionError;
    AssertionError.__tostring=function(self)
        return self:toString()
    end;
    type("not printable... yet");
    function AssertionError.new(options)
        local self;
        local message,operator,stackStartFn=options.message,options.operator,options.stackStartFn;
        local actual,expected=options.actual,options.expected;
        if(message)~=(nil)then
             self=(setmetatable(Error.new(tostring(message)),AssertionError))
        else
             if process.stderr.isTTY then
                 if process.stderr:hasColors()then
                     blue="\x1b[34m";
                    green="\x1b[32m";
                    white="\x1b[39m";
                    red="\x1b[31m"
                else
                     blue="";
                    green="";
                    white="";
                    red=""
                end
             end;
            if((((((((typeof(actual))==("table"))and((actual)~=(nil)))and((typeof(expected))==("table")))and((expected)~=(nil)))and((Array.indexOf(Object.keys(actual),"stack"))~=(-(1))))and(instanceof(actual,Error)))and((Array.indexOf(Object.keys(expected),"stack"))~=(-(1))))and(instanceof(expected,Error))then
                 actual=copyError(actual);
                expected=copyError(expected)
            end;
            if((operator)==("deepStrictEqual"))or((operator)==("strictEqual"))then
                 self=(setmetatable(Error.new(createErrDiff(actual,expected,operator)),AssertionError))
            elseif((operator)==("notDeepStrictEqual"))or((operator)==("notStrictEqual"))then
                 local base=kReadableOperator[operator];
                local res=String.split(inspectValue(actual),"\x0a");
                if((operator)==("notStrictEqual"))and(((((typeof(actual))==("table"))and((actual)~=(nil)))or((typeof(actual))==("function"))))then
                     base=kReadableOperator.notStrictEqualObject
                 end;
                if(#(res))>(50)then
                     res[47]=("%s...%s"):format(blue,white);
                    while(#(res))>(47)do
                         table.remove(res)
                    end
                 end;
                if(#(res))==(1)then
                     self=(setmetatable(Error.new(("%s%s%s"):format(base,if(string.len(res[1]))>(5)then"\x0a\x0a"else" ",res[1])),AssertionError))
                else
                     self=(setmetatable(Error.new(("%s\x0a\x0a%s\x0a"):format(base,Array.join(res,"\x0a"))),AssertionError))
                end
             else
                 local res=inspectValue(actual);
                local other=inspectValue(expected);
                local knownOperator=kReadableOperator[tostring(operator)];
                if((operator)==("notDeepEqual"))and((res)==(other))then
                     res=("%s\x0a\x0a%s"):format(knownOperator,res);
                    if(string.len(res))>(1024)then
                         res=("%s..."):format(String.slice(res,0,1021))
                    end;
                    self=(setmetatable(Error.new(res),AssertionError))
                else
                     if(string.len(res))>(512)then
                         res=("%s..."):format(String.slice(res,0,509))
                    end;
                    if(string.len(other))>(512)then
                         other=("%s..."):format(String.slice(other,0,509))
                    end;
                    if(operator)==("deepEqual")then
                         res=("%s\x0a\x0a%s\x0a\x0ashould loosely deep-equal\x0a\x0a"):format(knownOperator,res)
                    else
                         local newOp=kReadableOperator[("%sUnequal"):format(tostring(operator))];
                        if Boolean.toJSBoolean(newOp)then
                             res=("%s\x0a\x0a%s\x0a\x0ashould not loosely deep-equal\x0a\x0a"):format(newOp,res)
                        else
                             other=(" %s %s"):format(tostring(operator),other)
                        end
                     end;
                    self=(setmetatable(Error.new(("%s%s"):format(res,other)),AssertionError))
                end
             end
         end;
        self.generatedMessage=not(Boolean.toJSBoolean(message));
        self.name="AssertionError [ERR_ASSERTION]";
        self.code="ERR_ASSERTION";
        self.actual=actual;
        self.expected=expected;
        self.operator=operator;
        ErrorCaptureStackTrace(self,(stackStartFn)or(AssertionError.new));
        self.name="AssertionError";
        return(self)
    end;
    function AssertionError:toString()
        return("%s [%s]: %s"):format(self.name,self.code,self.message)
    end;
    AssertionError.name="AssertionError";
    return{["AssertionError"]=AssertionError}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_luau-polyfill@1.2.7\luau-polyfill\src\Error\Error.global.lua
 tkpack.declare("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill.Error.Error.global",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Error={};
    local DEFAULT_NAME="Error";
    Error.__index=Error;
    Error.__tostring=function(self)
        return getmetatable(Error).__tostring(self)
    end;
    local function __createError(message)
        local self=(setmetatable({["name"]=DEFAULT_NAME,["message"]=(message)or("")},Error));
        Error.__captureStackTrace(self,4);
        return self
     end;
    function Error.new(message)
        return __createError(message)
    end;
    function Error.captureStackTrace(err,options)
        Error.__captureStackTrace(err,3,options)
    end;
    function Error.__captureStackTrace(err_,level,options)
        local err=err_;
        if(typeof(options))==("function")then
             local stack=debug.traceback(nil,level);
            local functionName=debug.info(options,"n");
            local sourceFilePath=debug.info(options,"s");
            local espacedSourceFilePath=string.gsub(sourceFilePath,"([%(%)%.%%%+%-%*%?%[%^%\x24])","%%%1");
            local stacktraceLinePattern=(espacedSourceFilePath)..((":%d* function ")..(functionName));
            local beg=string.find(stack,stacktraceLinePattern);
            local end_;
            if(beg)~=(nil)then
                 beg,end_=string.find(stack,"\x0a",(beg)+(1))
            end;
            if(end_)~=(nil)then
                 stack=string.sub(stack,(end_)+(1))
            end;
            err.__stack=stack
         else
             err.__stack=debug.traceback(nil,level)
        end;
        Error.__recalculateStacktrace(err)
    end;
    function Error.__recalculateStacktrace(err_)
        local err=err_;
        local message=err.message;
        local name=(err.name)or(DEFAULT_NAME);
        local errName=(name)..((if((message)~=(nil))and((message)~=(""))then((": ")..(message))else""));
        local stack=if err.__stack then err.__stack else"";
        err.stack=(errName)..(("\x0a")..(stack))
    end;
    return setmetatable(Error,{["__call"]=function(_,...)
        return __createError(...)
    end,["__tostring"]=function(self)
        if(self.name)~=(nil)then
             if(self.message)and((self.message)~=(""))then
                 return string.format("%s: %s",tostring(self.name),tostring(self.message))
            end;
            return tostring(self.name)
        end;
        return tostring(DEFAULT_NAME)
    end})

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_instance-of@1.2.7\instance-of\src\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_instance-of@1.2.7.instance-of",function()
    local instanceof=tkpack.include("game.Packages._Index.jsdotlua_instance-of@1.2.7.instance-of.instanceof");
    return instanceof

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactFiberHostConfig\WithNoHydration.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoHydration",function()
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant");
    function shim(...)
        invariant(false,"The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue.")
    end;
    type("not printable... yet");
    return{["supportsHydration"]=false,["canHydrateInstance"]=shim,["canHydrateTextInstance"]=shim,["canHydrateSuspenseInstance"]=shim,["isSuspenseInstancePending"]=shim,["isSuspenseInstanceFallback"]=shim,["registerSuspenseInstanceRetry"]=shim,["getNextHydratableSibling"]=shim,["getFirstHydratableChild"]=shim,["hydrateInstance"]=shim,["hydrateTextInstance"]=shim,["hydrateSuspenseInstance"]=shim,["getNextHydratableInstanceAfterSuspenseInstance"]=shim,["commitHydratedContainer"]=shim,["commitHydratedSuspenseInstance"]=shim,["clearSuspenseBoundary"]=shim,["clearSuspenseBoundaryFromContainer"]=shim,["didNotMatchHydratedContainerTextInstance"]=shim,["didNotMatchHydratedTextInstance"]=shim,["didNotHydrateContainerInstance"]=shim,["didNotHydrateInstance"]=shim,["didNotFindHydratableContainerInstance"]=shim,["didNotFindHydratableContainerTextInstance"]=shim,["didNotFindHydratableContainerSuspenseInstance"]=shim,["didNotFindHydratableInstance"]=shim,["didNotFindHydratableTextInstance"]=shim,["didNotFindHydratableSuspenseInstance"]=shim}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactFiberHostConfig\WithNoPersistence.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoPersistence",function()
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant");
    local function shim(...)
        invariant(false,"The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.")
    end;
    return{["supportsPersistence"]=false,["cloneInstance"]=shim,["cloneFundamentalInstance"]=shim,["createContainerChildSet"]=shim,["appendChildToContainerChildSet"]=shim,["finalizeContainerChildren"]=shim,["replaceContainerChildren"]=shim,["cloneHiddenInstance"]=shim,["cloneHiddenTextInstance"]=shim}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactFiberHostConfig\WithNoTestSelectors.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactFiberHostConfig.WithNoTestSelectors",function()
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.invariant");
    local function shim(...)
        invariant(false,"The current renderer does not support test selectors. This error is likely caused by a bug in React. Please file an issue.")
    end;
    return{["supportsTestSelectors"]=false,["findFiberRoot"]=shim,["getBoundingRect"]=shim,["getTextContent"]=shim,["isHiddenSubtree"]=shim,["matchAccessibilityRole"]=shim,["setFocusIfFocusable"]=shim,["setupIntersectionObserver"]=shim}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\ReactCurrentDispatcher.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentDispatcher",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.luau-polyfill");
    type("not printable... yet");
    local ReactElementType=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactElementType");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactCurrentDispatcher={["current"]=nil};
    return ReactCurrentDispatcher

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\ReactCurrentBatchConfig.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentBatchConfig",function()
    local ReactCurrentBatchConfig={["transition"]=0};
    return ReactCurrentBatchConfig

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\ReactCurrentOwner.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactCurrentOwner",function()
    local ReactCurrentOwner={["current"]=nil};
    return ReactCurrentOwner

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\ReactDebugCurrentFrame.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.ReactDebugCurrentFrame",function()
    local ReactDebugCurrentFrame={};
    local currentExtraStackFrame=nil;
    function ReactDebugCurrentFrame.setExtraStackFrame(stack)
        if _G.__DEV__ then
             currentExtraStackFrame=stack
         end
     end;
    if _G.__DEV__ then
         ReactDebugCurrentFrame.getCurrentStack=nil;
        function ReactDebugCurrentFrame.getStackAddendum()
            local stack="";
            if currentExtraStackFrame then
                 stack=(stack)..(currentExtraStackFrame)
            end;
            local impl=ReactDebugCurrentFrame.getCurrentStack;
            if impl then
                 stack=(stack)..(((impl())or("")))
            end;
            return stack
         end
     end;
    return ReactDebugCurrentFrame

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_shared@17.2.1\shared\src\ReactSharedInternals\IsSomeRendererActing.luau
 tkpack.declare("game.Packages._Index.jsdotlua_shared@17.2.1.shared.ReactSharedInternals.IsSomeRendererActing",function()
    local IsSomeRendererActing={["current"]=false};
    return IsSomeRendererActing

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactInternalTypes.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    type("not printable... yet");
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    type("not printable... yet");
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRootTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local Scheduler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactRootTags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags",function()
    type("not printable... yet");
    return{["LegacyRoot"]=0,["BlockingRoot"]=1,["ConcurrentRoot"]=2}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberHostConfig.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig",function()
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberReconciler.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberReconciler",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberReconciler.new")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\luau-polyfill.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.luau-polyfill",function()
    return tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\ReactRobloxComponent.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxComponent",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local RobloxComponentProps=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.RobloxComponentProps");
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    exports.setInitialProperties=RobloxComponentProps.setInitialProperties;
    local function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement)
        local updatePayload;
        local lastProps=lastRawProps;
        local nextProps=nextRawProps;
        for propKey,_ in lastProps do
             if(nextProps[propKey])~=(nil)then
                 continue
             end;
            updatePayload=(updatePayload)or(table.create(2));
            table.insert(updatePayload,propKey);
            table.insert(updatePayload,Object.None)
        end;
        for propKey,nextProp in nextProps do
             local lastProp=if(lastProps)~=(nil)then lastProps[propKey]else nil;
            if(nextProp)==(lastProp)then
                 continue
             end;
            updatePayload=(updatePayload)or(table.create(2));
            table.insert(updatePayload,propKey);
            table.insert(updatePayload,nextProp)
        end;
        return updatePayload
     end;
    exports.diffProperties=diffProperties;
    exports.updateProperties=RobloxComponentProps.updateProperties;
    exports.cleanupHostComponent=RobloxComponentProps.cleanupHostComponent;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_boolean@1.2.7\boolean\src\toJSBoolean.lua
 tkpack.declare("game.Packages._Index.jsdotlua_boolean@1.2.7.boolean.toJSBoolean",function()
    local Number=tkpack.include("game.Packages._Index.jsdotlua_boolean@1.2.7.number");
    return function(val)
        return(((not(not(val)))and((val)~=(0)))and((val)~=("")))and(not(Number.isNaN(val)))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array",function()
    local ES7Types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return{["concat"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.concat"),["every"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.every"),["filter"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.filter"),["find"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.find"),["findIndex"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.findIndex"),["flat"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.flat"),["flatMap"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.flatMap"),["forEach"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.forEach"),["from"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from"),["includes"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.includes"),["indexOf"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.indexOf"),["isArray"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray"),["join"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.join"),["map"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.map"),["reduce"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.reduce"),["reverse"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.reverse"),["shift"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.shift"),["slice"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.slice"),["some"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.some"),["sort"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.sort"),["splice"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.splice"),["unshift"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.unshift")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Map\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map",function()
    local ES7Types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    local Map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.Map");
    local coerceToMap=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.coerceToMap");
    local coerceToTable=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.coerceToTable");
    type("not printable... yet");
    return{["Map"]=Map,["coerceToMap"]=coerceToMap,["coerceToTable"]=coerceToTable}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object",function()
    return{["assign"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.assign"),["entries"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.entries"),["freeze"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.freeze"),["is"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.is"),["isFrozen"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.isFrozen"),["keys"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.keys"),["preventExtensions"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.preventExtensions"),["seal"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.seal"),["values"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.values"),["None"]=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.None")}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Set\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Set",function()
    local __DEV__=_G.__DEV__;
    local inspect=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.inspect");
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local arrayForEach=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.forEach");
    local arrayFromString=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromString");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Set=({["__iter"]=function(self)
        return next,self._array
     end,["__tostring"]=function(self)
        local result="Set ";
        if(#(self._array))>(0)then
             result..=("(")..((tostring(#(self._array)))..(") "))
        end;
        result..=inspect(self._array);
        return result
     end});
    (Set).__index=Set;
    function Set.new(iterable)
        local array;
        local map={};
        if(iterable)~=(nil)then
             local arrayIterable;
            if(typeof(iterable))==("table")then
                 if isArray(iterable)then
                     arrayIterable=table.clone(iterable)
                else
                     local mt=getmetatable(iterable);
                    if(mt)and(rawget(mt,"__iter"))then
                         arrayIterable=iterable
                     elseif __DEV__ then
                         error("cannot create array from an object-like table")
                    end
                 end
             elseif(typeof(iterable))==("string")then
                 arrayIterable=arrayFromString(iterable)
            else
                 error(("cannot create array from value of type `%s`"):format(typeof(iterable)))
            end;
            if arrayIterable then
                 array=table.create(#(arrayIterable));
                for _,element in arrayIterable do
                     if not(map[element])then
                         map[element]=true;
                        table.insert(array,element)
                    end
                 end
             else
                 array={}
            end
         else
             array={}
        end;
        return(setmetatable({["size"]=#(array),["_map"]=map,["_array"]=array},Set))
    end;
    function Set:add(value)
        if not(self._map[value])then
             self.size=(self.size)+(1);
            self._map[value]=true;
            table.insert(self._array,value)
        end;
        return self
     end;
    function Set:clear()
        self.size=0;
        table.clear(self._map);
        table.clear(self._array)
    end;
    function Set:delete(value)
        if not(self._map[value])then
             return false
         end;
        self.size=(self.size)-(1);
        self._map[value]=nil;
        local index=table.find(self._array,value);
        if index then
             table.remove(self._array,index)
        end;
        return true
     end;
    function Set:forEach(callback,thisArg)
        if(typeof(callback))~=("function")then
             error("callback is not a function")
        end;
        arrayForEach(self._array,function(value)
            if(thisArg)~=(nil)then
                (callback)(thisArg,value,value,self)
            else
                (callback)(value,value,self)
            end
         end)
    end;
    function Set:has(value)
        return(self._map[value])~=(nil)
    end;
    function Set:ipairs()
        if __DEV__ then
             warn(debug.traceback("`for _,_ in mySet:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in mySet do` instead\x0a",2))
        end;
        return ipairs(self._array)
    end;
    return Set

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\WeakMap.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.WeakMap",function()
    local ES7Types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local WeakMap={};
    (WeakMap).__index=WeakMap;
    function WeakMap.new()
        local weakMap=setmetatable({},{["__mode"]="k"});
        return setmetatable({["_weakMap"]=weakMap},WeakMap)
    end;
    function WeakMap:get(key)
        return self._weakMap[key]
    end;
    function WeakMap:set(key,value)
        self._weakMap[key]=value;
        return self
     end;
    function WeakMap:has(key)
        return(self._weakMap[key])~=(nil)
    end;
    return WeakMap

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\inspect.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.inspect",function()
    local HttpService=game:GetService("HttpService");
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local ES7Types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local MAX_ARRAY_LENGTH=10;
    local DEFAULT_RECURSIVE_DEPTH=2;
    local formatValue;
    local formatObjectValue;
    local formatArray;
    local formatObject;
    local getObjectTag;
    local function inspect(value,options)
        local inspectOptions=(options)or({["depth"]=DEFAULT_RECURSIVE_DEPTH});
        local depth=(inspectOptions.depth)or(DEFAULT_RECURSIVE_DEPTH);
        inspectOptions.depth=if(depth)>=(0)then depth else DEFAULT_RECURSIVE_DEPTH;
        return formatValue(value,{},inspectOptions)
    end;
    local function isIndexKey(k,contiguousLength)
        return((((type(k))==("number"))and((k)<=(contiguousLength)))and((1)<=(k)))and((math.floor(k))==(k))
    end;
    local function getTableLength(tbl)
        local length=1;
        local value=rawget(tbl,length);
        while(value)~=(nil)do
             length+=1;
            value=rawget(tbl,length)
        end;
        return(length)-(1)
    end;
    local function sortKeysForPrinting(a,b)
        local typeofA=type(a);
        local typeofB=type(b);
        if((typeofA)==(typeofB))and((((typeofA)==("number"))or((typeofA)==("string"))))then
             return(a)<(b)
        end;
        return(typeofA)<(typeofB)
    end;
    local function rawpairs(t)
        return next,t,nil
     end;
    local function getFragmentedKeys(tbl)
        local keys={};
        local keysLength=0;
        local tableLength=getTableLength(tbl);
        for key,_ in rawpairs(tbl)do
             if not(isIndexKey(key,tableLength))then
                 keysLength=(keysLength)+(1);
                keys[keysLength]=key
             end
         end;
        table.sort(keys,sortKeysForPrinting);
        return keys,keysLength,tableLength
     end;
    function formatValue(value,seenValues,options)
        local valueType=typeof(value);
        if(valueType)==("string")then
             return HttpService:JSONEncode(value)
        elseif(valueType)==("number")then
             if(value)~=(value)then
                 return"NaN"
            elseif(value)==(math.huge)then
                 return"Infinity"
            elseif(value)==(-(math.huge))then
                 return"-Infinity"
            else
                 return tostring(value)
            end
         elseif(valueType)==("function")then
             local result="[function";
            local functionName=debug.info(value,"n");
            if((functionName)~=(nil))and((functionName)~=(""))then
                 result..=(" ")..(functionName)
            end;
            return(result)..("]")
        elseif(valueType)==("table")then
             return formatObjectValue(value,seenValues,options)
        else
             return tostring(value)
        end
     end;
    function formatObjectValue(value,previouslySeenValues,options)
        if(table.find(previouslySeenValues,value))~=(nil)then
             return"[Circular]"
        end;
        local seenValues={unpack(previouslySeenValues)};
        table.insert(seenValues,value);
        if(typeof(value.toJSON))==("function")then
             local jsonValue=value:toJSON(value);
            if(jsonValue)~=(value)then
                 if(typeof(jsonValue))==("string")then
                     return jsonValue
                 else
                     return formatValue(jsonValue,seenValues,options)
                end
             end
         elseif isArray(value)then
             return formatArray(value,seenValues,options)
        end;
        return formatObject(value,seenValues,options)
    end;
    function formatObject(object,seenValues,options)
        local result="";
        local mt=getmetatable(object);
        if(mt)and(rawget(mt,"__tostring"))then
             return tostring(object)
        end;
        local fragmentedKeys,fragmentedKeysLength,keysLength=getFragmentedKeys(object);
        if((keysLength)==(0))and((fragmentedKeysLength)==(0))then
             result..="{}";
            return result
         end;
        if(#(seenValues))>(options.depth)then
             result..=("[")..((getObjectTag(object))..("]"));
            return result
         end;
        local properties={};
        for i=1,keysLength do
             local value=formatValue(object[i],seenValues,options);
            table.insert(properties,value)
        end;
        for i=1,fragmentedKeysLength do
             local key=fragmentedKeys[i];
            local value=formatValue(object[key],seenValues,options);
            table.insert(properties,(key)..((": ")..(value)))
        end;
        result..=("{ ")..((table.concat(properties,", "))..(" }"));
        return result
     end;
    function formatArray(array,seenValues,options)
        local length=#(array);
        if(length)==(0)then
             return"[]"
        end;
        if(#(seenValues))>(options.depth)then
             return"[Array]"
        end;
        local len=math.min(MAX_ARRAY_LENGTH,length);
        local remaining=(length)-(len);
        local items={};
        for i=1,len do
             items[i]=(formatValue(array[i],seenValues,options))
        end;
        if(remaining)==(1)then
             table.insert(items,"... 1 more item")
        elseif(remaining)>(1)then
             table.insert(items,("... %s more items"):format(tostring(remaining)))
        end;
        return("[")..((table.concat(items,", "))..("]"))
    end;
    function getObjectTag(_object)
        return"Object"
    end;
    return inspect

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\es7-types.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types",function()
    return tkpack.include("game.Packages._Index.jsdotlua_es7-types@1.2.7.es7-types")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_console@1.2.7\console\src\makeConsoleImpl.lua
 tkpack.declare("game.Packages._Index.jsdotlua_console@1.2.7.console.makeConsoleImpl",function()
    local inspect=tkpack.include("game.Packages._Index.jsdotlua_console@1.2.7.collections").inspect;
    local INDENT="  ";
    return function()
        local console={};
        local indentDepth=0;
        local function indent()
            return string.rep(INDENT,indentDepth)
        end;
        function console.log(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            print((indent())..(message))
        end;
        function console.debug(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            print((indent())..(message))
        end;
        function console.info(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            print((indent())..(message))
        end;
        function console.warn(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            warn((indent())..(message))
        end;
        function console.error(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            warn((indent())..(message))
        end;
        function console.group(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            print((indent())..(message));
            indentDepth=(indentDepth)+(1)
        end;
        function console.groupCollapsed(content,...)
            local message;
            if(typeof(content))==("string")then
                 message=string.format(content,...)
            else
                 message=inspect(content)
            end;
            print((indent())..(message));
            indentDepth=(indentDepth)+(1)
        end;
        function console.groupEnd()
            if(indentDepth)>(0)then
                 indentDepth=(indentDepth)-(1)
            end
         end;
        return console
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_math@1.2.7\math\src\clz32.lua
 tkpack.declare("game.Packages._Index.jsdotlua_math@1.2.7.math.clz32",function()
    return bit32.countlz

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\isFinite.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.isFinite",function()
    return function(value)
        return((((typeof(value))==("number"))and((value)==(value)))and((value)~=(math.huge)))and((value)~=(-(math.huge)))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\isInteger.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.isInteger",function()
    return function(value)
        return(((type(value))==("number"))and((value)~=(math.huge)))and((value)==(math.floor(value)))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\isNaN.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.isNaN",function()
    return function(value)
        return((type(value))==("number"))and((value)~=(value))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\isSafeInteger.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.isSafeInteger",function()
    local isInteger=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.isInteger");
    local MAX_SAFE_INTEGER=tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number.MAX_SAFE_INTEGER");
    return function(value)
        return(isInteger(value))and((math.abs(value))<=(MAX_SAFE_INTEGER))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\MAX_SAFE_INTEGER.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.MAX_SAFE_INTEGER",function()
    return 9007199254740991

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\MIN_SAFE_INTEGER.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.MIN_SAFE_INTEGER",function()
    return-(9007199254740991)

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_number@1.2.7\number\src\toExponential.lua
 tkpack.declare("game.Packages._Index.jsdotlua_number@1.2.7.number.toExponential",function()
    return function(value,fractionDigits)
        local num=value;
        if(typeof(value))==("string")then
             local NaN=(0)/(0);
            num=(tonumber(value))or(NaN)
        end;
        if(typeof(num))~=("number")then
             return"nan"
        end;
        if(fractionDigits)~=(nil)then
             if(typeof(fractionDigits))~=("number")then
                 error("TypeError: fractionDigits must be a number between 0 and 100")
            end;
            if((fractionDigits)<(0))or((fractionDigits)>(100))then
                 error("RangeError: fractionDigits must be between 0 and 100")
            end
         end;
        local formatString;
        if(fractionDigits)==(nil)then
             formatString="%e"
        else
             formatString=("%.")..((tostring(fractionDigits))..("e"))
        end;
        local retval=string.format(formatString,num):gsub("%+0","+"):gsub("%-0","-"):gsub("0*e","e");
        return retval
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\charCodeAt.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.charCodeAt",function()
    local Number=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.number");
    local NaN=Number.NaN;
    return function(str,index)
        if(type(index))~=("number")then
             index=1
         end;
        local length=string.len(str);
        if((index)<(1))or((index)>(length))then
             return NaN
         end;
        local offset=utf8.offset(str,index);
        if((offset)==(nil))or((offset)>(length))then
             return NaN
         end;
        local value=utf8.codepoint(str,offset,offset);
        if(value)==(nil)then
             return NaN
         end;
        return value
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\endsWith.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.endsWith",function()
    local function endsWith(value,substring,optionalLength)
        local substringLength=substring:len();
        if(substringLength)==(0)then
             return true
         end;
        local valueLength=value:len();
        local length=(optionalLength)or(valueLength);
        if(length)>(valueLength)then
             length=valueLength
         end;
        if(length)<(1)then
             return false
         end;
        local position=((length)-(substringLength))+(1);
        return(value:find(substring,position,true))==(position)
    end;
    return endsWith

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\findOr.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.findOr",function()
    type("not printable... yet");
    local luaPatternCharacters=("([")..((("\x24%^()-[].?"):gsub("(.)","%%%1"))..("])"));
    local function findOr(str,patternTable,initIndex)
        local init=utf8.offset(str,(initIndex)or(1));
        local matches={};
        for _,value in patternTable do
             value=value:gsub(luaPatternCharacters,"%%%1");
            local iStart,iEnd=string.find(str,value,init);
            if iStart then
                 local prefix=string.sub(str,1,(iStart)-(1));
                local prefixEnd,invalidBytePosition=utf8.len(prefix);
                if(prefixEnd)==(nil)then
                     error(("string `%s` has an invalid byte at position %s"):format(prefix,tostring(invalidBytePosition)))
                end;
                local iStartIndex=(prefixEnd)+(1);
                local match={["index"]=iStartIndex,["match"]=string.sub(str,iStart,iEnd)};
                table.insert(matches,match)
            end
         end;
        if(#(matches))==(0)then
             return nil
         end;
        local firstMatch;
        for _,value in matches do
             if(firstMatch)==(nil)then
                 firstMatch=value
             end;
            if(value.index)<(firstMatch.index)then
                 firstMatch=value
             end
         end;
        return firstMatch
     end;
    return findOr

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\includes.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.includes",function()
    local luaPatternCharacters=("([")..((("\x24%^()-[].?"):gsub("(.)","%%%1"))..("])"));
    local function includes(str,substring,position)
        local strLen,invalidBytePosition=utf8.len(str);
        assert((strLen)~=(nil),("string `%s` has an invalid byte at position %s"):format(str,tostring(invalidBytePosition)));
        if(strLen)==(0)then
             return false
         end;
        if(#(substring))==(0)then
             return true
         end;
        local startIndex=1;
        if(position)~=(nil)then
             startIndex=(tonumber(position))or(1);
            if(startIndex)>(strLen)then
                 return false
             end
         end;
        if(startIndex)<(1)then
             startIndex=1
         end;
        local init=utf8.offset(str,startIndex);
        local value=substring:gsub(luaPatternCharacters,"%%%1");
        local iStart,_=string.find(str,value,init);
        return(iStart)~=(nil)
    end;
    return includes

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\indexOf.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.indexOf",function()
    local luaPatternCharacters=("([")..((("\x24%^()-[].?"):gsub("(.)","%%%1"))..("])"));
    return function(str,searchElement,fromIndex)
        local length=#(str);
        local fromIndex_=if(fromIndex)~=(nil)then if(fromIndex)<(1)then 1 else fromIndex else 1;
        if(#(searchElement))==(0)then
             return if(fromIndex_)>(length)then length else fromIndex_
         end;
        if(fromIndex_)>(length)then
             return-(1)
        end;
        searchElement=searchElement:gsub(luaPatternCharacters,"%%%1");
        local searchElementLength=#(searchElement);
        for i=fromIndex_,length do
             if(string.sub(str,i,((i)+(searchElementLength))-(1)))==(searchElement)then
                 return i
             end
         end;
        return-(1)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\lastIndexOf.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.lastIndexOf",function()
    local function lastIndexOf(str,searchValue,fromIndex)
        local strLength=string.len(str);
        local calculatedFromIndex;
        if fromIndex then
             calculatedFromIndex=fromIndex
         else
             calculatedFromIndex=strLength
         end;
        if(fromIndex)and((fromIndex)<(1))then
             calculatedFromIndex=1
         end;
        if(fromIndex)and((fromIndex)>(strLength))then
             calculatedFromIndex=strLength
         end;
        if(searchValue)==("")then
             return calculatedFromIndex
         end;
        local lastFoundStartIndex,foundStartIndex;
        local foundEndIndex=0;
        repeat
             lastFoundStartIndex=foundStartIndex;
            foundStartIndex,foundEndIndex=string.find(str,searchValue,(foundEndIndex)+(1),true)
        until((foundStartIndex)==(nil))or((foundStartIndex)>(calculatedFromIndex));
        if(lastFoundStartIndex)==(nil)then
             return-(1)
        end;
        return lastFoundStartIndex
     end;
    return lastIndexOf

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\slice.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.slice",function()
    local function slice(str,startIndexStr,lastIndexStr)
        local strLen,invalidBytePosition=utf8.len(str);
        assert((strLen)~=(nil),("string `%s` has an invalid byte at position %s"):format(str,tostring(invalidBytePosition)));
        local startIndex=tonumber(startIndexStr);
        assert((typeof(startIndex))==("number"),"startIndexStr should be a number");
        if((startIndex)+(strLen))<(0)then
             startIndex=1
         end;
        if(startIndex)>(strLen)then
             return""
        end;
        local lastIndex=(strLen)+(1);
        if(lastIndexStr)~=(nil)then
             local NaN=(0)/(0);
            lastIndex=(tonumber(lastIndexStr))or(NaN)
        end;
        assert((typeof(lastIndex))==("number"),"lastIndexStr should convert to number");
        if(lastIndex)>(strLen)then
             lastIndex=(strLen)+(1)
        end;
        local startIndexByte=utf8.offset(str,startIndex);
        local lastIndexByte=(utf8.offset(str,lastIndex))-(1);
        return string.sub(str,startIndexByte,lastIndexByte)
    end;
    return slice

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\split.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.split",function()
    local findOr=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.findOr");
    local slice=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.slice");
    local types=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.es7-types");
    type("not printable... yet");
    local MAX_SAFE_INTEGER=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.number").MAX_SAFE_INTEGER;
    type("not printable... yet");
    local function split(str,_pattern,_limit)
        if(_pattern)==(nil)then
             return{str}
        end;
        if(_limit)==(0)then
             return{}
        end;
        local limit=if((_limit)==(nil))or((_limit)<(0))then MAX_SAFE_INTEGER else _limit;
        local pattern=_pattern;
        local patternList;
        if(typeof(pattern))==("string")then
             if(pattern)==("")then
                 local result={};
                for c in str:gmatch(".")do
                     table.insert(result,c)
                end;
                return result
             end;
            patternList={pattern}
        else
             patternList=pattern
         end;
        local init=1;
        local result={};
        local lastMatch;
        local strLen,invalidBytePosition=utf8.len(str);
        assert((strLen)~=(nil),("string `%s` has an invalid byte at position %s"):format(str,tostring(invalidBytePosition)));
        repeat
             local match=findOr(str,patternList,init);
            if(match)~=(nil)then
                 table.insert(result,slice(str,init,match.index));
                local matchLength=utf8.len(match.match);
                init=(match.index)+(matchLength)
            else
                 table.insert(result,slice(str,init,nil))
            end;
            if(match)~=(nil)then
                 lastMatch=match
             end
         until(((match)==(nil))or((init)>(strLen)))or((#(result))>=(limit));
        if(lastMatch)~=(nil)then
             local lastMatchLength,invalidBytePosition_=utf8.len(lastMatch.match);
            assert((lastMatchLength)~=(nil),("string `%s` has an invalid byte at position %s"):format(lastMatch.match,tostring(invalidBytePosition_)));
            if((lastMatch.index)+(lastMatchLength))==((strLen)+(1))then
                 table.insert(result,"")
            end
         end;
        return result
     end;
    return split

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\startsWith.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.startsWith",function()
    local function startsWith(value,substring,position)
        if(string.len(substring))==(0)then
             return true
         end;
        local position_;
        if((position)==(nil))or((position)<(1))then
             position_=1
         else
             position_=position
         end;
        if(position_)>(string.len(value))then
             return false
         end;
        return(value:find(substring,position_,true))==(position_)
    end;
    return startsWith

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\substr.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.substr",function()
    return function(s,startIndex,numberOfCharacters)
        if(numberOfCharacters)and((numberOfCharacters)<=(0))then
             return""
        end;
        return string.sub(s,startIndex,((numberOfCharacters)and(((startIndex)+(numberOfCharacters))-(1)))or(nil))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\trim.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.trim",function()
    local trimStart=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimStart");
    local trimEnd=tkpack.include("game.Packages._Index.jsdotlua_string@1.2.7.string.trimEnd");
    return function(source)
        return trimStart(trimEnd(source))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\trimEnd.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.trimEnd",function()
    return function(source)
        return(source:gsub("[%s]+\x24",""))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\string\src\trimStart.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.string.trimStart",function()
    return function(source)
        return(source:gsub("^[%s]+",""))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_symbol-luau@1.0.1\symbol-luau\src\Symbol.lua
 tkpack.declare("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau.Symbol",function()
    type("not printable... yet");
    return{["new"]=function(name)
        local self=newproxy(true);
        local wrappedName="Symbol()";
        if name then
             wrappedName=("Symbol(%s)"):format(name)
        end;
        getmetatable(self).__tostring=function()
            return wrappedName
         end;
        return(self)
    end}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_symbol-luau@1.0.1\symbol-luau\src\Registry.global.lua
 tkpack.declare("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau.Registry.global",function()
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_symbol-luau@1.0.1.symbol-luau.Symbol");
    local GlobalRegistry={};
    return{["getOrInit"]=function(name)
        if(GlobalRegistry[name])==(nil)then
             GlobalRegistry[name]=Symbol.new(name)
        end;
        return GlobalRegistry[name]
    end,["__clear"]=function()
        GlobalRegistry={}
    end}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_timers@1.2.7\collections.lua
 tkpack.declare("game.Packages._Index.jsdotlua_timers@1.2.7.collections",function()
    return tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_timers@1.2.7\timers\src\makeTimerImpl.lua
 tkpack.declare("game.Packages._Index.jsdotlua_timers@1.2.7.timers.makeTimerImpl",function()
    local Status=newproxy(false);
    type("not printable... yet");
    type("not printable... yet");
    local SCHEDULED=1;
    local DONE=2;
    local CANCELLED=3;
    return function(delayImpl)
        local function setTimeout(callback,delayTime,...)
            local args={...};
            local task={[Status]=SCHEDULED};
            if(delayTime)==(nil)then
                 delayTime=0
             end;
            local delayTimeMs=(delayTime)/(1000);
            delayImpl(delayTimeMs,function()
                if(task[Status])==(SCHEDULED)then
                     callback(unpack(args));
                    task[Status]=DONE
                 end
             end);
            return task
         end;
        local function clearTimeout(task)
            if(task)==(nil)then
                 return
             end;
            if(task[Status])==(SCHEDULED)then
                 task[Status]=CANCELLED
             end
         end;
        return{["setTimeout"]=setTimeout,["clearTimeout"]=clearTimeout}
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_timers@1.2.7\timers\src\makeIntervalImpl.lua
 tkpack.declare("game.Packages._Index.jsdotlua_timers@1.2.7.timers.makeIntervalImpl",function()
    local Status=newproxy(false);
    type("not printable... yet");
    type("not printable... yet");
    local SCHEDULED=1;
    local CANCELLED=3;
    return function(delayImpl)
        local function setInterval(callback,intervalTime,...)
            local args={...};
            local task={[Status]=SCHEDULED};
            if(intervalTime)==(nil)then
                 intervalTime=0
             end;
            local intervalTimeMs=(intervalTime)/(1000);
            local delay_;
            delay_=function()
                delayImpl(intervalTimeMs,function()
                    if(task[Status])==(SCHEDULED)then
                         callback(unpack(args));
                        delay_()
                    end
                 end)
            end;
            delay_();
            return task
         end;
        local function clearInterval(task)
            if(task)==(nil)then
                 return
             end;
            if(task[Status])==(SCHEDULED)then
                 task[Status]=CANCELLED
             end
         end;
        return{["setInterval"]=setInterval,["clearInterval"]=clearInterval}
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_instance-of@1.2.7\instance-of\src\instanceof.lua
 tkpack.declare("game.Packages._Index.jsdotlua_instance-of@1.2.7.instance-of.instanceof",function()
    local __DEV__=_G.__DEV__;
    local function instanceof(tbl,class)
        if __DEV__ then
             assert((typeof(class))==("table"),"Received a non-table as the second argument for instanceof")
        end;
        if(typeof(tbl))~=("table")then
             return false
         end;
        local ok,hasNew=pcall(function()
            return((class.new)~=(nil))and((tbl.new)==(class.new))
        end);
        if(ok)and(hasNew)then
             return true
         end;
        local seen={[tbl]=true};
        while(tbl)and((typeof(tbl))==("table"))do
             tbl=getmetatable(tbl);
            if(typeof(tbl))==("table")then
                 tbl=tbl.__index;
                if(tbl)==(class)then
                     return true
                 end
             end;
            if(typeof(tbl))==("table")then
                 if seen[tbl]then
                     return false
                 end;
                seen[tbl]=true
             end
         end;
        return false
     end;
    return instanceof

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\luau-polyfill.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill",function()
    return tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\shared.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared",function()
    return tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactWorkTags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags",function()
    type("not printable... yet");
    return{["FunctionComponent"]=0,["ClassComponent"]=1,["IndeterminateComponent"]=2,["HostRoot"]=3,["HostPortal"]=4,["HostComponent"]=5,["HostText"]=6,["Fragment"]=7,["Mode"]=8,["ContextConsumer"]=9,["ContextProvider"]=10,["ForwardRef"]=11,["Profiler"]=12,["SuspenseComponent"]=13,["MemoComponent"]=14,["SimpleMemoComponent"]=15,["LazyComponent"]=16,["IncompleteClassComponent"]=17,["DehydratedFragment"]=18,["SuspenseListComponent"]=19,["FundamentalComponent"]=20,["ScopeComponent"]=21,["Block"]=22,["OffscreenComponent"]=23,["LegacyHiddenComponent"]=24}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactTypeOfMode.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode",function()
    type("not printable... yet");
    return{["NoMode"]=0,["StrictMode"]=1,["BlockingMode"]=2,["ConcurrentMode"]=4,["ProfileMode"]=8,["DebugTracingMode"]=16}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberFlags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags",function()
    type("not printable... yet");
    local exports={};
    exports.NoFlags=0;
    exports.PerformedWork=1;
    exports.Placement=2;
    exports.Update=4;
    exports.PlacementAndUpdate=6;
    exports.Deletion=8;
    exports.ContentReset=16;
    exports.Callback=32;
    exports.DidCapture=64;
    exports.Ref=128;
    exports.Snapshot=256;
    exports.Passive=512;
    exports.PassiveUnmountPendingDev=8192;
    exports.Hydrating=1024;
    exports.HydratingAndUpdate=1028;
    exports.LifecycleEffectMask=932;
    exports.HostEffectMask=2047;
    exports.Incomplete=2048;
    exports.ShouldCapture=4096;
    exports.ForceUpdateForLegacySuspense=16384;
    exports.PassiveStatic=32768;
    exports.BeforeMutationMask=778;
    exports.MutationMask=1182;
    exports.LayoutMask=164;
    exports.PassiveMask=520;
    exports.StaticMask=32768;
    exports.MountLayoutDev=65536;
    exports.MountPassiveDev=131072;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\scheduler.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler",function()
    return tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberReconciler.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberReconciler.new",function()
    local __DEV__=_G.__DEV__;
    local flowtypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local Object=LuauPolyfill.Object;
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRootTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags");
    type("not printable... yet");
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local FundamentalComponent=ReactWorkTags.FundamentalComponent;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local ReactFiberTreeReflection=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTreeReflection");
    local findCurrentHostFiber=ReactFiberTreeReflection.findCurrentHostFiber;
    local findCurrentHostFiberWithNoPortals=ReactFiberTreeReflection.findCurrentHostFiberWithNoPortals;
    local getInstance=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactInstanceMap.get;
    local HostComponent=ReactWorkTags.HostComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local enableSchedulingProfiler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.enableSchedulingProfiler;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local getPublicInstance=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig").getPublicInstance;
    local ReactFiberContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new");
    local findCurrentUnmaskedContext=ReactFiberContext.findCurrentUnmaskedContext;
    local processChildContext=ReactFiberContext.processChildContext;
    local emptyContextObject=ReactFiberContext.emptyContextObject;
    local isLegacyContextProvider=ReactFiberContext.isContextProvider;
    local ReactFiberRoot=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberRoot.new");
    local createFiberRoot=ReactFiberRoot.createFiberRoot;
    local ReactFiberDevToolsHook=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberDevToolsHook.new");
    local injectInternals=ReactFiberDevToolsHook.injectInternals;
    local onScheduleRoot=ReactFiberDevToolsHook.onScheduleRoot;
    local ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
    local requestEventTime=ReactFiberWorkLoop.requestEventTime;
    local requestUpdateLane=ReactFiberWorkLoop.requestUpdateLane;
    local scheduleUpdateOnFiber=ReactFiberWorkLoop.scheduleUpdateOnFiber;
    local flushRoot=ReactFiberWorkLoop.flushRoot;
    local batchedEventUpdates=ReactFiberWorkLoop.batchedEventUpdates;
    local batchedUpdates=ReactFiberWorkLoop.batchedUpdates;
    local unbatchedUpdates=ReactFiberWorkLoop.unbatchedUpdates;
    local flushSync=ReactFiberWorkLoop.flushSync;
    local flushControlled=ReactFiberWorkLoop.flushControlled;
    local deferredUpdates=ReactFiberWorkLoop.deferredUpdates;
    local discreteUpdates=ReactFiberWorkLoop.discreteUpdates;
    local flushDiscreteUpdates=ReactFiberWorkLoop.flushDiscreteUpdates;
    local flushPassiveEffects=ReactFiberWorkLoop.flushPassiveEffects;
    local warnIfNotScopedWithMatchingAct=ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct;
    local warnIfUnmockedScheduler=ReactFiberWorkLoop.warnIfUnmockedScheduler;
    local IsThisRendererActing=ReactFiberWorkLoop.IsThisRendererActing;
    local act=ReactFiberWorkLoop.act;
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    local createUpdate=ReactUpdateQueue.createUpdate;
    local enqueueUpdate=ReactUpdateQueue.enqueueUpdate;
    local ReactCurrentFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber");
    local ReactCurrentFiberIsRendering=ReactCurrentFiber.isRendering;
    local resetCurrentDebugFiberInDEV=ReactCurrentFiber.resetCurrentFiber;
    local setCurrentDebugFiberInDEV=ReactCurrentFiber.setCurrentFiber;
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local StrictMode=ReactTypeOfMode.StrictMode;
    local SyncLane=ReactFiberLane.SyncLane;
    local InputDiscreteHydrationLane=ReactFiberLane.InputDiscreteHydrationLane;
    local SelectiveHydrationLane=ReactFiberLane.SelectiveHydrationLane;
    local NoTimestamp=ReactFiberLane.NoTimestamp;
    local getHighestPriorityPendingLanes=ReactFiberLane.getHighestPriorityPendingLanes;
    local higherPriorityLane=ReactFiberLane.higherPriorityLane;
    local getCurrentUpdateLanePriority=ReactFiberLane.getCurrentUpdateLanePriority;
    local setCurrentUpdateLanePriority=ReactFiberLane.setCurrentUpdateLanePriority;
    local markRenderScheduled=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler").markRenderScheduled;
    local exports={};
    exports.ReactRootTags=ReactRootTags;
    exports.ReactWorkTags=ReactWorkTags;
    exports.ReactTypeOfMode=ReactTypeOfMode;
    exports.ReactFiberFlags=ReactFiberFlags;
    exports.getNearestMountedFiber=ReactFiberTreeReflection.getNearestMountedFiber;
    exports.findCurrentFiberUsingSlowPath=ReactFiberTreeReflection.findCurrentFiberUsingSlowPath;
    exports.createPortal=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactPortal").createPortal;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local didWarnAboutNestedUpdates;
    local didWarnAboutFindNodeInStrictMode;
    if __DEV__ then
         didWarnAboutNestedUpdates=false;
        didWarnAboutFindNodeInStrictMode={}
    end;
    local function getContextForSubtree(parentComponent)
        if not(parentComponent)then
             return emptyContextObject
         end;
        local fiber=getInstance(parentComponent);
        local parentContext=findCurrentUnmaskedContext(fiber);
        if(fiber.tag)==(ClassComponent)then
             local Component=fiber.type;
            if isLegacyContextProvider(Component)then
                 return processChildContext(fiber,Component,parentContext)
            end
         end;
        return parentContext
     end;
    local function findHostInstance(component)
        local fiber=getInstance(component);
        if(fiber)==(nil)then
             if(typeof(component.render))==("function")then
                 invariant(false,"Unable to find node on an unmounted component.")
            else
                 invariant(false,"Argument appears to not be a ReactComponent. Keys: %s",table.concat(Object.keys(component)))
            end
         end;
        local hostFiber=findCurrentHostFiber(fiber);
        if(hostFiber)==(nil)then
             return nil
         end;
        return hostFiber.stateNode
     end;
    local function findHostInstanceWithWarning(component,methodName)
        if __DEV__ then
             local fiber=getInstance(component);
            if(fiber)==(nil)then
                 if(typeof(component.render))==("function")then
                     invariant(false,"Unable to find node on an unmounted component.")
                else
                     invariant(false,"Argument appears to not be a ReactComponent. Keys: %s",table.concat(Object.keys(component)))
                end
             end;
            local hostFiber=findCurrentHostFiber(fiber);
            if(hostFiber)==(nil)then
                 return nil
             end;
            if(bit32.band(hostFiber.mode,StrictMode))~=(0)then
                 local componentName=(getComponentName(fiber.type))or("Component");
                if not(didWarnAboutFindNodeInStrictMode[componentName])then
                     didWarnAboutFindNodeInStrictMode[componentName]=true;
                    local previousFiber=ReactCurrentFiber.current;
                    local ok,result=xpcall(function()
                        setCurrentDebugFiberInDEV(hostFiber);
                        if(bit32.band(fiber.mode,StrictMode))~=(0)then
                             console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName)
                        else
                             console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName)
                        end
                     end,describeError);
                    if previousFiber then
                         setCurrentDebugFiberInDEV(previousFiber)
                    else
                         resetCurrentDebugFiberInDEV()
                    end;
                    if not(ok)then
                         error(result)
                    end
                 end
             end;
            return hostFiber.stateNode
         end;
        return findHostInstance(component)
    end;
    exports.createContainer=function(containerInfo,tag,hydrate,hydrationCallbacks)
        return createFiberRoot(containerInfo,tag,hydrate,hydrationCallbacks)
    end;
    exports.updateContainer=function(element,container,parentComponent,callback)
        if __DEV__ then
             onScheduleRoot(container,element)
        end;
        local current=container.current;
        local eventTime=requestEventTime();
        if __DEV__ then
             if _G.__TESTEZ_RUNNING_TEST__ then
                 warnIfUnmockedScheduler(current);
                warnIfNotScopedWithMatchingAct(current)
            end
         end;
        local lane=requestUpdateLane(current);
        if enableSchedulingProfiler then
             markRenderScheduled(lane)
        end;
        local context=getContextForSubtree(parentComponent);
        if(container.context)==(nil)then
             container.context=context
         else
             container.pendingContext=context
         end;
        if __DEV__ then
             if((ReactCurrentFiberIsRendering)and((ReactCurrentFiber.current)~=(nil)))and(not(didWarnAboutNestedUpdates))then
                 didWarnAboutNestedUpdates=true;
                console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\x0a\x0aCheck the render method of %s.",(getComponentName((ReactCurrentFiber.current).type))or("Unknown"))
            end
         end;
        local update=createUpdate(eventTime,lane);
        if(element)==(nil)then
             element=Object.None
         end;
        update.payload={["element"]=element};
        if(callback)~=(nil)then
             if __DEV__ then
                 if(typeof(callback))~=("function")then
                     console.error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",tostring(callback))
                end
             end;
            update.callback=callback
         end;
        enqueueUpdate(current,update);
        scheduleUpdateOnFiber(current,lane,eventTime);
        return lane
     end;
    exports.batchedEventUpdates=batchedEventUpdates;
    exports.batchedUpdates=batchedUpdates;
    exports.unbatchedUpdates=unbatchedUpdates;
    exports.deferredUpdates=deferredUpdates;
    exports.discreteUpdates=discreteUpdates;
    exports.flushDiscreteUpdates=flushDiscreteUpdates;
    exports.flushControlled=flushControlled;
    exports.flushSync=flushSync;
    exports.flushPassiveEffects=flushPassiveEffects;
    exports.IsThisRendererActing=IsThisRendererActing;
    exports.act=act;
    exports.getPublicRootInstance=function(container)
        local containerFiber=container.current;
        if not(containerFiber.child)then
             return nil
         end;
        if(containerFiber.child.tag)==(HostComponent)then
             return getPublicInstance(containerFiber.child.stateNode)
        else
             return containerFiber.child.stateNode
         end
     end;
    local markRetryLaneIfNotHydrated;
    exports.attemptSynchronousHydration=function(fiber)
        if(fiber.tag)==(HostRoot)then
             local root=fiber.stateNode;
            if root.hydrate then
                 local lanes=getHighestPriorityPendingLanes(root);
                flushRoot(root,lanes)
            end
         elseif(fiber.tag)==(SuspenseComponent)then
             local eventTime=requestEventTime();
            flushSync(function()
                return scheduleUpdateOnFiber(fiber,SyncLane,eventTime)
            end);
            local retryLane=InputDiscreteHydrationLane;
            markRetryLaneIfNotHydrated(fiber,retryLane)
        end
     end;
    local function markRetryLaneImpl(fiber,retryLane)
        local suspenseState=fiber.memoizedState;
        if suspenseState then
             if((suspenseState)~=(nil))and((suspenseState.dehydrated)~=(nil))then
                 suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane)
            end
         end
     end;
    markRetryLaneIfNotHydrated=function(fiber,retryLane)
        markRetryLaneImpl(fiber,retryLane);
        local alternate=fiber.alternate;
        if alternate then
             markRetryLaneImpl(alternate,retryLane)
        end
     end;
    exports.attemptUserBlockingHydration=function(fiber)
        if(fiber.tag)~=(SuspenseComponent)then
             return
         end;
        local eventTime=requestEventTime();
        local lane=InputDiscreteHydrationLane;
        scheduleUpdateOnFiber(fiber,lane,eventTime);
        markRetryLaneIfNotHydrated(fiber,lane)
    end;
    exports.attemptContinuousHydration=function(fiber)
        if(fiber.tag)~=(SuspenseComponent)then
             return
         end;
        local eventTime=requestEventTime();
        local lane=SelectiveHydrationLane;
        scheduleUpdateOnFiber(fiber,lane,eventTime);
        markRetryLaneIfNotHydrated(fiber,lane)
    end;
    exports.attemptHydrationAtCurrentPriority=function(fiber)
        if(fiber.tag)~=(SuspenseComponent)then
             return
         end;
        local eventTime=requestEventTime();
        local lane=requestUpdateLane(fiber);
        scheduleUpdateOnFiber(fiber,lane,eventTime);
        markRetryLaneIfNotHydrated(fiber,lane)
    end;
    exports.runWithPriority=function(priority,fn)
        local previousPriority=getCurrentUpdateLanePriority();
        setCurrentUpdateLanePriority(priority);
        local ok,result=xpcall(fn,describeError);
        setCurrentUpdateLanePriority(previousPriority);
        if not(ok)then
             error(result)
        end;
        return result
     end;
    exports.getCurrentUpdateLanePriority=getCurrentUpdateLanePriority;
    exports.findHostInstance=findHostInstance;
    exports.findHostInstanceWithWarning=findHostInstanceWithWarning;
    exports.findHostInstanceWithNoPortals=function(fiber)
        local hostFiber=findCurrentHostFiberWithNoPortals(fiber);
        if(hostFiber)==(nil)then
             return nil
         end;
        if(hostFiber.tag)==(FundamentalComponent)then
             return hostFiber.stateNode.instance
         end;
        return hostFiber.stateNode
     end;
    local function shouldSuspendImpl(fiber)
        return false
     end;
    exports.shouldSuspend=function(fiber)
        return shouldSuspendImpl(fiber)
    end;
    local overrideHookState;
    local overrideHookStateDeletePath;
    local overrideHookStateRenamePath;
    local overrideProps;
    local overridePropsDeletePath;
    local overridePropsRenamePath;
    local scheduleUpdate;
    local setSuspenseHandler;
    if __DEV__ then
         local function copyWithDeleteImpl(obj,path,index)
            local key=path[index];
            local updated;
            if Array.isArray(obj)then
                 updated=Array.slice(obj)
            else
                 updated=table.clone(obj)
            end;
            if((index)+(1))==(#(path))then
                 if Array.isArray(updated)then
                     local updatedIndex=key;
                    Array.splice(updated,updatedIndex,1)
                else
                     updated[key]=nil
                 end;
                return updated
             end;
            updated[key]=copyWithDeleteImpl(obj[key],path,(index)+(1));
            return updated
         end;
        local function copyWithDelete(obj,path)
            return copyWithDeleteImpl(obj,path,0)
        end;
        local function copyWithRenameImpl(obj,oldPath,newPath,index)
            local oldKey=oldPath[index];
            local updated;
            if Array.isArray(obj)then
                 updated=Array.slice(obj)
            else
                 updated=table.clone(obj)
            end;
            if((index)+(1))==(#(oldPath))then
                 local newKey=newPath[index];
                updated[newKey]=updated[oldKey];
                if Array.isArray(updated)then
                     Array.splice(updated,oldKey,1)
                else
                     updated[oldKey]=nil
                 end
             else
                 updated[oldKey]=copyWithRenameImpl(obj[oldKey],oldPath,newPath,(index)+(1))
            end;
            return updated
         end;
        local function copyWithRename(obj,oldPath,newPath)
            if(#(oldPath))~=(#(newPath))then
                 console.warn("copyWithRename() expects paths of the same length");
                return nil
             else
                 for i=1,#(newPath)do
                     if(oldPath[i])~=(newPath[i])then
                         console.warn("copyWithRename() expects paths to be the same except for the deepest key");
                        return nil
                     end
                 end
             end;
            return copyWithRenameImpl(obj,oldPath,newPath,0)
        end;
        local function copyWithSetImpl(obj,path,index,value)
            if(index)>=(((#(path))+(1)))then
                 return value
             end;
            local key=path[index];
            local updated;
            if Array.isArray(obj)then
                 updated=Array.slice(obj)
            else
                 updated=table.clone(obj)
            end;
            updated[key]=copyWithSetImpl(obj[key],path,(index)+(2),value);
            return updated
         end;
        local function copyWithSet(obj,path,value)
            return copyWithSetImpl(obj,path,1,value)
        end;
        local function findHook(fiber,id)
            local currentHook=fiber.memoizedState;
            while((currentHook)~=(nil))and((id)>(1))do
                 currentHook=currentHook.next;
                id-=1
             end;
            return currentHook
         end;
        overrideHookState=function(fiber,id,path,value)
            local hook=findHook(fiber,id);
            if(hook)~=(nil)then
                 local newState=copyWithSet(hook.memoizedState,path,value);
                hook.memoizedState=newState;
                hook.baseState=newState;
                fiber.memoizedProps=table.clone(fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
            end
         end;
        overrideHookStateDeletePath=function(fiber,id,path)
            local hook=findHook(fiber,id);
            if(hook)~=(nil)then
                 local newState=copyWithDelete(hook.memoizedState,path);
                hook.memoizedState=newState;
                hook.baseState=newState;
                fiber.memoizedProps=table.clone(fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
            end
         end;
        overrideHookStateRenamePath=function(fiber,id,oldPath,newPath)
            local hook=findHook(fiber,id);
            if(hook)~=(nil)then
                 local newState=copyWithRename(hook.memoizedState,oldPath,newPath);
                hook.memoizedState=newState;
                hook.baseState=newState;
                fiber.memoizedProps=table.clone(fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
            end
         end;
        overrideProps=function(fiber,path,value)
            fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);
            local alternate=fiber.alternate;
            if alternate then
                 alternate.pendingProps=fiber.pendingProps
             end;
            scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
        end;
        overridePropsDeletePath=function(fiber,path)
            fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);
            local alternate=fiber.alternate;
            if alternate then
                 alternate.pendingProps=fiber.pendingProps
             end;
            scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
        end;
        overridePropsRenamePath=function(fiber,oldPath,newPath)
            fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);
            local alternate=fiber.alternate;
            if alternate then
                 alternate.pendingProps=fiber.pendingProps
             end;
            scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
        end;
        scheduleUpdate=function(fiber)
            scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)
        end;
        setSuspenseHandler=function(newShouldSuspendImpl)
            shouldSuspendImpl=newShouldSuspendImpl
         end
     end;
    function findHostInstanceByFiber(fiber)
        local hostFiber=findCurrentHostFiber(fiber);
        if(hostFiber)==(nil)then
             return nil
         end;
        return hostFiber.stateNode
     end;
    function emptyFindFiberByHostInstance(instance)
        return nil
     end;
    function getCurrentFiberForDevTools()
        return ReactCurrentFiber.current
     end;
    exports.injectIntoDevTools=function(devToolsConfig)
        local findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;
        local ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;
        local getCurrentFiber;
        if __DEV__ then
             getCurrentFiber=getCurrentFiberForDevTools
         end;
        return injectInternals({["bundleType"]=devToolsConfig.bundleType,["version"]=devToolsConfig.version,["rendererPackageName"]=devToolsConfig.rendererPackageName,["rendererConfig"]=devToolsConfig.rendererConfig,["overrideHookState"]=overrideHookState,["overrideHookStateDeletePath"]=overrideHookStateDeletePath,["overrideHookStateRenamePath"]=overrideHookStateRenamePath,["overrideProps"]=overrideProps,["overridePropsDeletePath"]=overridePropsDeletePath,["overridePropsRenamePath"]=overridePropsRenamePath,["setSuspenseHandler"]=setSuspenseHandler,["scheduleUpdate"]=scheduleUpdate,["currentDispatcherRef"]=ReactCurrentDispatcher,["findHostInstanceByFiber"]=findHostInstanceByFiber,["findFiberByHostInstance"]=(findFiberByHostInstance)or(emptyFindFiberByHostInstance),["getCurrentFiber"]=getCurrentFiber})
    end;
    exports.robloxReactProfiling=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.RobloxReactProfiling");
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\roblox\RobloxComponentProps.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.RobloxComponentProps",function()
    local __DEV__=_G.__DEV__;
    local CollectionService=game:GetService("CollectionService");
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local inspect=LuauPolyfill.util.inspect;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").console;
    local React=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").ReactSymbols;
    local SingleEventManager=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.SingleEventManager");
    type("not printable... yet");
    local Type=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").Type;
    local getDefaultInstanceProperty=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.getDefaultInstanceProperty");
    local ReactRobloxHostTypes=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.ReactRobloxHostTypes.roblox");
    type("not printable... yet");
    local Tag=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react").Tag;
    type("not printable... yet");
    type("not printable... yet");
    local instanceToEventManager={};
    local instanceToBindings={};
    local applyPropsError="Error applying initial props to Roblox Instance '%s' (%s):\x0a  %s\x0a";
    local updatePropsError="Error updating props on Roblox Instance '%s' (%s):\x0a  %s\x0a";
    local updateBindingError="Error updating binding or ref assigned to key %s of '%s' (%s).\x0a\x0aUpdated value:\x0a  %s\x0a\x0aError:\x0a  %s\x0a\x0a%s\x0a";
    local function identity(...)
        return...
    end;
    local function setRobloxInstanceProperty(hostInstance,key,newValue)
        if(newValue)==(nil)then
             local success,_=pcall(hostInstance.ResetPropertyToDefault,hostInstance,key);
            if success then
                 return
             end;
            local hostClass=hostInstance.ClassName;
            local _,defaultValue=getDefaultInstanceProperty(hostClass,key);
            newValue=defaultValue
         end;
        hostInstance[key]=newValue
     end;
    local function removeBinding(hostInstance,key)
        local bindings=instanceToBindings[hostInstance];
        if(bindings)~=(nil)then
             local disconnect=bindings[key];
            disconnect();
            bindings[key]=nil
         end
     end;
    local function attachBinding(hostInstance,key,newBinding)
        local function updateBoundProperty(newValue)
            local success,errorMessage=xpcall(setRobloxInstanceProperty,identity,hostInstance,key,newValue);
            if not(success)then
                 local source=(newBinding._source)or("<enable DEV mode for stack>");
                local fullMessage=string.format(updateBindingError,key,hostInstance.Name,hostInstance.ClassName,tostring(newValue),errorMessage,source);
                console.error(fullMessage);
                error(fullMessage,0)
            end
         end;
        if(instanceToBindings[hostInstance])==(nil)then
             instanceToBindings[hostInstance]={}
        end;
        instanceToBindings[hostInstance][key]=React.__subscribeToBinding(newBinding,updateBoundProperty);
        updateBoundProperty(newBinding:getValue())
    end;
    local function applyTags(hostInstance,oldTags,newTags)
        if __DEV__ then
             if((newTags)~=(nil))and((typeof(newTags))~=("string"))then
                 console.error("Type provided for ReactRoblox.Tag is invalid - tags should be specified as a single string, with individual tags delimited by spaces. Instead received:\x0a%s",inspect(newTags));
                return
             end
         end;
        local oldTagSet={};
        for str in string.gmatch((oldTags)or(""),"%S+")do
             oldTagSet[str]=true
         end;
        local newTagSet={};
        for str in string.gmatch((newTags)or(""),"%S+")do
             newTagSet[str]=true
         end;
        for tag,_ in oldTagSet do
             if not(newTagSet[tag])then
                 CollectionService:RemoveTag(hostInstance,tag)
            end
         end;
        for tag,_ in newTagSet do
             if not(oldTagSet[tag])then
                 CollectionService:AddTag(hostInstance,tag)
            end
         end
     end;
    local function removeAllTags(hostInstance)
        for _,tag in CollectionService:GetTags(hostInstance)do
             CollectionService:RemoveTag(hostInstance,tag)
        end
     end;
    local function applyProp(hostInstance,key,newValue,oldValue)
        local internalKeyType=Type.of(key);
        if((internalKeyType)==(Type.HostEvent))or((internalKeyType)==(Type.HostChangeEvent))then
             local eventManager=instanceToEventManager[hostInstance];
            if(eventManager)==(nil)then
                 eventManager=(SingleEventManager.new(hostInstance));
                instanceToEventManager[hostInstance]=eventManager
             end;
            local eventName=key.name;
            if(internalKeyType)==(Type.HostChangeEvent)then
                 eventManager:connectPropertyChange(eventName,newValue)
            else
                 eventManager:connectEvent(eventName,newValue)
            end;
            return
         end;
        local newIsBinding=((typeof(newValue))==("table"))and((newValue["\x24\x24typeof"])==(ReactSymbols.REACT_BINDING_TYPE));
        local oldIsBinding=(((oldValue)~=(nil))and((typeof(oldValue))==("table")))and((oldValue["\x24\x24typeof"])==(ReactSymbols.REACT_BINDING_TYPE));
        if oldIsBinding then
             removeBinding(hostInstance,key)
        end;
        if newIsBinding then
             attachBinding(hostInstance,key,newValue)
        elseif(key)==(Tag)then
             applyTags(hostInstance,oldValue,newValue)
        else
             setRobloxInstanceProperty(hostInstance,key,newValue)
        end
     end;
    local function applyProps(hostInstance,props)
        for propKey,value in props do
             if((propKey)==("ref"))or((propKey)==("children"))then
                 continue
             end;
            applyProp(hostInstance,propKey,value)
        end
     end;
    local function setInitialProperties(domElement,_tag,rawProps,_rootContainerElement)
        local success,errorMessage=xpcall(applyProps,identity,domElement,rawProps);
        if not(success)then
             local fullMessage=string.format(applyPropsError,domElement.Name,domElement.ClassName,errorMessage);
            console.error(fullMessage);
            error(fullMessage,0)
        end;
        if(instanceToEventManager[domElement])~=(nil)then
             instanceToEventManager[domElement]:resume()
        end
     end;
    local function safelyApplyProperties(domElement,updatePayload,lastProps)
        local updatePayloadCount=#(updatePayload);
        for i=1,updatePayloadCount,2 do
             local propKey=updatePayload[i];
            local value=updatePayload[(i)+(1)];
            if(value)==(Object.None)then
                 value=nil
             end;
            if((propKey)~=("ref"))and((propKey)~=("children"))then
                 applyProp(domElement,propKey,value,lastProps[propKey])
            end
         end
     end;
    local function updateProperties(domElement,updatePayload,lastProps)
        if(instanceToEventManager[domElement])~=(nil)then
             instanceToEventManager[domElement]:suspend()
        end;
        local success,errorMessage=xpcall(safelyApplyProperties,identity,domElement,updatePayload,lastProps);
        if not(success)then
             local fullMessage=string.format(updatePropsError,domElement.Name,domElement.ClassName,errorMessage);
            console.error(fullMessage);
            error(fullMessage,0)
        end;
        if(instanceToEventManager[domElement])~=(nil)then
             instanceToEventManager[domElement]:resume()
        end
     end;
    local function cleanupBindings(domElement)
        local instanceBindings=instanceToBindings[domElement];
        if(instanceBindings)~=(nil)then
             for _,disconnectBinding in instanceBindings do
                 disconnectBinding()
            end;
            instanceToBindings[domElement]=nil
         end
     end;
    local function cleanupHostComponent(domElement)
        if(instanceToEventManager[domElement])~=(nil)then
             instanceToEventManager[domElement]=nil
         end;
        cleanupBindings(domElement);
        if(typeof(domElement))~=("Instance")then
             return
         end;
        removeAllTags(domElement);
        for _,descElement in domElement:GetDescendants()do
             if(instanceToEventManager[descElement])~=(nil)then
                 instanceToEventManager[descElement]=nil
             end;
            cleanupBindings(descElement);
            removeAllTags(domElement)
        end
     end;
    return{["setInitialProperties"]=setInitialProperties,["updateProperties"]=updateProperties,["cleanupHostComponent"]=cleanupHostComponent,["_instanceToEventManager"]=instanceToEventManager,["_instanceToBindings"]=instanceToBindings}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_boolean@1.2.7\number.lua
 tkpack.declare("game.Packages._Index.jsdotlua_boolean@1.2.7.number",function()
    return tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\concat.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.concat",function()
    local __DEV__=_G.__DEV__;
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    local RECEIVED_OBJECT_ERROR="Array.concat(...) only works with array-like tables but it received an object-like table.\x0aYou can avoid this error by wrapping the object-like table into an array. Example: `concat({1, 2}, {a = true})` should be `concat({1, 2}, { {a = true} }`";
    local function concat(source,...)
        local array;
        local elementCount=0;
        if isArray(source)then
             array=table.clone(source);
            elementCount=#((source))
        else
             elementCount+=1;
            array={};
            array[elementCount]=source
         end;
        for i=1,select("\x23",...)do
             local value=select(i,...);
            local valueType=typeof(value);
            if(value)==(nil)then
                
             elseif(valueType)==("table")then
                 if __DEV__ then
                     if not(isArray(value))then
                         error(RECEIVED_OBJECT_ERROR)
                    end
                 end;
                for k=1,#(value)do
                     elementCount+=1;
                    array[elementCount]=value[k]
                end
             else
                 elementCount+=1;
                array[elementCount]=value
             end
         end;
        return(array)
    end;
    return concat

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\every.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.every",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(t,callback,thisArg)
        if __DEV__ then
             if(typeof(t))~=("table")then
                 error(string.format("Array.every called on %s",typeof(t)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        local len=#(t);
        local k=1;
        while(k)<=(len)do
             local kValue=t[k];
            local testResult;
            if(kValue)~=(nil)then
                 if(thisArg)~=(nil)then
                     testResult=(callback)(thisArg,kValue,k,t)
                else
                     testResult=(callback)(kValue,k,t)
                end;
                if not(testResult)then
                     return false
                 end
             end;
            k+=1
         end;
        return true
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\filter.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.filter",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(t,callback,thisArg)
        if __DEV__ then
             if(typeof(t))~=("table")then
                 error(string.format("Array.filter called on %s",typeof(t)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        local len=#(t);
        local res={};
        local index=1;
        if(thisArg)==(nil)then
             for i=1,len do
                 local kValue=t[i];
                if(kValue)~=(nil)then
                     if(callback)(kValue,i,t)then
                         res[index]=kValue;
                        index+=1
                     end
                 end
             end
         else
             for i=1,len do
                 local kValue=t[i];
                if(kValue)~=(nil)then
                     if(callback)(thisArg,kValue,i,t)then
                         res[index]=kValue;
                        index+=1
                     end
                 end
             end
         end;
        return res
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\find.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.find",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(array,predicate)
        for i=1,#(array)do
             local element=array[i];
            if predicate(element,i,array)then
                 return element
             end
         end;
        return nil
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\findIndex.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.findIndex",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(array,predicate)
        for i=1,#(array)do
             local element=array[i];
            if predicate(element,i,array)then
                 return i
             end
         end;
        return-(1)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\flat.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.flat",function()
    local __DEV__=_G.__DEV__;
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    local function flat(array,depth_)
        if __DEV__ then
             if(typeof(array))~=("table")then
                 error(string.format("Array.flat called on %s",typeof(array)))
            end;
            if((depth_)~=(nil))and((typeof(depth_))~=("number"))then
                 error("depth is not a number or nil")
            end
         end;
        local depth=(depth_)or(1);
        local newArray={};
        for _,v in array do
             if isArray(v)then
                 local vArray=(v);
                local innerArrFlat=if(depth)>(1)then flat(vArray,(depth)-(1))else vArray;
                for _,innerValue in innerArrFlat do
                     table.insert(newArray,innerValue)
                end
             else
                 table.insert(newArray,v)
            end
         end;
        return newArray
     end;
    return flat

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\flatMap.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.flatMap",function()
    local __DEV__=_G.__DEV__;
    local flat=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.flat");
    local map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.map");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local function flatMap(array,callback,thisArg)
        if __DEV__ then
             if(typeof(array))~=("table")then
                 error(string.format("Array.flatMap called on %s",typeof(array)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        return flat(map(array,callback,thisArg))
    end;
    return flatMap

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\forEach.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.forEach",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(t,callback,thisArg)
        if __DEV__ then
             if(typeof(t))~=("table")then
                 error(string.format("Array.forEach called on %s",typeof(t)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        local len=#(t);
        local k=1;
        while(k)<=(len)do
             local kValue=t[k];
            if(thisArg)~=(nil)then
                (callback)(thisArg,kValue,k,t)
            else
                (callback)(kValue,k,t)
            end;
            if(#(t))<(len)then
                 len=#(t)
            end;
            k+=1
         end
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\from\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from",function()
    local Set=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Set");
    local Map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.Map");
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local instanceof=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    local fromString=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromString");
    local fromSet=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromSet");
    local fromMap=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromMap");
    local fromArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromArray");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value,mapFn,thisArg)
        if(value)==(nil)then
             error("cannot create array from a nil value")
        end;
        local valueType=typeof(value);
        local array;
        if((valueType)==("table"))and(isArray(value))then
             array=fromArray(value,mapFn,thisArg)
        elseif instanceof(value,Set)then
             array=fromSet(value,mapFn,thisArg)
        elseif instanceof(value,Map)then
             array=fromMap(value,mapFn,thisArg)
        elseif(valueType)==("string")then
             array=fromString(value,mapFn,thisArg)
        else
             array={}
        end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\includes.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.includes",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    local indexOf=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.indexOf");
    return function(array,searchElement,fromIndex)
        return(indexOf(array,searchElement,fromIndex))~=(-(1))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\indexOf.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.indexOf",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(array,searchElement,fromIndex)
        local fromIndex_=(fromIndex)or(1);
        local length=#(array);
        if(fromIndex_)<(1)then
             fromIndex_=math.max((length)-(math.abs(fromIndex_)),1)
        end;
        for i=fromIndex_,length do
             if(array[i])==(searchElement)then
                 return i
             end
         end;
        return-(1)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\isArray.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray",function()
    return function(value)
        if(typeof(value))~=("table")then
             return false
         end;
        if(next(value))==(nil)then
             return true
         end;
        local length=#(value);
        if(length)==(0)then
             return false
         end;
        local count=0;
        local sum=0;
        for key in pairs(value)do
             if(typeof(key))~=("number")then
                 return false
             end;
            if(((key)%(1))~=(0))or((key)<(1))then
                 return false
             end;
            count+=1;
            sum+=key
         end;
        return(sum)==((((count)*(((count)+(1))))/(2)))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\join.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.join",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    local map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.map");
    return function(arr,separator)
        if(#(arr))==(0)then
             return""
        end;
        local stringifiedArray=map(arr,function(item)
            return tostring(item)
        end);
        return table.concat(stringifiedArray,(separator)or(","))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\map.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.map",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(t,callback,thisArg)
        if __DEV__ then
             if(typeof(t))~=("table")then
                 error(string.format("Array.map called on %s",typeof(t)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        local len=#(t);
        local A={};
        local k=1;
        while(k)<=(len)do
             local kValue=t[k];
            if(kValue)~=(nil)then
                 local mappedValue;
                if(thisArg)~=(nil)then
                     mappedValue=(callback)(thisArg,kValue,k,t)
                else
                     mappedValue=(callback)(kValue,k,t)
                end;
                A[k]=mappedValue
             end;
            k+=1
         end;
        return A
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\reduce.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.reduce",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(array,callback,initialValue)
        if __DEV__ then
             if(typeof(array))~=("table")then
                 error(string.format("Array.reduce called on %s",typeof(array)))
            end;
            if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        local length=#(array);
        local value;
        local initial=1;
        if(initialValue)~=(nil)then
             value=initialValue
         else
             initial=2;
            if(length)==(0)then
                 error("reduce of empty array with no initial value")
            end;
            value=array[1]
        end;
        for i=initial,length do
             value=callback(value,array[i],i,array)
        end;
        return value
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\reverse.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.reverse",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(t)
        local n=#(t);
        local i=1;
        while(i)<(n)do
             t[i],t[n]=t[n],t[i];
            i=(i)+(1);
            n=(n)-(1)
        end;
        return t
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\shift.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.shift",function()
    local __DEV__=_G.__DEV__;
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(value)
        if __DEV__ then
             if not(isArray(value))then
                 error(string.format("Array.shift called on non-array %s",typeof(value)))
            end
         end;
        if(#(value))>(0)then
             return table.remove(value,1)
        else
             return nil
         end
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\slice.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.slice",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(t,start_idx,end_idx)
        if(typeof(t))~=("table")then
             error(string.format("Array.slice called on %s",typeof(t)))
        end;
        local length=#(t);
        local start_idx_=(start_idx)or(1);
        local end_idx_;
        if((end_idx)==(nil))or((end_idx)>((length)+(1)))then
             end_idx_=(length)+(1)
        else
             end_idx_=end_idx
         end;
        if(start_idx_)>((length)+(1))then
             return{}
        end;
        local slice={};
        if(start_idx_)<(1)then
             start_idx_=math.max((length)-(math.abs(start_idx_)),1)
        end;
        if(end_idx_)<(1)then
             end_idx_=math.max((length)-(math.abs(end_idx_)),1)
        end;
        local idx=start_idx_;
        local i=1;
        while(idx)<(end_idx_)do
             slice[i]=t[idx];
            idx=(idx)+(1);
            i=(i)+(1)
        end;
        return slice
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\some.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.some",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(t,callback,thisArg)
        if(typeof(t))~=("table")then
             error(string.format("Array.some called on %s",typeof(t)))
        end;
        if(typeof(callback))~=("function")then
             error("callback is not a function")
        end;
        for i,value in t do
             if(thisArg)~=(nil)then
                 if((value)~=(nil))and((callback)(thisArg,value,i,t))then
                     return true
                 end
             else
                 if((value)~=(nil))and((callback)(value,i,t))then
                     return true
                 end
             end
         end;
        return false
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\sort.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.sort",function()
    local None=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.None");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    local defaultSort=function(a,b)
        return((type(a))..(tostring(a)))<((type(b))..(tostring(b)))
    end;
    return function(array,compare)
        local wrappedCompare=defaultSort;
        if((compare)~=(nil))and((compare)~=(None))then
             if(typeof(compare))~=("function")then
                 error("invalid argument to Array.sort: compareFunction must be a function")
            end;
            wrappedCompare=function(a,b)
                local result=compare(a,b);
                if(typeof(result))~=("number")then
                     error(("invalid result from compare function, expected number but got %s"):format(typeof(result)))
                end;
                return(result)<(0)
            end
         end;
        table.sort(array,wrappedCompare);
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\splice.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.splice",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(array,start,deleteCount,...)
        if(start)>(#(array))then
             local varargCount=select("\x23",...);
            for i=1,varargCount do
                 local toInsert=select(i,...);
                table.insert(array,toInsert)
            end;
            return{}
        else
             local length=#(array);
            if(start)<(1)then
                 start=math.max((length)-(math.abs(start)),1)
            end;
            local deletedItems={};
            local deleteCount_=(deleteCount)or(length);
            if(deleteCount_)>(0)then
                 local lastIndex=math.min(length,(start)+(math.max(0,(deleteCount_)-(1))));
                for i=start,lastIndex do
                     local deleted=table.remove(array,start);
                    table.insert(deletedItems,deleted)
                end
             end;
            local varargCount=select("\x23",...);
            for i=varargCount,1,-(1)do
                 local toInsert=select(i,...);
                table.insert(array,start,toInsert)
            end;
            return deletedItems
         end
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\unshift.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.unshift",function()
    local __DEV__=_G.__DEV__;
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(array,...)
        if __DEV__ then
             if not(isArray(array))then
                 error(string.format("Array.unshift called on non-array %s",typeof(array)))
            end
         end;
        local numberOfItems=select("\x23",...);
        if(numberOfItems)>(0)then
             for i=numberOfItems,1,-(1)do
                 local toInsert=select(i,...);
                table.insert(array,1,toInsert)
            end
         end;
        return#(array)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Map\Map.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.Map",function()
    local __DEV__=_G.__DEV__;
    local arrayForEach=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.forEach");
    local arrayMap=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.map");
    local isArray=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.isArray");
    local instanceof=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Map=({});
    function Map.new(iterable)
        local array;
        local map;
        if(iterable)==(nil)then
             array={};
            map={}
        elseif isArray(iterable)then
             if __DEV__ then
                 if((#((iterable)))>(0))and((typeof((iterable)[1]))~=("table"))then
                     error(("Value `")..((typeof((iterable)[1]))..("` is not an entry object.\x0a Cannot create Map from {K, V} form, it must be { {K, V}... }")))
                end
             end;
            array=table.create(#((iterable)));
            map={};
            for _,entry in iterable do
                 local key=entry[1];
                if __DEV__ then
                     if(key)==(nil)then
                         error("cannot create Map from a table that isn't an array.")
                    end
                 end;
                local val=entry[2];
                if(map[key])==(nil)then
                     table.insert(array,key)
                end;
                map[key]=val
             end
         elseif instanceof(iterable,Map)then
             array=table.clone((iterable)._array);
            map=table.clone((iterable)._map)
        else
             error(("`%s` `%s` is not iterable, cannot make Map using it"):format(typeof(iterable),tostring(iterable)))
        end;
        return(setmetatable({["size"]=#(array),["_map"]=map,["_array"]=array},Map))
    end;
    function Map:set(key,value)
        if(self._map[key])==(nil)then
             self.size=(self.size)+(1);
            table.insert(self._array,key)
        end;
        self._map[key]=value;
        return self
     end;
    function Map:get(key)
        return self._map[key]
    end;
    function Map:clear()
        local table_=table;
        self.size=0;
        table_.clear(self._map);
        table_.clear(self._array)
    end;
    function Map:delete(key)
        if(self._map[key])==(nil)then
             return false
         end;
        self.size=(self.size)-(1);
        self._map[key]=nil;
        local index=table.find(self._array,key);
        if index then
             table.remove(self._array,index)
        end;
        return true
     end;
    function Map:forEach(callback,thisArg)
        if __DEV__ then
             if(typeof(callback))~=("function")then
                 error("callback is not a function")
            end
         end;
        arrayForEach(self._array,function(key)
            local value=self._map[key];
            if(thisArg)~=(nil)then
                (callback)(thisArg,value,key,self)
            else
                (callback)(value,key,self)
            end
         end)
    end;
    function Map:has(key)
        return(self._map[key])~=(nil)
    end;
    function Map:keys()
        return self._array
     end;
    function Map:values()
        return arrayMap(self._array,function(key)
            return self._map[key]
        end)
    end;
    function Map:entries()
        return arrayMap(self._array,function(key)
            return{key,self._map[key]}
        end)
    end;
    function Map:ipairs()
        if __DEV__ then
             warn(debug.traceback("`for _,_ in myMap:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in myMap do` instead\x0a",2))
        end;
        return ipairs(self:entries())
    end;
    function Map.__iter(self)
        return next,self:entries()
    end;
    function Map.__index(self,key)
        local mapProp=rawget(Map,key);
        if(mapProp)~=(nil)then
             return mapProp
         end;
        if __DEV__ then
             assert(rawget(self,"_map"),"Map has been corrupted, and is missing private state! Did you accidentally call table.clear() instead of map:clear()?")
        end;
        return Map.get(self,key)
    end;
    function Map.__newindex(self,key,value)
        self:set(key,value)
    end;
    return Map

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Map\coerceToMap.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.coerceToMap",function()
    local Map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.Map");
    local Object=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object");
    local instanceOf=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    local function coerceToMap(mapLike)
        return((instanceOf(mapLike,Map))and(mapLike))or(Map.new(Object.entries(mapLike)))
    end;
    return coerceToMap

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Map\coerceToTable.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.coerceToTable",function()
    local Map=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Map.Map");
    local instanceOf=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of");
    local arrayReduce=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.reduce");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    local function coerceToTable(mapLike)
        if not(instanceOf(mapLike,Map))then
             return mapLike
         end;
        return arrayReduce(mapLike:entries(),function(tbl,entry)
            tbl[entry[1]]=entry[2];
            return tbl
         end,{})
    end;
    return coerceToTable

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\assign.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.assign",function()
    local None=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.None");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(target,source0,source1,source2,...)
        if((source0)~=(nil))and((typeof(source0))==("table"))then
             for key,value in pairs(source0)do
                 if(value)==(None)then
                    (target)[key]=nil
                 else
                    (target)[key]=value
                 end
             end
         end;
        if((source1)~=(nil))and((typeof(source1))==("table"))then
             for key,value in pairs(source1)do
                 if(value)==(None)then
                    (target)[key]=nil
                 else
                    (target)[key]=value
                 end
             end
         end;
        if((source2)~=(nil))and((typeof(source2))==("table"))then
             for key,value in pairs(source2)do
                 if(value)==(None)then
                    (target)[key]=nil
                 else
                    (target)[key]=value
                 end
             end
         end;
        for index=1,select("\x23",...)do
             local rest=select(index,...);
            if((rest)~=(nil))and((typeof(rest))==("table"))then
                 for key,value in pairs(rest)do
                     if(value)==(None)then
                        (target)[key]=nil
                     else
                        (target)[key]=value
                     end
                 end
             end
         end;
        return(target)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\entries.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.entries",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value)
        assert((value)~=(nil),"cannot get entries from a nil value");
        local valueType=typeof(value);
        local entries={};
        if(valueType)==("table")then
             for key,keyValue in pairs(value)do
                 table.insert(entries,{key,keyValue})
            end
         elseif(valueType)==("string")then
             for i=1,string.len(value)do
                 entries[i]={tostring(i),string.sub(value,i,i)}
            end
         end;
        return entries
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\freeze.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.freeze",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(t)
        return(table.freeze(t))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\is.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.is",function()
    return function(value1,value2)
        if(value1)==(value2)then
             return((value1)~=(0))or(((1)/(value1))==((1)/(value2)))
        else
             return((value1)~=(value1))and((value2)~=(value2))
        end
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\isFrozen.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.isFrozen",function()
    local __DEV__=_G.__DEV__;
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(t)
        if __DEV__ then
             print("Luau now has a direct table.isfrozen call that can save the overhead of this library function call")
        end;
        return table.isfrozen(t)
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\keys.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.keys",function()
    local Set=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Set");
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    local instanceOf=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value)
        if(value)==(nil)then
             error("cannot extract keys from a nil value")
        end;
        local valueType=typeof(value);
        local keys;
        if(valueType)==("table")then
             keys={};
            if instanceOf(value,Set)then
                 return keys
             end;
            for key in pairs(value)do
                 table.insert(keys,key)
            end
         elseif(valueType)==("string")then
             local length=(value):len();
            keys=table.create(length);
            for i=1,length do
                 keys[i]=tostring(i)
            end
         end;
        return keys
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\preventExtensions.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.preventExtensions",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    local function preventExtensions(t)
        local name=tostring(t);
        return(setmetatable(t,{["__newindex"]=function(self,key,value)
            local message=("%q (%s) is not a valid member of %s"):format(tostring(key),typeof(key),name);
            error(message,2)
        end,["__metatable"]=false}))
    end;
    return preventExtensions

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\seal.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.seal",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    return function(t)
        return(table.freeze(t))
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\values.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.values",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    return function(value)
        if(value)==(nil)then
             error("cannot extract values from a nil value")
        end;
        local valueType=typeof(value);
        local array;
        if(valueType)==("table")then
             array={};
            for _,keyValue in pairs(value)do
                 table.insert(array,keyValue)
            end
         elseif(valueType)==("string")then
             local valueStringLength=(value):len();
            array=table.create(valueStringLength);
            for i=1,valueStringLength do
                (array)[i]=(value):sub(i,i)
            end
         end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Object\None.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Object.None",function()
    local None=newproxy(true);
    local mt=getmetatable(None);
    mt.__tostring=function()
        return"Object.None"
    end;
    return None

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\from\fromString.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromString",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value,mapFn,thisArg)
        local array={};
        local valueStringLength=#(value);
        array=table.create(valueStringLength);
        if mapFn then
             for i=1,valueStringLength do
                 if(thisArg)~=(nil)then
                    (array)[i]=(mapFn)(thisArg,string.sub(value,i,i),i)
                else
                    (array)[i]=(mapFn)(string.sub(value,i,i),i)
                end
             end
         else
             for i=1,valueStringLength do
                (array)[i]=string.sub(value,i,i)
            end
         end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_console@1.2.7\collections.lua
 tkpack.declare("game.Packages._Index.jsdotlua_console@1.2.7.collections",function()
    return tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.collections")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\number.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.number",function()
    return tkpack.include("game.Packages._Index.jsdotlua_number@1.2.7.number")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_string@1.2.7\es7-types.lua
 tkpack.declare("game.Packages._Index.jsdotlua_string@1.2.7.es7-types",function()
    return tkpack.include("game.Packages._Index.jsdotlua_es7-types@1.2.7.es7-types")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\init.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler",function()
    local initializeScheduler=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Scheduler");
    local function onlyInTestError(functionName)
        return function()
            error((functionName)..(" is only available in tests, not in production"))
        end
     end;
    local Scheduler=initializeScheduler(nil);
    local Tracing=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Tracing");
    local TracingSubscriptions=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.TracingSubscriptions");
    type("not printable... yet");
    if _G.__ROACT_17_MOCK_SCHEDULER__ then
         return tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.unstable_mock")
    end;
    local exports={["unstable_ImmediatePriority"]=Scheduler.unstable_ImmediatePriority,["unstable_UserBlockingPriority"]=Scheduler.unstable_UserBlockingPriority,["unstable_NormalPriority"]=Scheduler.unstable_NormalPriority,["unstable_IdlePriority"]=Scheduler.unstable_IdlePriority,["unstable_LowPriority"]=Scheduler.unstable_LowPriority,["unstable_runWithPriority"]=Scheduler.unstable_runWithPriority,["unstable_next"]=Scheduler.unstable_next,["unstable_scheduleCallback"]=Scheduler.unstable_scheduleCallback,["unstable_cancelCallback"]=Scheduler.unstable_cancelCallback,["unstable_wrapCallback"]=Scheduler.unstable_wrapCallback,["unstable_getCurrentPriorityLevel"]=Scheduler.unstable_getCurrentPriorityLevel,["unstable_shouldYield"]=Scheduler.unstable_shouldYield,["unstable_requestPaint"]=Scheduler.unstable_requestPaint,["unstable_continueExecution"]=Scheduler.unstable_continueExecution,["unstable_pauseExecution"]=Scheduler.unstable_pauseExecution,["unstable_getFirstCallbackNode"]=Scheduler.unstable_getFirstCallbackNode,["unstable_now"]=Scheduler.unstable_now,["unstable_forceFrameRate"]=Scheduler.unstable_forceFrameRate,["unstable_flushAllWithoutAsserting"]=onlyInTestError("unstable_flushAllWithoutAsserting"),["unstable_flushAll"]=onlyInTestError("unstable_flushAll"),["unstable_flushNumberOfYields"]=onlyInTestError("unstable_flushNumberOfYields"),["unstable_clearYields"]=onlyInTestError("unstable_clearYields"),["unstable_flushUntilNextPaint"]=onlyInTestError("unstable_clearYields"),["unstable_advanceTime"]=onlyInTestError("unstable_advanceTime"),["unstable_flushExpired"]=onlyInTestError("unstable_flushExpired"),["unstable_yieldValue"]=onlyInTestError("unstable_yieldValue"),["tracing"]={["unstable_wrap"]=onlyInTestError("unstable_wrap"),["__interactionsRef"]={},["__subscriberRef"]={}}};
    for k,v in Tracing do
         exports.tracing[k]=v
     end;
    for k,v in TracingSubscriptions do
         exports.tracing[k]=v
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberLane.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactFiberSchedulerPriorities=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSchedulerPriorities.roblox");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local ImmediateSchedulerPriority=ReactFiberSchedulerPriorities.ImmediatePriority;
    local UserBlockingSchedulerPriority=ReactFiberSchedulerPriorities.UserBlockingPriority;
    local NormalSchedulerPriority=ReactFiberSchedulerPriorities.NormalPriority;
    local LowSchedulerPriority=ReactFiberSchedulerPriorities.LowPriority;
    local IdleSchedulerPriority=ReactFiberSchedulerPriorities.IdlePriority;
    local NoSchedulerPriority=ReactFiberSchedulerPriorities.NoPriority;
    local exports={};
    local SyncLanePriority=15;
    exports.SyncLanePriority=SyncLanePriority;
    local SyncBatchedLanePriority=14;
    exports.SyncBatchedLanePriority=SyncBatchedLanePriority;
    local InputDiscreteHydrationLanePriority=13;
    local InputDiscreteLanePriority=12;
    exports.InputDiscreteLanePriority=InputDiscreteLanePriority;
    local InputContinuousHydrationLanePriority=11;
    local InputContinuousLanePriority=10;
    exports.InputContinuousLanePriority=InputContinuousLanePriority;
    local DefaultHydrationLanePriority=9;
    local DefaultLanePriority=8;
    exports.DefaultLanePriority=DefaultLanePriority;
    local TransitionHydrationPriority=7;
    local TransitionPriority=6;
    exports.TransitionPriority=TransitionPriority;
    local RetryLanePriority=5;
    local SelectiveHydrationLanePriority=4;
    local IdleHydrationLanePriority=3;
    local IdleLanePriority=2;
    local OffscreenLanePriority=1;
    local NoLanePriority=0;
    exports.NoLanePriority=NoLanePriority;
    local NoLanes=0;
    exports.NoLanes=NoLanes;
    local NoLane=0;
    exports.NoLane=NoLane;
    local SyncLane=1;
    exports.SyncLane=SyncLane;
    local SyncBatchedLane=2;
    exports.SyncBatchedLane=SyncBatchedLane;
    local InputDiscreteHydrationLane=4;
    exports.InputDiscreteHydrationLane=InputDiscreteHydrationLane;
    local InputDiscreteLanes=24;
    local InputContinuousHydrationLane=32;
    local InputContinuousLanes=192;
    local DefaultHydrationLane=256;
    exports.DefaultHydrationLane=DefaultHydrationLane;
    local DefaultLanes=3584;
    exports.DefaultLanes=DefaultLanes;
    local TransitionHydrationLane=4096;
    local TransitionLanes=4186112;
    local RetryLanes=62914560;
    exports.RetryLanes=RetryLanes;
    local SomeRetryLane=33554432;
    exports.SomeRetryLane=SomeRetryLane;
    local SelectiveHydrationLane=67108864;
    exports.SelectiveHydrationLane=SelectiveHydrationLane;
    local NonIdleLanes=134217727;
    local IdleHydrationLane=134217728;
    exports.IdleHydrationLane=IdleHydrationLane;
    local IdleLanes=805306368;
    local OffscreenLane=1073741824;
    exports.OffscreenLane=OffscreenLane;
    local NoTimestamp=-(1);
    exports.NoTimestamp=NoTimestamp;
    local currentUpdateLanePriority=exports.NoLanePriority;
    exports.getCurrentUpdateLanePriority=function()
        return currentUpdateLanePriority
     end;
    exports.setCurrentUpdateLanePriority=function(newLanePriority)
        currentUpdateLanePriority=newLanePriority
     end;
    local return_highestLanePriority=exports.DefaultLanePriority;
    local function getHighestPriorityLanes(lanes)
        if(bit32.band(SyncLane,lanes))~=(NoLanes)then
             return_highestLanePriority=SyncLanePriority;
            return SyncLane
         end;
        if(bit32.band(SyncBatchedLane,lanes))~=(NoLanes)then
             return_highestLanePriority=SyncBatchedLanePriority;
            return SyncBatchedLane
         end;
        if(bit32.band(InputDiscreteHydrationLane,lanes))~=(NoLanes)then
             return_highestLanePriority=InputDiscreteHydrationLanePriority;
            return InputDiscreteHydrationLane
         end;
        local inputDiscreteLanes=bit32.band(InputDiscreteLanes,lanes);
        if(inputDiscreteLanes)~=(NoLanes)then
             return_highestLanePriority=InputDiscreteLanePriority;
            return inputDiscreteLanes
         end;
        if(bit32.band(lanes,InputContinuousHydrationLane))~=(NoLanes)then
             return_highestLanePriority=InputContinuousHydrationLanePriority;
            return InputContinuousHydrationLane
         end;
        local inputContinuousLanes=bit32.band(InputContinuousLanes,lanes);
        if(inputContinuousLanes)~=(NoLanes)then
             return_highestLanePriority=InputContinuousLanePriority;
            return inputContinuousLanes
         end;
        if(bit32.band(lanes,DefaultHydrationLane))~=(NoLanes)then
             return_highestLanePriority=DefaultHydrationLanePriority;
            return DefaultHydrationLane
         end;
        local defaultLanes=bit32.band(DefaultLanes,lanes);
        if(defaultLanes)~=(NoLanes)then
             return_highestLanePriority=DefaultLanePriority;
            return defaultLanes
         end;
        if(bit32.band(lanes,TransitionHydrationLane))~=(NoLanes)then
             return_highestLanePriority=TransitionHydrationPriority;
            return TransitionHydrationLane
         end;
        local transitionLanes=bit32.band(TransitionLanes,lanes);
        if(transitionLanes)~=(NoLanes)then
             return_highestLanePriority=TransitionPriority;
            return transitionLanes
         end;
        local retryLanes=bit32.band(RetryLanes,lanes);
        if(retryLanes)~=(NoLanes)then
             return_highestLanePriority=RetryLanePriority;
            return retryLanes
         end;
        if(bit32.band(lanes,SelectiveHydrationLane))~=(0)then
             return_highestLanePriority=SelectiveHydrationLanePriority;
            return SelectiveHydrationLane
         end;
        if(bit32.band(lanes,IdleHydrationLane))~=(NoLanes)then
             return_highestLanePriority=IdleHydrationLanePriority;
            return IdleHydrationLane
         end;
        local idleLanes=bit32.band(IdleLanes,lanes);
        if(idleLanes)~=(NoLanes)then
             return_highestLanePriority=IdleLanePriority;
            return idleLanes
         end;
        if(bit32.band(OffscreenLane,lanes))~=(NoLanes)then
             return_highestLanePriority=OffscreenLanePriority;
            return OffscreenLane
         end;
        if _G.__DEV__ then
             console.error("Should have found matching lanes. This is a bug in React.")
        end;
        return_highestLanePriority=DefaultLanePriority;
        return lanes
     end;
    local function schedulerPriorityToLanePriority(schedulerPriorityLevel)
        if(schedulerPriorityLevel)==(ImmediateSchedulerPriority)then
             return SyncLanePriority
         elseif(schedulerPriorityLevel)==(UserBlockingSchedulerPriority)then
             return InputContinuousLanePriority
         elseif((schedulerPriorityLevel)==(NormalSchedulerPriority))or((schedulerPriorityLevel)==(LowSchedulerPriority))then
             return DefaultLanePriority
         elseif(schedulerPriorityLevel)==(IdleSchedulerPriority)then
             return IdleLanePriority
         else
             return NoLanePriority
         end
     end;
    exports.schedulerPriorityToLanePriority=schedulerPriorityToLanePriority;
    local function lanePriorityToSchedulerPriority(lanePriority)
        if((lanePriority)==(SyncLanePriority))or((lanePriority)==(SyncBatchedLanePriority))then
             return ImmediateSchedulerPriority
         elseif((((lanePriority)==(InputDiscreteHydrationLanePriority))or((lanePriority)==(InputDiscreteLanePriority)))or((lanePriority)==(InputContinuousHydrationLanePriority)))or((lanePriority)==(InputContinuousLanePriority))then
             return UserBlockingSchedulerPriority
         elseif((((((lanePriority)==(DefaultHydrationLanePriority))or((lanePriority)==(DefaultLanePriority)))or((lanePriority)==(TransitionHydrationPriority)))or((lanePriority)==(TransitionPriority)))or((lanePriority)==(SelectiveHydrationLanePriority)))or((lanePriority)==(RetryLanePriority))then
             return NormalSchedulerPriority
         elseif(((lanePriority)==(IdleHydrationLanePriority))or((lanePriority)==(IdleLanePriority)))or((lanePriority)==(OffscreenLanePriority))then
             return IdleSchedulerPriority
         elseif(lanePriority)==(NoLanePriority)then
             return NoSchedulerPriority
         else
             invariant(false,"Invalid update priority: %s. This is a bug in React.",lanePriority);
            error("unreachable")
        end
     end;
    exports.lanePriorityToSchedulerPriority=lanePriorityToSchedulerPriority;
    local pickArbitraryLaneIndex,getLowestPriorityLane,getEqualOrHigherPriorityLanes;
    local function getNextLanes(root,wipLanes)
        local pendingLanes=root.pendingLanes;
        if(pendingLanes)==(NoLanes)then
             return_highestLanePriority=NoLanePriority;
            return NoLanes
         end;
        local nextLanes=NoLanes;
        local nextLanePriority=NoLanePriority;
        local expiredLanes=root.expiredLanes;
        local suspendedLanes=root.suspendedLanes;
        local pingedLanes=root.pingedLanes;
        if(expiredLanes)~=(NoLanes)then
             nextLanes=expiredLanes;
            return_highestLanePriority=SyncLanePriority;
            nextLanePriority=SyncLanePriority
         else
             local nonIdlePendingLanes=bit32.band(pendingLanes,NonIdleLanes);
            if(nonIdlePendingLanes)~=(NoLanes)then
                 local nonIdleUnblockedLanes=bit32.band(nonIdlePendingLanes,bit32.bnot(suspendedLanes));
                if(nonIdleUnblockedLanes)~=(NoLanes)then
                     nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);
                    nextLanePriority=return_highestLanePriority
                 else
                     local nonIdlePingedLanes=bit32.band(nonIdlePendingLanes,pingedLanes);
                    if(nonIdlePingedLanes)~=(NoLanes)then
                         nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);
                        nextLanePriority=return_highestLanePriority
                     end
                 end
             else
                 local unblockedLanes=bit32.band(pendingLanes,bit32.bnot(suspendedLanes));
                if(unblockedLanes)~=(NoLanes)then
                     nextLanes=getHighestPriorityLanes(unblockedLanes);
                    nextLanePriority=return_highestLanePriority
                 else
                     if(pingedLanes)~=(NoLanes)then
                         nextLanes=getHighestPriorityLanes(pingedLanes);
                        nextLanePriority=return_highestLanePriority
                     end
                 end
             end
         end;
        if(nextLanes)==(NoLanes)then
             return NoLanes
         end;
        nextLanes=bit32.band(pendingLanes,(bit32.lshift(getLowestPriorityLane(nextLanes),1))-(1));
        if(((wipLanes)~=(NoLanes))and((wipLanes)~=(nextLanes)))and((bit32.band(wipLanes,suspendedLanes))==(NoLanes))then
             getHighestPriorityLanes(wipLanes);
            local wipLanePriority=return_highestLanePriority;
            if(nextLanePriority)<=(wipLanePriority)then
                 return wipLanes
             else
                 return_highestLanePriority=nextLanePriority
             end
         end;
        local entangledLanes=root.entangledLanes;
        if(entangledLanes)~=(NoLanes)then
             local entanglements=root.entanglements;
            local lanes=bit32.band(nextLanes,entangledLanes);
            while(lanes)>(0)do
                 local index=pickArbitraryLaneIndex(lanes);
                local lane=bit32.lshift(1,index);
                nextLanes=bit32.bor(nextLanes,entanglements[index]);
                lanes=bit32.band(lanes,bit32.bnot(lane))
            end
         end;
        return nextLanes
     end;
    exports.getNextLanes=getNextLanes;
    local function getMostRecentEventTime(root,lanes)
        local eventTimes=root.eventTimes;
        local mostRecentEventTime=NoTimestamp;
        while(lanes)>(0)do
             local index=pickArbitraryLaneIndex(lanes);
            local lane=bit32.lshift(1,index);
            local eventTime=eventTimes[index];
            if(eventTime)>(mostRecentEventTime)then
                 mostRecentEventTime=eventTime
             end;
            lanes=bit32.band(lanes,bit32.bnot(lane))
        end;
        return mostRecentEventTime
     end;
    exports.getMostRecentEventTime=getMostRecentEventTime;
    local function computeExpirationTime(lane,currentTime)
        getHighestPriorityLanes(lane);
        local priority=return_highestLanePriority;
        if(priority)>=(InputContinuousLanePriority)then
             return(currentTime)+(250)
        elseif(priority)>=(TransitionPriority)then
             return(currentTime)+(5000)
        else
             return NoTimestamp
         end
     end;
    exports.computeExpirationTime=computeExpirationTime;
    local function markStarvedLanesAsExpired(root,currentTime)
        local pendingLanes=root.pendingLanes;
        local suspendedLanes=root.suspendedLanes;
        local pingedLanes=root.pingedLanes;
        local expirationTimes=root.expirationTimes;
        local lanes=pendingLanes;
        while(lanes)>(0)do
             local index=pickArbitraryLaneIndex(lanes);
            local lane=bit32.lshift(1,index);
            local expirationTime=expirationTimes[index];
            if(expirationTime)==(NoTimestamp)then
                 if((bit32.band(lane,suspendedLanes))==(NoLanes))or((bit32.band(lane,pingedLanes))~=(NoLanes))then
                     expirationTimes[index]=computeExpirationTime(lane,currentTime)
                end
             elseif(expirationTime)<=(currentTime)then
                 root.expiredLanes=bit32.bor(root.expiredLanes,lane)
            end;
            lanes=bit32.band(lanes,bit32.bnot(lane))
        end
     end;
    exports.markStarvedLanesAsExpired=markStarvedLanesAsExpired;
    local function getHighestPriorityPendingLanes(root)
        return getHighestPriorityLanes(root.pendingLanes)
    end;
    exports.getHighestPriorityPendingLanes=getHighestPriorityPendingLanes;
    local function getLanesToRetrySynchronouslyOnError(root)
        local everythingButOffscreen=bit32.band(root.pendingLanes,bit32.bnot(OffscreenLane));
        if(everythingButOffscreen)~=(NoLanes)then
             return everythingButOffscreen
         end;
        if(bit32.band(everythingButOffscreen,OffscreenLane))~=(0)then
             return OffscreenLane
         end;
        return NoLanes
     end;
    exports.getLanesToRetrySynchronouslyOnError=getLanesToRetrySynchronouslyOnError;
    local function returnNextLanesPriority()
        return return_highestLanePriority
     end;
    exports.returnNextLanesPriority=returnNextLanesPriority;
    local function includesNonIdleWork(lanes)
        return(bit32.band(lanes,NonIdleLanes))~=(NoLanes)
    end;
    exports.includesNonIdleWork=includesNonIdleWork;
    local function includesOnlyRetries(lanes)
        return(bit32.band(lanes,RetryLanes))==(lanes)
    end;
    exports.includesOnlyRetries=includesOnlyRetries;
    local function includesOnlyTransitions(lanes)
        return(bit32.band(lanes,TransitionLanes))==(lanes)
    end;
    exports.includesOnlyTransitions=includesOnlyTransitions;
    local pickArbitraryLane;
    local function findUpdateLane(lanePriority,wipLanes)
        if(lanePriority)==(NoLanePriority)then
            
         elseif(lanePriority)==(SyncLanePriority)then
             return SyncLane
         elseif(lanePriority)==(SyncBatchedLanePriority)then
             return SyncBatchedLane
         elseif(lanePriority)==(InputDiscreteLanePriority)then
             local lane=pickArbitraryLane(bit32.band(InputDiscreteLanes,bit32.bnot(wipLanes)));
            if(lane)==(NoLane)then
                 return findUpdateLane(InputContinuousLanePriority,wipLanes)
            end;
            return lane
         elseif(lanePriority)==(InputContinuousLanePriority)then
             local lane=pickArbitraryLane(bit32.band(InputContinuousLanes,bit32.bnot(wipLanes)));
            if(lane)==(NoLane)then
                 return findUpdateLane(DefaultLanePriority,wipLanes)
            end;
            return lane
         elseif(lanePriority)==(DefaultLanePriority)then
             local lane=pickArbitraryLane(bit32.band(DefaultLanes,bit32.bnot(wipLanes)));
            if(lane)==(NoLane)then
                 lane=pickArbitraryLane(bit32.band(TransitionLanes,bit32.bnot(wipLanes)));
                if(lane)==(NoLane)then
                     lane=pickArbitraryLane(DefaultLanes)
                end
             end;
            return lane
         elseif((lanePriority)==(TransitionPriority))or((lanePriority)==(RetryLanePriority))then
            
         elseif(lanePriority)==(IdleLanePriority)then
             local lane=pickArbitraryLane(bit32.band(IdleLanes,bit32.bnot(wipLanes)));
            if(lane)==(NoLane)then
                 lane=pickArbitraryLane(IdleLanes)
            end;
            return lane
         end;
        invariant(false,"Invalid update priority: %s. This is a bug in React.",lanePriority);
        error("unreachable")
    end;
    exports.findUpdateLane=findUpdateLane;
    local function findTransitionLane(wipLanes,pendingLanes)
        local lane=pickArbitraryLane(bit32.band(TransitionLanes,bit32.bnot(pendingLanes)));
        if(lane)==(NoLane)then
             lane=pickArbitraryLane(bit32.band(TransitionLanes,bit32.bnot(wipLanes)));
            if(lane)==(NoLane)then
                 lane=pickArbitraryLane(TransitionLanes)
            end
         end;
        return lane
     end;
    exports.findTransitionLane=findTransitionLane;
    local function findRetryLane(wipLanes)
        local lane=pickArbitraryLane(bit32.band(RetryLanes,bit32.bnot(wipLanes)));
        if(lane)==(NoLane)then
             lane=pickArbitraryLane(RetryLanes)
        end;
        return lane
     end;
    exports.findRetryLane=findRetryLane;
    local function getHighestPriorityLane(lanes)
        return bit32.band(lanes,-(lanes))
    end;
    function getLowestPriorityLane(lanes)
        local index=(31)-(bit32.countlz(lanes));
        if(index)<(0)then
             return NoLanes
         else
             return bit32.lshift(1,index)
        end
     end;
    function getEqualOrHigherPriorityLanes(lanes)
        return(bit32.lshift(getLowestPriorityLane(lanes),1))-(1)
    end;
    function pickArbitraryLane(lanes)
        return getHighestPriorityLane(lanes)
    end;
    exports.pickArbitraryLane=pickArbitraryLane;
    function pickArbitraryLaneIndex(lanes)
        return(31)-(bit32.countlz(lanes))
    end;
    local function includesSomeLane(a,b)
        return(bit32.band(a,b))~=(NoLanes)
    end;
    exports.includesSomeLane=includesSomeLane;
    local function isSubsetOfLanes(set,subset)
        return(bit32.band(set,subset))==(subset)
    end;
    exports.isSubsetOfLanes=isSubsetOfLanes;
    local function mergeLanes(a,b)
        return bit32.bor(a,b)
    end;
    exports.mergeLanes=mergeLanes;
    local function removeLanes(set,subset)
        return bit32.band(set,bit32.bnot(subset))
    end;
    exports.removeLanes=removeLanes;
    local function laneToLanes(lane)
        return lane
     end;
    exports.laneToLanes=laneToLanes;
    local function higherPriorityLane(a,b)
        if((a)~=(NoLane))and((b)~=(NoLane))then
             if(a)<(b)then
                 return a
             end;
            return b
         else
             if(a)~=(NoLane)then
                 return a
             end;
            return b
         end
     end;
    exports.higherPriorityLane=higherPriorityLane;
    local function higherLanePriority(a,b)
        if((a)~=(NoLanePriority))and((a)>(b))then
             return a
         else
             return b
         end
     end;
    exports.higherLanePriority=higherLanePriority;
    local function createLaneMap(initial)
        local laneMap={[0]=initial,[1]=initial,[2]=initial,[3]=initial,[4]=initial,[5]=initial,[6]=initial,[7]=initial,[8]=initial,[9]=initial,[10]=initial,[11]=initial,[12]=initial,[13]=initial,[14]=initial,[15]=initial,[16]=initial,[17]=initial,[18]=initial,[19]=initial,[20]=initial,[21]=initial,[22]=initial,[23]=initial,[24]=initial,[25]=initial,[26]=initial,[27]=initial,[28]=initial,[29]=initial,[30]=initial,[31]=initial};
        return laneMap
     end;
    exports.createLaneMap=createLaneMap;
    local function markRootUpdated(root,updateLane,eventTime)
        root.pendingLanes=bit32.bor(root.pendingLanes,updateLane);
        local higherPriorityLanes=(updateLane)-(1);
        root.suspendedLanes=bit32.band(root.suspendedLanes,higherPriorityLanes);
        root.pingedLanes=bit32.band(root.pingedLanes,higherPriorityLanes);
        local eventTimes=root.eventTimes;
        local index=(31)-(bit32.countlz(updateLane));
        eventTimes[index]=eventTime
     end;
    exports.markRootUpdated=markRootUpdated;
    local function markRootSuspended(root,suspendedLanes)
        root.suspendedLanes=bit32.bor(root.suspendedLanes,suspendedLanes);
        root.pingedLanes=bit32.band(root.pingedLanes,bit32.bnot(suspendedLanes));
        local expirationTimes=root.expirationTimes;
        local lanes=suspendedLanes;
        while(lanes)>(0)do
             local index=pickArbitraryLaneIndex(lanes);
            local lane=bit32.lshift(1,index);
            expirationTimes[index]=NoTimestamp;
            lanes=bit32.band(lanes,bit32.bnot(lane))
        end
     end;
    exports.markRootSuspended=markRootSuspended;
    local function markRootPinged(root,pingedLanes,eventTime)
        root.pingedLanes=bit32.bor(root.pingedLanes,bit32.band(root.suspendedLanes,pingedLanes))
    end;
    exports.markRootPinged=markRootPinged;
    local function markRootExpired(root,expiredLanes)
        root.expiredLanes=bit32.bor(root.expiredLanes,bit32.band(expiredLanes,root.pendingLanes))
    end;
    exports.markRootExpired=markRootExpired;
    local function markDiscreteUpdatesExpired(root)
        root.expiredLanes=bit32.bor(root.expiredLanes,bit32.band(InputDiscreteLanes,root.pendingLanes))
    end;
    exports.markDiscreteUpdatesExpired=markDiscreteUpdatesExpired;
    local function hasDiscreteLanes(lanes)
        return(bit32.band(lanes,InputDiscreteLanes))~=(NoLanes)
    end;
    exports.hasDiscreteLanes=hasDiscreteLanes;
    local function markRootMutableRead(root,updateLane)
        root.mutableReadLanes=bit32.bor(root.mutableReadLanes,bit32.band(updateLane,root.pendingLanes))
    end;
    exports.markRootMutableRead=markRootMutableRead;
    local function markRootFinished(root,remainingLanes)
        local noLongerPendingLanes=bit32.band(root.pendingLanes,bit32.bnot(remainingLanes));
        root.pendingLanes=remainingLanes;
        root.suspendedLanes=0;
        root.pingedLanes=0;
        root.expiredLanes=bit32.band(root.expiredLanes,remainingLanes);
        root.mutableReadLanes=bit32.band(root.mutableReadLanes,remainingLanes);
        root.entangledLanes=bit32.band(root.entangledLanes,remainingLanes);
        local entanglements=root.entanglements;
        local eventTimes=root.eventTimes;
        local expirationTimes=root.expirationTimes;
        local lanes=noLongerPendingLanes;
        while(lanes)>(0)do
             local index=pickArbitraryLaneIndex(lanes);
            local lane=bit32.lshift(1,index);
            entanglements[index]=NoLanes;
            eventTimes[index]=NoTimestamp;
            expirationTimes[index]=NoTimestamp;
            lanes=bit32.band(lanes,bit32.bnot(lane))
        end
     end;
    exports.markRootFinished=markRootFinished;
    local function markRootEntangled(root,entangledLanes)
        root.entangledLanes=bit32.bor(root.entangledLanes,entangledLanes);
        local entanglements=root.entanglements;
        local lanes=entangledLanes;
        while(lanes)>(0)do
             local index=pickArbitraryLaneIndex(lanes);
            local lane=bit32.lshift(1,index);
            entanglements[index]=bit32.bor(entanglements[index],entangledLanes);
            lanes=bit32.band(lanes,bit32.bnot(lane))
        end
     end;
    exports.markRootEntangled=markRootEntangled;
    local function getBumpedLaneForHydration(root,renderLanes)
        getHighestPriorityLanes(renderLanes);
        local highestLanePriority=return_highestLanePriority;
        local lane;
        if((highestLanePriority)==(SyncLanePriority))or((highestLanePriority)==(SyncBatchedLanePriority))then
             lane=NoLane
         elseif((highestLanePriority)==(InputDiscreteHydrationLanePriority))or((highestLanePriority)==(InputDiscreteLanePriority))then
             lane=InputDiscreteHydrationLane
         elseif((highestLanePriority)==(InputContinuousHydrationLanePriority))or((highestLanePriority)==(InputContinuousLanePriority))then
             lane=InputContinuousHydrationLane
         elseif((highestLanePriority)==(DefaultHydrationLanePriority))or((highestLanePriority)==(DefaultLanePriority))then
             lane=DefaultHydrationLane
         elseif((highestLanePriority)==(TransitionHydrationPriority))or((highestLanePriority)==(TransitionPriority))then
             lane=TransitionHydrationLane
         elseif(highestLanePriority)==(RetryLanePriority)then
             lane=TransitionHydrationLane
         elseif(highestLanePriority)==(SelectiveHydrationLanePriority)then
             lane=SelectiveHydrationLane
         elseif((highestLanePriority)==(IdleHydrationLanePriority))or((highestLanePriority)==(IdleLanePriority))then
             lane=IdleHydrationLane
         elseif((highestLanePriority)==(OffscreenLanePriority))or((highestLanePriority)==(NoLanePriority))then
             lane=NoLane
         else
             invariant(false,"Invalid lane: %s. This is a bug in React.",tostring(lane))
        end;
        if(bit32.band(lane,bit32.bor(root.suspendedLanes,renderLanes)))~=(NoLane)then
             return NoLane
         end;
        return lane
     end;
    exports.getBumpedLaneForHydration=getBumpedLaneForHydration;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberSuspenseComponent.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local NoFlags=ReactFiberFlags.NoFlags;
    local DidCapture=ReactFiberFlags.DidCapture;
    local isSuspenseInstancePending=ReactFiberHostConfig.isSuspenseInstancePending;
    local isSuspenseInstanceFallback=ReactFiberHostConfig.isSuspenseInstanceFallback;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    exports.shouldCaptureSuspense=function(workInProgress,hasInvisibleParent)
        local nextState=workInProgress.memoizedState;
        if nextState then
             if(nextState.dehydrated)~=(nil)then
                 return true
             end;
            return false
         end;
        local props=workInProgress.memoizedProps;
        if(props.fallback)==(nil)then
             return false
         end;
        if(props.unstable_avoidThisFallback)~=(true)then
             return true
         end;
        if hasInvisibleParent then
             return false
         end;
        return true
     end;
    exports.findFirstSuspended=function(row)
        local node=row;
        while(node)~=(nil)do
             if(node.tag)==(SuspenseComponent)then
                 local state=node.memoizedState;
                if state then
                     local dehydrated=state.dehydrated;
                    if(((dehydrated)==(nil))or(isSuspenseInstancePending(dehydrated)))or(isSuspenseInstanceFallback(dehydrated))then
                         return node
                     end
                 end
             elseif((node.tag)==(SuspenseListComponent))and((node.memoizedProps.revealOrder)~=(nil))then
                 local didSuspend=(bit32.band(node.flags,DidCapture))~=(NoFlags);
                if didSuspend then
                     return node
                 end
             elseif(node.child)~=(nil)then
                 node.child.return_=node;
                node=node.child;
                continue
             end;
            if(node)==(row)then
                 return nil
             end;
            while(node.sibling)==(nil)do
                 if((node.return_)==(nil))or((node.return_)==(row))then
                     return nil
                 end;
                node=node.return_
             end;
            (node.sibling).return_=node.return_;
            node=node.sibling
         end;
        return nil
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberTreeReflection.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTreeReflection",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local getInstance=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactInstanceMap.get;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostComponent=ReactWorkTags.HostComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local HostPortal=ReactWorkTags.HostPortal;
    local HostText=ReactWorkTags.HostText;
    local FundamentalComponent=ReactWorkTags.FundamentalComponent;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local NoFlags=ReactFiberFlags.NoFlags;
    local Placement=ReactFiberFlags.Placement;
    local Hydrating=ReactFiberFlags.Hydrating;
    local enableFundamentalAPI=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.enableFundamentalAPI;
    local ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;
    local exports={};
    local function getNearestMountedFiber(fiber)
        local node=fiber;
        local nearestMounted=fiber;
        if not(fiber.alternate)then
             local nextNode=node;
            repeat
                 node=nextNode;
                if(bit32.band(node.flags,bit32.bor(Placement,Hydrating)))~=(NoFlags)then
                     nearestMounted=node.return_
                 end;
                nextNode=node.return_
             until not(nextNode)
        else
             while node.return_ do
                 node=node.return_
             end
         end;
        if(node.tag)==(HostRoot)then
             return nearestMounted
         end;
        return nil
     end;
    exports.getNearestMountedFiber=getNearestMountedFiber;
    exports.getSuspenseInstanceFromFiber=function(fiber)
        if(fiber.tag)==(SuspenseComponent)then
             local suspenseState=fiber.memoizedState;
            if(suspenseState)==(nil)then
                 local current=fiber.alternate;
                if(current)~=(nil)then
                     suspenseState=current.memoizedState
                 end
             end;
            if suspenseState then
                 return suspenseState.dehydrated
             end
         end;
        return nil
     end;
    exports.getContainerFromFiber=function(fiber)
        return if(fiber.tag)==(HostRoot)then fiber.stateNode.containerInfo else nil
     end;
    exports.isFiberMounted=function(fiber)
        return(getNearestMountedFiber(fiber))==(fiber)
    end;
    exports.isMounted=function(component)
        if _G.__DEV__ then
             local owner=ReactCurrentOwner.current;
            if((owner)~=(nil))and((owner.tag)==(ClassComponent))then
                 local ownerFiber=owner;
                local instance=ownerFiber.stateNode;
                if not(instance._warnedAboutRefsInRender)then
                     console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",(getComponentName(ownerFiber.type))or("A component"))
                end;
                instance._warnedAboutRefsInRender=true
             end
         end;
        local fiber=getInstance(component);
        if not(fiber)then
             return false
         else
             local fiberNonNil=fiber;
            return(getNearestMountedFiber(fiberNonNil))==(fiber)
        end
     end;
    local function assertIsMounted(fiber)
        invariant((getNearestMountedFiber(fiber))==(fiber),"Unable to find node on an unmounted component.")
    end;
    local function findCurrentFiberUsingSlowPath(fiber)
        local alternate=fiber.alternate;
        if not(alternate)then
             local nearestMounted=getNearestMountedFiber(fiber);
            invariant((nearestMounted)~=(nil),"Unable to find node on an unmounted component.");
            if(nearestMounted)~=(fiber)then
                 return nil
             end;
            return fiber
         end;
        local a=fiber;
        local b=alternate;
        while true do
             local parentA=a.return_;
            if(parentA)==(nil)then
                 break
             end;
            local parentB=parentA.alternate;
            if(parentB)==(nil)then
                 local nextParent=parentA.return_;
                if(nextParent)~=(nil)then
                     a=nextParent;
                    b=nextParent;
                    continue
                 end;
                break
             end;
            if(parentA.child)==(parentB.child)then
                 local child=parentA.child;
                while child do
                     if(child)==(a)then
                         assertIsMounted(parentA);
                        return fiber
                     end;
                    if(child)==(b)then
                         assertIsMounted(parentA);
                        return alternate
                     end;
                    child=child.sibling
                 end;
                invariant(false,"Unable to find node on an unmounted component.")
            end;
            if(a.return_)~=(b.return_)then
                 a=parentA;
                b=parentB
             else
                 local didFindChild=false;
                local child=parentA.child;
                while child do
                     if(child)==(a)then
                         didFindChild=true;
                        a=parentA;
                        b=parentB;
                        break
                     end;
                    if(child)==(b)then
                         didFindChild=true;
                        b=parentA;
                        a=parentB;
                        break
                     end;
                    child=child.sibling
                 end;
                if not(didFindChild)then
                     child=parentB.child;
                    while child do
                         if(child)==(a)then
                             didFindChild=true;
                            a=parentB;
                            b=parentA;
                            break
                         end;
                        if(child)==(b)then
                             didFindChild=true;
                            b=parentB;
                            a=parentA;
                            break
                         end;
                        child=child.sibling
                     end;
                    invariant(didFindChild,"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")
                end
             end;
            invariant((a.alternate)==(b),"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")
        end;
        invariant((a.tag)==(HostRoot),"Unable to find node on an unmounted component.");
        if(a.stateNode.current)==(a)then
             return fiber
         end;
        return alternate
     end;
    exports.findCurrentFiberUsingSlowPath=findCurrentFiberUsingSlowPath;
    exports.findCurrentHostFiber=function(parent)
        local currentParent=findCurrentFiberUsingSlowPath(parent);
        if not(currentParent)then
             return nil
         end;
        local node=currentParent;
        while true do
             local child=node.child;
            if((node.tag)==(HostComponent))or((node.tag)==(HostText))then
                 return node
             elseif child then
                 child.return_=node;
                node=child;
                continue
             end;
            if(node)==(currentParent)then
                 return nil
             end;
            local return_=node.return_;
            local sibling=node.sibling;
            while not(sibling)do
                 if(not(return_))or((return_)==(currentParent))then
                     return nil
                 end;
                node=return_
             end;
            (sibling).return_=return_;
            node=sibling
         end;
        return nil
     end;
    exports.findCurrentHostFiberWithNoPortals=function(parent)
        local currentParent=findCurrentFiberUsingSlowPath(parent);
        if not(currentParent)then
             return nil
         end;
        local node=currentParent;
        while true do
             local child=node.child;
            if(((node.tag)==(HostComponent))or((node.tag)==(HostText)))or(((enableFundamentalAPI)and((node.tag)==(FundamentalComponent))))then
                 return node
             elseif(child)and((node.tag)~=(HostPortal))then
                 child.return_=node;
                node=child;
                continue
             end;
            if(node)==(currentParent)then
                 return nil
             end;
            local return_=node.return_;
            local sibling=node.sibling;
            while not(sibling)do
                 if(not(return_))or((return_)==(currentParent))then
                     return nil
                 end;
                node=return_
             end;
            (sibling).return_=return_;
            node=sibling
         end;
        return nil
     end;
    exports.isFiberSuspenseAndTimedOut=function(fiber)
        local memoizedState=fiber.memoizedState;
        return(((fiber.tag)==(SuspenseComponent))and((memoizedState)~=(nil)))and((memoizedState.dehydrated)==(nil))
    end;
    exports.doesFiberContain=function(parentFiber,childFiber)
        local node=childFiber;
        local parentFiberAlternate=parentFiber.alternate;
        while(node)~=(nil)do
             if((node)==(parentFiber))or((node)==(parentFiberAlternate))then
                 return true
             end;
            node=node.return_
         end;
        return false
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberContext.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new",function()
    local __DEV__=_G.__DEV__;
    local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__=_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local Error=LuauPolyfill.Error;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new");
    type("not printable... yet");
    local isFiberMounted=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTreeReflection").isFiberMounted;
    local disableLegacyContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.disableLegacyContext;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local checkPropTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").checkPropTypes;
    local createCursor=ReactFiberStack.createCursor;
    local push=ReactFiberStack.push;
    local pop=ReactFiberStack.pop;
    local warnedAboutMissingGetChildContext;
    if __DEV__ then
         warnedAboutMissingGetChildContext={}
    end;
    local emptyContextObject={};
    if __DEV__ then
         Object.freeze(emptyContextObject)
    end;
    type("not printable... yet");
    local contextStackCursor=createCursor(emptyContextObject);
    local didPerformWorkStackCursor=createCursor(false);
    local previousContext=emptyContextObject;
    local isContextProvider;
    local function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider)
        if(didPushOwnContextIfProvider)and(isContextProvider(Component))then
             return previousContext
         end;
        return contextStackCursor.current
     end;
    local function cacheContext(workInProgress,unmaskedContext,maskedContext)
        local instance=workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext=maskedContext
     end;
    local function getMaskedContext(workInProgress,unmaskedContext)
        local type_=workInProgress.type;
        if(type(type_))==("function")then
             return unmaskedContext
         end;
        local contextTypes=type_.contextTypes;
        if not(contextTypes)then
             return emptyContextObject
         end;
        local instance=workInProgress.stateNode;
        if(instance)and((instance.__reactInternalMemoizedUnmaskedChildContext)==(unmaskedContext))then
             return instance.__reactInternalMemoizedMaskedChildContext
         end;
        local context={};
        for key,_ in contextTypes do
             context[key]=unmaskedContext[key]
        end;
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             local name=(getComponentName(type_))or("Unknown");
            checkPropTypes(contextTypes,nil,context,"context",name)
        end;
        if instance then
             cacheContext(workInProgress,unmaskedContext,context)
        end;
        return context
     end;
    local function hasContextChanged()
        if disableLegacyContext then
             return false
         else
             return didPerformWorkStackCursor.current
         end
     end;
    function isContextProvider(type_)
        if(type(type_))==("function")then
             return false
         end;
        local childContextTypes=type_.childContextTypes;
        return(childContextTypes)~=(nil)
    end;
    local function popContext(fiber)
        pop(didPerformWorkStackCursor,fiber);
        pop(contextStackCursor,fiber)
    end;
    local function popTopLevelContextObject(fiber)
        pop(didPerformWorkStackCursor,fiber);
        pop(contextStackCursor,fiber)
    end;
    local function pushTopLevelContextObject(fiber,context,didChange)
        if(contextStackCursor.current)~=(emptyContextObject)then
             error(Error.new("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."))
        end;
        push(contextStackCursor,context,fiber);
        push(didPerformWorkStackCursor,didChange,fiber)
    end;
    local function processChildContext(fiber,type_,parentContext)
        local instance=fiber.stateNode;
        local childContextTypes=type_.childContextTypes;
        if((instance.getChildContext)==(nil))or((type(instance.getChildContext))~=("function"))then
             if __DEV__ then
                 local componentName=(getComponentName(type_))or("Unknown");
                if not(warnedAboutMissingGetChildContext[componentName])then
                     warnedAboutMissingGetChildContext[componentName]=true;
                    console.error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",componentName,componentName)
                end
             end;
            return parentContext
         end;
        local childContext=instance:getChildContext();
        for contextKey,_ in childContext do
             if(childContextTypes[contextKey])==(nil)then
                 local name=(getComponentName(type_))or("Unknown");
                error(Error.new(string.format("%s.getChildContext(): key \"%s\" is not defined in childContextTypes.",name,contextKey)))
            end
         end;
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             local name=(getComponentName(type_))or("Unknown");
            checkPropTypes(childContextTypes,nil,childContext,"child context",name)
        end;
        return Object.assign({},parentContext,childContext)
    end;
    local function pushContextProvider(workInProgress)
        local instance=workInProgress.stateNode;
        local memoizedMergedChildContext=(((instance)and(instance.__reactInternalMemoizedMergedChildContext)))or(emptyContextObject);
        previousContext=contextStackCursor.current;
        push(contextStackCursor,memoizedMergedChildContext,workInProgress);
        push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);
        return true
     end;
    local function invalidateContextProvider(workInProgress,type_,didChange)
        local instance=workInProgress.stateNode;
        if not(instance)then
             error(Error.new("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."))
        end;
        if didChange then
             local mergedContext=processChildContext(workInProgress,type_,previousContext);
            instance.__reactInternalMemoizedMergedChildContext=mergedContext;
            pop(didPerformWorkStackCursor,workInProgress);
            pop(contextStackCursor,workInProgress);
            push(contextStackCursor,mergedContext,workInProgress);
            push(didPerformWorkStackCursor,didChange,workInProgress)
        else
             pop(didPerformWorkStackCursor,workInProgress);
            push(didPerformWorkStackCursor,didChange,workInProgress)
        end
     end;
    local function findCurrentUnmaskedContext(fiber)
        if((fiber.tag)~=(ClassComponent))or(not(isFiberMounted(fiber)))then
             error(Error.new("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."))
        end;
        local node=fiber;
        repeat
             if(node.tag)==(HostRoot)then
                 return node.stateNode.context
             elseif(node.tag)==(ClassComponent)then
                 local Component=node.type;
                if(Component.childContextTypes)~=(nil)then
                     return node.stateNode.__reactInternalMemoizedMergedChildContext
                 end
             end;
            node=node.return_
         until(node)==(nil);
        error(Error.new("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."))
    end;
    return{["emptyContextObject"]=emptyContextObject,["getUnmaskedContext"]=getUnmaskedContext,["cacheContext"]=cacheContext,["getMaskedContext"]=getMaskedContext,["hasContextChanged"]=hasContextChanged,["popContext"]=popContext,["popTopLevelContextObject"]=popTopLevelContextObject,["pushTopLevelContextObject"]=pushTopLevelContextObject,["processChildContext"]=processChildContext,["isContextProvider"]=isContextProvider,["pushContextProvider"]=pushContextProvider,["invalidateContextProvider"]=invalidateContextProvider,["findCurrentUnmaskedContext"]=findCurrentUnmaskedContext}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberRoot.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberRoot.new",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Set=LuauPolyfill.Set;
    local Map=LuauPolyfill.Map;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRootTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local noTimeout=ReactFiberHostConfig.noTimeout;
    local supportsHydration=ReactFiberHostConfig.supportsHydration;
    local ReactFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new");
    local createHostRootFiber=ReactFiber.createHostRootFiber;
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    local NoLanes=ReactFiberLane.NoLanes;
    local NoLanePriority=ReactFiberLane.NoLanePriority;
    local NoTimestamp=ReactFiberLane.NoTimestamp;
    local createLaneMap=ReactFiberLane.createLaneMap;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    local enableSuspenseCallback=ReactFeatureFlags.enableSuspenseCallback;
    local Scheduler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler").tracing;
    local unstable_getThreadID=Scheduler.unstable_getThreadID;
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    local initializeUpdateQueue=ReactUpdateQueue.initializeUpdateQueue;
    local LegacyRoot=ReactRootTags.LegacyRoot;
    local BlockingRoot=ReactRootTags.BlockingRoot;
    local ConcurrentRoot=ReactRootTags.ConcurrentRoot;
    local exports={};
    local function FiberRootNode(containerInfo,tag,hydrate)
        local rootNode={["tag"]=tag,["containerInfo"]=containerInfo,["pendingChildren"]=nil,["current"]=(nil),["pingCache"]=nil,["finishedWork"]=nil,["timeoutHandle"]=noTimeout,["context"]=nil,["pendingContext"]=nil,["hydrate"]=hydrate,["callbackNode"]=nil,["callbackPriority"]=NoLanePriority,["eventTimes"]=createLaneMap(NoLanes),["expirationTimes"]=createLaneMap(NoTimestamp),["pendingLanes"]=NoLanes,["suspendedLanes"]=NoLanes,["pingedLanes"]=NoLanes,["expiredLanes"]=NoLanes,["mutableReadLanes"]=NoLanes,["finishedLanes"]=NoLanes,["entangledLanes"]=NoLanes,["entanglements"]=createLaneMap(NoLanes)};
        if supportsHydration then
             rootNode.mutableSourceEagerHydrationData=nil
         end;
        if enableSchedulerTracing then
             rootNode.interactionThreadID=unstable_getThreadID();
            rootNode.memoizedInteractions=Set.new();
            rootNode.pendingInteractionMap=Map.new()
        end;
        if enableSuspenseCallback then
             rootNode.hydrationCallbacks=nil
         end;
        if _G.__DEV__ then
             if(tag)==(BlockingRoot)then
                 rootNode._debugRootType="createBlockingRoot()"
            elseif(tag)==(ConcurrentRoot)then
                 rootNode._debugRootType="createRoot()"
            elseif(tag)==(LegacyRoot)then
                 rootNode._debugRootType="createLegacyRoot()"
            end
         end;
        return rootNode
     end;
    exports.createFiberRoot=function(containerInfo,tag,hydrate,hydrationCallbacks)
        local root=FiberRootNode(containerInfo,tag,hydrate);
        if enableSuspenseCallback then
             root.hydrationCallbacks=hydrationCallbacks
         end;
        local uninitializedFiber=createHostRootFiber(tag);
        root.current=uninitializedFiber;
        uninitializedFiber.stateNode=root;
        initializeUpdateQueue(uninitializedFiber);
        return root
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberDevToolsHook.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberDevToolsHook.new",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    type("not printable... yet");
    local exports={};
    type("not printable... yet");
    local function isCallable(value)
        if(typeof(value))==("function")then
             return true
         end;
        if(typeof(value))==("table")then
             local mt=getmetatable(value);
            if(mt)and(rawget(mt,"__call"))then
                 return true
             end;
            if value._isMockFunction then
                 return true
             end
         end;
        return false
     end;
    local enableProfilerTimer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.enableProfilerTimer;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local DidCapture=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags").DidCapture;
    local rendererID;
    local injectedHook;
    local hasLoggedError=false;
    exports.isDevToolsPresent=function()
        return(_G.__REACT_DEVTOOLS_GLOBAL_HOOK__)~=(nil)
    end;
    exports.injectInternals=function(internals)
        if(_G.__REACT_DEVTOOLS_GLOBAL_HOOK__)==(nil)then
             return false
         end;
        local hook=_G.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        if hook.isDisabled then
             return true
         end;
        if not(hook.supportsFiber)then
             if _G.__DEV__ then
                 console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools")
            end;
            return true
         end;
        local ok,err=pcall(function()
            rendererID=hook.inject(internals);
            injectedHook=hook
         end);
        if not(ok)then
             if _G.__DEV__ then
                 console.error("React instrumentation encountered an error: %s.",err)
            end
         end;
        return true
     end;
    exports.onScheduleRoot=function(root,children)
        if _G.__DEV__ then
             if(injectedHook)and(isCallable(injectedHook.onScheduleFiberRoot))then
                 local ok,err=pcall(injectedHook.onScheduleFiberRoot,rendererID,root,children);
                if not(ok)then
                     if(_G.__DEV__)and(not(hasLoggedError))then
                         hasLoggedError=true;
                        console.error("React instrumentation encountered an error: %s",err)
                    end
                 end
             end
         end
     end;
    exports.onCommitRoot=function(root,priorityLevel)
        if(injectedHook)and(isCallable(injectedHook.onCommitFiberRoot))then
             local ok,err=pcall(function()
                local didError=(bit32.band(root.current.flags,DidCapture))==(DidCapture);
                if enableProfilerTimer then
                     injectedHook.onCommitFiberRoot(rendererID,root,priorityLevel,didError)
                else
                     injectedHook.onCommitFiberRoot(rendererID,root,nil,didError)
                end
             end);
            if not(ok)then
                 if _G.__DEV__ then
                     if not(hasLoggedError)then
                         hasLoggedError=true;
                        console.error("React instrumentation encountered an error: %s",err)
                    end
                 end
             end
         end
     end;
    exports.onCommitUnmount=function(fiber)
        if(injectedHook)and(isCallable(injectedHook.onCommitFiberUnmount))then
             local ok,err=pcall(injectedHook.onCommitFiberUnmount,rendererID,fiber);
            if not(ok)then
                 if _G.__DEV__ then
                     if not(hasLoggedError)then
                         hasLoggedError=true;
                        console.error("React instrumentation encountered an error: %s",err)
                    end
                 end
             end
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberWorkLoop.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new",function()
    local __DEV__=_G.__DEV__;
    local __YOLO__=_G.__YOLO__;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Set=LuauPolyfill.Set;
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local Scheduler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local ReactFiberStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new");
    type("not printable... yet");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableDebugTracing=ReactFeatureFlags.enableDebugTracing;
    local enableSchedulingProfiler=ReactFeatureFlags.enableSchedulingProfiler;
    local skipUnmountedBoundaries=ReactFeatureFlags.skipUnmountedBoundaries;
    local enableDoubleInvokingEffects=ReactFeatureFlags.enableDoubleInvokingEffects;
    local ReactShared=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ReactSharedInternals=ReactShared.ReactSharedInternals;
    local invariant=ReactShared.invariant;
    local SchedulerWithReactIntegration=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulerWithReactIntegration.new");
    local scheduleCallback=SchedulerWithReactIntegration.scheduleCallback;
    local cancelCallback=SchedulerWithReactIntegration.cancelCallback;
    local getCurrentPriorityLevel=SchedulerWithReactIntegration.getCurrentPriorityLevel;
    local runWithPriority=SchedulerWithReactIntegration.runWithPriority;
    local shouldYield=SchedulerWithReactIntegration.shouldYield;
    local requestPaint=SchedulerWithReactIntegration.requestPaint;
    local now=SchedulerWithReactIntegration.now;
    local NoSchedulerPriority=SchedulerWithReactIntegration.NoPriority;
    local ImmediateSchedulerPriority=SchedulerWithReactIntegration.ImmediatePriority;
    local UserBlockingSchedulerPriority=SchedulerWithReactIntegration.UserBlockingPriority;
    local NormalSchedulerPriority=SchedulerWithReactIntegration.NormalPriority;
    local flushSyncCallbackQueue=SchedulerWithReactIntegration.flushSyncCallbackQueue;
    local scheduleSyncCallback=SchedulerWithReactIntegration.scheduleSyncCallback;
    local DebugTracing=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.DebugTracing");
    local SchedulingProfiler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler");
    local SchedulerTracing=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler").tracing;
    local __interactionsRef,__subscriberRef=SchedulerTracing.__interactionsRef,SchedulerTracing.__subscriberRef;
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local ReactFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new");
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local LegacyRoot=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags").LegacyRoot;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    type("not printable... yet");
    local SyncLane=ReactFiberLane.SyncLane;
    local SyncBatchedLane=ReactFiberLane.SyncBatchedLane;
    local NoTimestamp=ReactFiberLane.NoTimestamp;
    local findUpdateLane=ReactFiberLane.findUpdateLane;
    local findTransitionLane=ReactFiberLane.findTransitionLane;
    local findRetryLane=ReactFiberLane.findRetryLane;
    local includesSomeLane=ReactFiberLane.includesSomeLane;
    local isSubsetOfLanes=ReactFiberLane.isSubsetOfLanes;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local removeLanes=ReactFiberLane.removeLanes;
    local pickArbitraryLane=ReactFiberLane.pickArbitraryLane;
    local hasDiscreteLanes=ReactFiberLane.hasDiscreteLanes;
    local includesNonIdleWork=ReactFiberLane.includesNonIdleWork;
    local includesOnlyRetries=ReactFiberLane.includesOnlyRetries;
    local includesOnlyTransitions=ReactFiberLane.includesOnlyTransitions;
    local getNextLanes=ReactFiberLane.getNextLanes;
    local returnNextLanesPriority=ReactFiberLane.returnNextLanesPriority;
    local setCurrentUpdateLanePriority=ReactFiberLane.setCurrentUpdateLanePriority;
    local getCurrentUpdateLanePriority=ReactFiberLane.getCurrentUpdateLanePriority;
    local markStarvedLanesAsExpired=ReactFiberLane.markStarvedLanesAsExpired;
    local getLanesToRetrySynchronouslyOnError=ReactFiberLane.getLanesToRetrySynchronouslyOnError;
    local getMostRecentEventTime=ReactFiberLane.getMostRecentEventTime;
    local markRootUpdated=ReactFiberLane.markRootUpdated;
    local markRootSuspended_dontCallThisOneDirectly=ReactFiberLane.markRootSuspended;
    local markRootPinged=ReactFiberLane.markRootPinged;
    local markRootExpired=ReactFiberLane.markRootExpired;
    local markDiscreteUpdatesExpired=ReactFiberLane.markDiscreteUpdatesExpired;
    local markRootFinished=ReactFiberLane.markRootFinished;
    local schedulerPriorityToLanePriority=ReactFiberLane.schedulerPriorityToLanePriority;
    local lanePriorityToSchedulerPriority=ReactFiberLane.lanePriorityToSchedulerPriority;
    local ReactFiberTransition=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTransition");
    local ReactFiberUnwindWork=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberUnwindWork.new");
    local unwindWork=ReactFiberUnwindWork.unwindWork;
    local unwindInterruptedWork=ReactFiberUnwindWork.unwindInterruptedWork;
    local ReactFiberThrow=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberThrow.new");
    local throwException=ReactFiberThrow.throwException;
    local createRootErrorUpdate=ReactFiberThrow.createRootErrorUpdate;
    local createClassErrorUpdate=ReactFiberThrow.createClassErrorUpdate;
    local ReactFiberCommitWork=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberCommitWork.new");
    local commitBeforeMutationEffectOnFiber=ReactFiberCommitWork.commitBeforeMutationLifeCycles;
    local commitPlacement=ReactFiberCommitWork.commitPlacement;
    local commitWork=ReactFiberCommitWork.commitWork;
    local commitDeletion=ReactFiberCommitWork.commitDeletion;
    local commitPassiveUnmountOnFiber=ReactFiberCommitWork.commitPassiveUnmount;
    local commitPassiveUnmountInsideDeletedTreeOnFiber=ReactFiberCommitWork.commitPassiveUnmountInsideDeletedTree;
    local commitPassiveMountOnFiber=ReactFiberCommitWork.commitPassiveMount;
    local commitDetachRef=ReactFiberCommitWork.commitDetachRef;
    local invokeLayoutEffectMountInDEV=ReactFiberCommitWork.invokeLayoutEffectMountInDEV;
    local invokePassiveEffectMountInDEV=ReactFiberCommitWork.invokePassiveEffectMountInDEV;
    local invokeLayoutEffectUnmountInDEV=ReactFiberCommitWork.invokeLayoutEffectUnmountInDEV;
    local invokePassiveEffectUnmountInDEV=ReactFiberCommitWork.invokePassiveEffectUnmountInDEV;
    local recursivelyCommitLayoutEffects=ReactFiberCommitWork.recursivelyCommitLayoutEffects;
    local Promise=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.promise");
    local enqueueUpdate=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new").enqueueUpdate;
    local resetContextDependencies=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new").resetContextDependencies;
    local RobloxReactProfiling=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.RobloxReactProfiling");
    local ensureRootIsScheduled;
    local lazyInitRefs={["resetHooksAfterThrowRef"]=(nil),["ContextOnlyDispatcherRef"]=(nil),["getIsUpdatingOpaqueValueInRenderPhaseInDEVRef"]=(nil),["originalBeginWorkRef"]=(nil),["completeWorkRef"]=(nil)};
    local originalBeginWork=function(current,workInProgress,renderLanes)
        if not(lazyInitRefs.originalBeginWorkRef)then
             lazyInitRefs.originalBeginWorkRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberBeginWork.new").beginWork
         end;
        return lazyInitRefs.originalBeginWorkRef(current,workInProgress,renderLanes)
    end;
    local completeWork=function(current,workInProgress,renderLanes)
        if not(lazyInitRefs.completeWorkRef)then
             lazyInitRefs.completeWorkRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberCompleteWork.new").completeWork
         end;
        return(lazyInitRefs.completeWorkRef)(current,workInProgress,renderLanes)
    end;
    local ReactFiberHooks;
    local function initReactFiberHooks()
        ReactFiberHooks=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHooks.new");
        lazyInitRefs.resetHooksAfterThrowRef=ReactFiberHooks.resetHooksAfterThrow;
        lazyInitRefs.ContextOnlyDispatcherRef=ReactFiberHooks.ContextOnlyDispatcher;
        lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef=ReactFiberHooks.getIsUpdatingOpaqueValueInRenderPhaseInDEV
     end;
    local resetHooksAfterThrow=function()
        if not(lazyInitRefs.resetHooksAfterThrowRef)then
             initReactFiberHooks()
        end;
        return lazyInitRefs.resetHooksAfterThrowRef()
    end;
    local ContextOnlyDispatcher=function()
        if not(lazyInitRefs.ContextOnlyDispatcherRef)then
             initReactFiberHooks()
        end;
        return lazyInitRefs.ContextOnlyDispatcherRef
     end;
    local getIsUpdatingOpaqueValueInRenderPhaseInDEV=function()
        if not(lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef)then
             initReactFiberHooks()
        end;
        return lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef()
    end;
    local createCapturedValue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCapturedValue").createCapturedValue;
    local pushToStack=ReactFiberStack.push;
    local popFromStack=ReactFiberStack.pop;
    local createCursor=ReactFiberStack.createCursor;
    local ReactProfilerTimer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new");
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactStrictModeWarnings=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactStrictModeWarnings.new");
    local ReactCurrentFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber");
    local ReactCurrentFiberCurrent=ReactCurrentFiber.current;
    local resetCurrentDebugFiberInDEV=ReactCurrentFiber.resetCurrentFiber;
    local setCurrentDebugFiberInDEV=ReactCurrentFiber.setCurrentFiber;
    local ReactErrorUtils=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactErrorUtils;
    local invokeGuardedCallback=ReactErrorUtils.invokeGuardedCallback;
    local hasCaughtError=ReactErrorUtils.hasCaughtError;
    local clearCaughtError=ReactErrorUtils.clearCaughtError;
    local onCommitRootDevTools=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberDevToolsHook.new").onCommitRoot;
    local onCommitRootTestSelector=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTestSelectors").onCommitRoot;
    local enqueueTask=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").enqueueTask;
    local doesFiberContain=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTreeReflection").doesFiberContain;
    local ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;
    local ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;
    local IsSomeRendererActing=ReactSharedInternals.IsSomeRendererActing;
    local captureCommitPhaseErrorOnRoot,flushPassiveMountEffects;
    local mod={};
    type("not printable... yet");
    local NoContext=0;
    local BatchedContext=1;
    local EventContext=2;
    local DiscreteEventContext=4;
    local LegacyUnbatchedContext=8;
    local RenderContext=16;
    local CommitContext=32;
    local RetryAfterError=64;
    exports.NoContext=NoContext;
    exports.RetryAfterError=RetryAfterError;
    type("not printable... yet");
    local RootExitStatus={["Incomplete"]=0,["FatalErrored"]=1,["Errored"]=2,["Suspended"]=3,["SuspendedWithDelay"]=4,["Completed"]=5};
    local executionContext=NoContext;
    local workInProgressRoot;
    local workInProgress;
    local workInProgressRootRenderLanes=ReactFiberLane.NoLanes;
    exports.subtreeRenderLanes=ReactFiberLane.NoLanes;
    local subtreeRenderLanesCursor=createCursor(ReactFiberLane.NoLanes);
    local workInProgressRootExitStatus=RootExitStatus.Incomplete;
    local workInProgressRootFatalError;
    local workInProgressRootIncludedLanes=ReactFiberLane.NoLanes;
    local ReactFiberWorkInProgress=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkInProgress");
    local workInProgressRootSkippedLanes=ReactFiberWorkInProgress.workInProgressRootSkippedLanes;
    local workInProgressRootUpdatedLanes=ReactFiberLane.NoLanes;
    local workInProgressRootPingedLanes=ReactFiberLane.NoLanes;
    local mostRecentlyUpdatedRoot;
    local globalMostRecentFallbackTime=0;
    local FALLBACK_THROTTLE_MS=500;
    local workInProgressRootRenderTargetTime=math.huge;
    local RENDER_TIMEOUT_MS=500;
    local nearestProfilerOnStack;
    local function resetRenderTimer()
        workInProgressRootRenderTargetTime=(now())+(RENDER_TIMEOUT_MS)
    end;
    exports.getRenderTargetTime=function()
        return workInProgressRootRenderTargetTime
     end;
    local hasUncaughtError=false;
    local firstUncaughtError;
    local legacyErrorBoundariesThatAlreadyFailed;
    local rootDoesHavePassiveEffects=false;
    local rootWithPendingPassiveEffects;
    local pendingPassiveEffectsRenderPriority=NoSchedulerPriority;
    local pendingPassiveEffectsLanes=ReactFiberLane.NoLanes;
    local rootsWithPendingDiscreteUpdates;
    local NESTED_UPDATE_LIMIT=50;
    local nestedUpdateCount=0;
    local rootWithNestedUpdates;
    local NESTED_PASSIVE_UPDATE_LIMIT=50;
    local nestedPassiveUpdateCount=0;
    local spawnedWorkDuringRender;
    local currentEventTime=NoTimestamp;
    local currentEventWipLanes=ReactFiberLane.NoLanes;
    local currentEventPendingLanes=ReactFiberLane.NoLanes;
    local focusedInstanceHandle;
    local shouldFireAfterActiveInstanceBlur=false;
    exports.getWorkInProgressRoot=function()
        return workInProgressRoot
     end;
    exports.requestEventTime=function()
        if(bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))~=(NoContext)then
             return now()
        end;
        if(currentEventTime)~=(NoTimestamp)then
             return currentEventTime
         end;
        currentEventTime=now();
        return currentEventTime
     end;
    exports.requestUpdateLane=function(fiber)
        local mode=fiber.mode;
        if(bit32.band(mode,ReactTypeOfMode.BlockingMode))==(ReactTypeOfMode.NoMode)then
             return SyncLane
         elseif(bit32.band(mode,ReactTypeOfMode.ConcurrentMode))==(ReactTypeOfMode.NoMode)then
             return if(getCurrentPriorityLevel())==(ImmediateSchedulerPriority)then SyncLane else SyncBatchedLane
         elseif((not(ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch))and((bit32.band(executionContext,RenderContext))~=(NoContext)))and((workInProgressRootRenderLanes)~=(ReactFiberLane.NoLanes))then
             return pickArbitraryLane(workInProgressRootRenderLanes)
        end;
        if(currentEventWipLanes)==(ReactFiberLane.NoLanes)then
             currentEventWipLanes=workInProgressRootIncludedLanes
         end;
        local isTransition=(ReactFiberTransition.requestCurrentTransition())~=(ReactFiberTransition.NoTransition);
        if isTransition then
             if(currentEventPendingLanes)~=(ReactFiberLane.NoLanes)then
                 if(mostRecentlyUpdatedRoot)~=(nil)then
                     currentEventPendingLanes=mostRecentlyUpdatedRoot.pendingLanes
                 else
                     currentEventPendingLanes=ReactFiberLane.NoLanes
                 end
             end;
            return findTransitionLane(currentEventWipLanes,currentEventPendingLanes)
        end;
        local schedulerPriority=getCurrentPriorityLevel();
        local lane;
        if((bit32.band(executionContext,DiscreteEventContext))~=(NoContext))and((schedulerPriority)==(UserBlockingSchedulerPriority))then
             lane=findUpdateLane(ReactFiberLane.InputDiscreteLanePriority,currentEventWipLanes)
        else
             local schedulerLanePriority=schedulerPriorityToLanePriority(schedulerPriority);
            if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
                 local currentUpdateLanePriority=getCurrentUpdateLanePriority();
                if((schedulerLanePriority)~=(currentUpdateLanePriority))and((currentUpdateLanePriority)~=(ReactFiberLane.NoLanePriority))then
                     if __DEV__ then
                         console.error("Expected current scheduler lane priority %s to match current update lane priority %s",tostring(schedulerLanePriority),tostring(currentUpdateLanePriority))
                    end
                 end
             end;
            lane=findUpdateLane(schedulerLanePriority,currentEventWipLanes)
        end;
        return lane
     end;
    function requestRetryLane(fiber)
        local mode=fiber.mode;
        if(bit32.band(mode,ReactTypeOfMode.BlockingMode))==(ReactTypeOfMode.NoMode)then
             return SyncLane
         elseif(bit32.band(mode,ReactTypeOfMode.ConcurrentMode))==(ReactTypeOfMode.NoMode)then
             return if(getCurrentPriorityLevel())==(ImmediateSchedulerPriority)then SyncLane else SyncBatchedLane
         end;
        if(currentEventWipLanes)==(ReactFiberLane.NoLanes)then
             currentEventWipLanes=workInProgressRootIncludedLanes
         end;
        return findRetryLane(currentEventWipLanes)
    end;
    exports.scheduleUpdateOnFiber=function(fiber,lane,eventTime)
        mod.checkForNestedUpdates();
        local root=mod.markUpdateLaneFromFiberToRoot(fiber,lane);
        if(root)==(nil)then
             return nil
         end;
        markRootUpdated(root,lane,eventTime);
        if(root)==(workInProgressRoot)then
             mod.warnAboutRenderPhaseUpdatesInDEV(fiber);
            if(ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch)or((bit32.band(executionContext,RenderContext))==(NoContext))then
                 workInProgressRootUpdatedLanes=mergeLanes(workInProgressRootUpdatedLanes,lane)
            end;
            if(workInProgressRootExitStatus)==(RootExitStatus.SuspendedWithDelay)then
                 mod.markRootSuspended(root,workInProgressRootRenderLanes)
            end
         end;
        local priorityLevel=getCurrentPriorityLevel();
        if(lane)==(SyncLane)then
             if((bit32.band(executionContext,LegacyUnbatchedContext))~=(NoContext))and((bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext))then
                 mod.schedulePendingInteractions(root,lane);
                mod.performSyncWorkOnRoot(root)
            else
                 ensureRootIsScheduled(root,eventTime);
                mod.schedulePendingInteractions(root,lane);
                if(executionContext)==(NoContext)then
                     resetRenderTimer();
                    flushSyncCallbackQueue()
                end
             end
         else
             if((bit32.band(executionContext,DiscreteEventContext))~=(NoContext))and((((priorityLevel)==(UserBlockingSchedulerPriority))or((priorityLevel)==(ImmediateSchedulerPriority))))then
                 if(rootsWithPendingDiscreteUpdates)==(nil)then
                     rootsWithPendingDiscreteUpdates=Set.new({root})
                else
                     rootsWithPendingDiscreteUpdates:add(root)
                end
             end;
            ensureRootIsScheduled(root,eventTime);
            mod.schedulePendingInteractions(root,lane)
        end;
        mostRecentlyUpdatedRoot=root;
        return root
     end;
    mod.markUpdateLaneFromFiberToRoot=function(sourceFiber,lane)
        sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);
        local alternate=sourceFiber.alternate;
        if(alternate)~=(nil)then
             alternate.lanes=mergeLanes(alternate.lanes,lane)
        end;
        if __DEV__ then
             if((alternate)==(nil))and((bit32.band(sourceFiber.flags,bit32.bor(ReactFiberFlags.Placement,ReactFiberFlags.Hydrating)))~=(ReactFiberFlags.NoFlags))then
                 mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
            end
         end;
        local node=sourceFiber;
        local parent=sourceFiber.return_;
        while(parent)~=(nil)do
             parent.childLanes=mergeLanes(parent.childLanes,lane);
            alternate=parent.alternate;
            if(alternate)~=(nil)then
                 alternate.childLanes=mergeLanes(alternate.childLanes,lane)
            else
                 if __DEV__ then
                     if(bit32.band(parent.flags,bit32.bor(ReactFiberFlags.Placement,ReactFiberFlags.Hydrating)))~=(ReactFiberFlags.NoFlags)then
                         mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
                    end
                 end
             end;
            node=parent;
            parent=parent.return_
         end;
        if(node.tag)==(ReactWorkTags.HostRoot)then
             local root=node.stateNode;
            return root
         else
             return nil
         end
     end;
    ensureRootIsScheduled=function(root,currentTime)
        local existingCallbackNode=root.callbackNode;
        markStarvedLanesAsExpired(root,currentTime);
        local lanes;
        if(root)==(workInProgressRoot)then
             lanes=workInProgressRootRenderLanes
         else
             lanes=ReactFiberLane.NoLanes
         end;
        local nextLanes=getNextLanes(root,lanes);
        local newCallbackPriority=returnNextLanesPriority();
        if(nextLanes)==(ReactFiberLane.NoLanes)then
             if(existingCallbackNode)~=(nil)then
                 cancelCallback(existingCallbackNode);
                root.callbackNode=nil;
                root.callbackPriority=ReactFiberLane.NoLanePriority
             end;
            return
         end;
        if(existingCallbackNode)~=(nil)then
             local existingCallbackPriority=root.callbackPriority;
            if(existingCallbackPriority)==(newCallbackPriority)then
                 return
             end;
            cancelCallback(existingCallbackNode)
        end;
        local newCallbackNode;
        if(newCallbackPriority)==(ReactFiberLane.SyncLanePriority)then
             newCallbackNode=scheduleSyncCallback(function()
                local profileRunning=RobloxReactProfiling.profileRootBeforeUnitOfWork(root);
                local ret=mod.performSyncWorkOnRoot(root);
                RobloxReactProfiling.profileRootAfterYielding(profileRunning);
                return ret
             end)
        elseif(newCallbackPriority)==(ReactFiberLane.SyncBatchedLanePriority)then
             newCallbackNode=scheduleCallback(ImmediateSchedulerPriority,function()
                local profileRunning=RobloxReactProfiling.profileRootBeforeUnitOfWork(root);
                local ret=mod.performSyncWorkOnRoot(root);
                RobloxReactProfiling.profileRootAfterYielding(profileRunning);
                return ret
             end)
        else
             local schedulerPriorityLevel=lanePriorityToSchedulerPriority(newCallbackPriority);
            newCallbackNode=scheduleCallback(schedulerPriorityLevel,function()
                local profileRunning=RobloxReactProfiling.profileRootBeforeUnitOfWork(root);
                local ret=mod.performConcurrentWorkOnRoot(root);
                RobloxReactProfiling.profileRootAfterYielding(profileRunning);
                return ret
             end)
        end;
        root.callbackPriority=newCallbackPriority;
        root.callbackNode=newCallbackNode
     end;
    mod.performConcurrentWorkOnRoot=function(root)
        currentEventTime=NoTimestamp;
        currentEventWipLanes=ReactFiberLane.NoLanes;
        currentEventPendingLanes=ReactFiberLane.NoLanes;
        invariant((bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext),"Should not already be working.");
        local originalCallbackNode=root.callbackNode;
        local didFlushPassiveEffects=exports.flushPassiveEffects();
        if didFlushPassiveEffects then
             if(root.callbackNode)~=(originalCallbackNode)then
                 return nil
             end
         end;
        local lanes=getNextLanes(root,if(root)==(workInProgressRoot)then workInProgressRootRenderLanes else ReactFiberLane.NoLanes);
        if(lanes)==(ReactFiberLane.NoLanes)then
             return nil
         end;
        local exitStatus=mod.renderRootConcurrent(root,lanes);
        if includesSomeLane(workInProgressRootIncludedLanes,workInProgressRootUpdatedLanes)then
             mod.prepareFreshStack(root,ReactFiberLane.NoLanes)
        elseif(exitStatus)~=(RootExitStatus.Incomplete)then
             if(exitStatus)==(RootExitStatus.Errored)then
                 executionContext=bit32.bor(executionContext,RetryAfterError);
                if root.hydrate then
                     root.hydrate=false;
                    ReactFiberHostConfig.clearContainer(root.containerInfo)
                end;
                lanes=getLanesToRetrySynchronouslyOnError(root);
                if(lanes)~=(ReactFiberLane.NoLanes)then
                     exitStatus=mod.renderRootSync(root,lanes)
                end
             end;
            if(exitStatus)==(RootExitStatus.FatalErrored)then
                 local fatalError=workInProgressRootFatalError;
                mod.prepareFreshStack(root,ReactFiberLane.NoLanes);
                mod.markRootSuspended(root,lanes);
                ensureRootIsScheduled(root,now());
                error(fatalError)
            end;
            local finishedWork=root.current.alternate;
            root.finishedWork=finishedWork;
            root.finishedLanes=lanes;
            mod.finishConcurrentRender(root,exitStatus,lanes)
        end;
        ensureRootIsScheduled(root,now());
        if(root.callbackNode)==(originalCallbackNode)then
             return function()
                return mod.performConcurrentWorkOnRoot(root)
            end
         end;
        return nil
     end;
    local actingUpdatesScopeDepth=0;
    local didWarnAboutUsingActInProd=false;
    function shouldForceFlushFallbacksInDEV()
        return(__DEV__)and((actingUpdatesScopeDepth)>(0))
    end;
    mod.finishConcurrentRender=function(root,exitStatus,lanes)
        if((exitStatus)==(RootExitStatus.Incomplete))or((exitStatus)==(RootExitStatus.FatalErrored))then
             invariant(false,"Root did not complete. This is a bug in React.")
        elseif(exitStatus)==(RootExitStatus.Errored)then
             mod.commitRoot(root)
        elseif(exitStatus)==(RootExitStatus.Suspended)then
             mod.markRootSuspended(root,lanes);
            if(includesOnlyRetries(lanes))and(not(shouldForceFlushFallbacksInDEV()))then
                 local msUntilTimeout=((globalMostRecentFallbackTime)+(FALLBACK_THROTTLE_MS))-(now());
                if(msUntilTimeout)>(10)then
                     local nextLanes=getNextLanes(root,ReactFiberLane.NoLanes);
                    if(nextLanes)~=(ReactFiberLane.NoLanes)then
                         return
                     end;
                    local suspendedLanes=root.suspendedLanes;
                    if not(isSubsetOfLanes(suspendedLanes,lanes))then
                         local eventTime=exports.requestEventTime();
                        markRootPinged(root,suspendedLanes,eventTime);
                        return
                     end;
                    root.timeoutHandle=ReactFiberHostConfig.scheduleTimeout(function()
                        return mod.commitRoot(root)
                    end,msUntilTimeout);
                    return
                 end
             end;
            mod.commitRoot(root)
        elseif(exitStatus)==(RootExitStatus.SuspendedWithDelay)then
             mod.markRootSuspended(root,lanes);
            if includesOnlyTransitions(lanes)then
                 return
             end;
            if not(shouldForceFlushFallbacksInDEV())then
                 local mostRecentEventTime=getMostRecentEventTime(root,lanes);
                local eventTimeMs=mostRecentEventTime;
                local timeElapsedMs=(now())-(eventTimeMs);
                local msUntilTimeout=(jnd(timeElapsedMs))-(timeElapsedMs);
                if(msUntilTimeout)>(10)then
                     root.timeoutHandle=ReactFiberHostConfig.scheduleTimeout(function()
                        return mod.commitRoot(root)
                    end,msUntilTimeout);
                    return
                 end
             end;
            mod.commitRoot(root)
        elseif(exitStatus)==(RootExitStatus.Completed)then
             mod.commitRoot(root)
        else
             invariant(false,"Unknown root exit status.")
        end
     end;
    mod.markRootSuspended=function(root,suspendedLanes)
        suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);
        suspendedLanes=removeLanes(suspendedLanes,workInProgressRootUpdatedLanes);
        markRootSuspended_dontCallThisOneDirectly(root,suspendedLanes)
    end;
    mod.performSyncWorkOnRoot=function(root)
        invariant((bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext),"Should not already be working.");
        exports.flushPassiveEffects();
        local lanes;
        local exitStatus;
        if((root)==(workInProgressRoot))and(includesSomeLane(root.expiredLanes,workInProgressRootRenderLanes))then
             lanes=workInProgressRootRenderLanes;
            exitStatus=mod.renderRootSync(root,lanes);
            if includesSomeLane(workInProgressRootIncludedLanes,workInProgressRootUpdatedLanes)then
                 lanes=getNextLanes(root,lanes);
                exitStatus=mod.renderRootSync(root,lanes)
            end
         else
             lanes=getNextLanes(root,ReactFiberLane.NoLanes);
            exitStatus=mod.renderRootSync(root,lanes)
        end;
        if((root.tag)~=(LegacyRoot))and((exitStatus)==(RootExitStatus.Errored))then
             executionContext=bit32.bor(executionContext,RetryAfterError);
            if root.hydrate then
                 root.hydrate=false;
                ReactFiberHostConfig.clearContainer(root.containerInfo)
            end;
            lanes=getLanesToRetrySynchronouslyOnError(root);
            if(lanes)~=(ReactFiberLane.NoLanes)then
                 exitStatus=mod.renderRootSync(root,lanes)
            end
         end;
        if(exitStatus)==(RootExitStatus.FatalErrored)then
             local fatalError=workInProgressRootFatalError;
            mod.prepareFreshStack(root,ReactFiberLane.NoLanes);
            mod.markRootSuspended(root,lanes);
            ensureRootIsScheduled(root,now());
            error(fatalError)
        end;
        local finishedWork=root.current.alternate;
        root.finishedWork=finishedWork;
        root.finishedLanes=lanes;
        mod.commitRoot(root);
        ensureRootIsScheduled(root,now());
        return nil
     end;
    exports.flushRoot=function(root,lanes)
        markRootExpired(root,lanes);
        ensureRootIsScheduled(root,now());
        if(bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext)then
             resetRenderTimer();
            flushSyncCallbackQueue()
        end
     end;
    exports.getExecutionContext=function()
        return executionContext
     end;
    exports.flushDiscreteUpdates=function()
        if(bit32.band(executionContext,bit32.bor(BatchedContext,RenderContext,CommitContext)))~=(NoContext)then
             if __DEV__ then
                 if(bit32.band(executionContext,RenderContext))~=(NoContext)then
                     console.error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.")
                end
             end;
            return
         end;
        mod.flushPendingDiscreteUpdates();
        exports.flushPassiveEffects()
    end;
    exports.deferredUpdates=function(fn)
        if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
             local previousLanePriority=getCurrentUpdateLanePriority();
            local ok,result;
            if not(__YOLO__)then
                 setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority);
                ok,result=xpcall(runWithPriority,describeError,NormalSchedulerPriority,fn)
            else
                 ok=true;
                setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority);
                result=runWithPriority(NormalSchedulerPriority,fn)
            end;
            setCurrentUpdateLanePriority(previousLanePriority);
            if ok then
                 return result
             else
                 error(result)
            end
         else
             return runWithPriority(NormalSchedulerPriority,fn)
        end
     end;
    mod.flushPendingDiscreteUpdates=function()
        if(rootsWithPendingDiscreteUpdates)~=(nil)then
             local roots=rootsWithPendingDiscreteUpdates;
            rootsWithPendingDiscreteUpdates=nil;
            roots:forEach(function(root)
                markDiscreteUpdatesExpired(root);
                ensureRootIsScheduled(root,now())
            end)
        end;
        flushSyncCallbackQueue()
    end;
    exports.batchedUpdates=function(fn,a)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,BatchedContext);
        local ok,result;
        if not(__YOLO__)then
             ok,result=xpcall(fn,describeError,a)
        else
             ok=true;
            result=fn(a)
        end;
        executionContext=prevExecutionContext;
        if(executionContext)==(NoContext)then
             resetRenderTimer();
            flushSyncCallbackQueue()
        end;
        if ok then
             return result
         else
             error(result)
        end
     end;
    exports.batchedEventUpdates=function(fn,a)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,EventContext);
        local ok,result;
        if not(__YOLO__)then
             ok,result=xpcall(fn,describeError,a)
        else
             ok=true;
            result=fn(a)
        end;
        executionContext=prevExecutionContext;
        if(executionContext)==(NoContext)then
             resetRenderTimer();
            flushSyncCallbackQueue()
        end;
        if ok then
             return result
         else
             error(result)
        end
     end;
    exports.discreteUpdates=function(fn,a,b,c,d)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,DiscreteEventContext);
        if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
             local previousLanePriority=getCurrentUpdateLanePriority();
            setCurrentUpdateLanePriority(ReactFiberLane.InputDiscreteLanePriority);
            local ok,result=xpcall(runWithPriority,describeError,UserBlockingSchedulerPriority,function()
                return fn(a,b,c,d)
            end);
            setCurrentUpdateLanePriority(previousLanePriority);
            executionContext=prevExecutionContext;
            if(executionContext)==(NoContext)then
                 resetRenderTimer();
                flushSyncCallbackQueue()
            end;
            if ok then
                 return result
             else
                 error(result)
            end
         else
             local ok,result=xpcall(runWithPriority,describeError,UserBlockingSchedulerPriority,function()
                return fn(a,b,c,d)
            end);
            executionContext=prevExecutionContext;
            if(executionContext)==(NoContext)then
                 resetRenderTimer();
                flushSyncCallbackQueue()
            end;
            if ok then
                 return result
             else
                 error(result)
            end
         end
     end;
    exports.unbatchedUpdates=function(fn,a)
        local prevExecutionContext=executionContext;
        executionContext=bit32.band(executionContext,bit32.bnot(BatchedContext));
        executionContext=bit32.bor(executionContext,LegacyUnbatchedContext);
        local ok,result;
        if not(__YOLO__)then
             ok,result=xpcall(fn,describeError,a)
        else
             ok=true;
            result=fn(a)
        end;
        executionContext=prevExecutionContext;
        if(executionContext)==(NoContext)then
             resetRenderTimer();
            flushSyncCallbackQueue()
        end;
        if ok then
             return result
         else
             error(result)
        end
     end;
    exports.flushSync=function(fn,a)
        local prevExecutionContext=executionContext;
        if((bit32.band(prevExecutionContext,bit32.bor(RenderContext,CommitContext))))~=(NoContext)then
             if __DEV__ then
                 console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.")
            end;
            return fn(a)
        end;
        executionContext=bit32.bor(executionContext,BatchedContext);
        if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
             local previousLanePriority=getCurrentUpdateLanePriority();
            setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority);
            local ok,result;
            if not(__YOLO__)then
                 if fn then
                     ok,result=xpcall(runWithPriority,describeError,ImmediateSchedulerPriority,function()
                        return fn(a)
                    end)
                else
                     ok=true;
                    result=nil
                 end
             else
                 ok=true;
                setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority);
                if fn then
                     result=runWithPriority(ImmediateSchedulerPriority,function()
                        return fn(a)
                    end)
                else
                     result=nil
                 end
             end;
            setCurrentUpdateLanePriority(previousLanePriority);
            executionContext=prevExecutionContext;
            flushSyncCallbackQueue();
            if not(ok)then
                 error(result)
            end;
            return result
         else
             local ok,result;
            if not(__YOLO__)then
                 if fn then
                     ok,result=xpcall(runWithPriority,describeError,ImmediateSchedulerPriority,function()
                        return fn(a)
                    end)
                else
                     ok=true;
                    result=nil
                 end
             else
                 ok=true;
                if fn then
                     result=runWithPriority(ImmediateSchedulerPriority,function()
                        return fn(a)
                    end)
                else
                     result=nil
                 end
             end;
            executionContext=prevExecutionContext;
            flushSyncCallbackQueue();
            if not(ok)then
                 error(result)
            end;
            return result
         end
     end;
    exports.flushControlled=function(fn)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,BatchedContext);
        if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
             local previousLanePriority=getCurrentUpdateLanePriority();
            setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority);
            local ok,result=xpcall(runWithPriority,describeError,ImmediateSchedulerPriority,fn);
            setCurrentUpdateLanePriority(previousLanePriority);
            executionContext=prevExecutionContext;
            if(executionContext)==(NoContext)then
                 resetRenderTimer();
                flushSyncCallbackQueue()
            end;
            if not(ok)then
                 error(result)
            end
         else
             local ok,result=xpcall(runWithPriority,describeError,ImmediateSchedulerPriority,fn);
            executionContext=prevExecutionContext;
            if(executionContext)==(NoContext)then
                 resetRenderTimer();
                flushSyncCallbackQueue()
            end;
            if not(ok)then
                 error(result)
            end
         end
     end;
    exports.pushRenderLanes=function(fiber,lanes)
        pushToStack(subtreeRenderLanesCursor,exports.subtreeRenderLanes,fiber);
        exports.subtreeRenderLanes=mergeLanes(exports.subtreeRenderLanes,lanes);
        workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes)
    end;
    exports.popRenderLanes=function(fiber)
        exports.subtreeRenderLanes=subtreeRenderLanesCursor.current;
        popFromStack(subtreeRenderLanesCursor,fiber)
    end;
    mod.prepareFreshStack=function(root,lanes)
        root.finishedWork=nil;
        root.finishedLanes=ReactFiberLane.NoLanes;
        local timeoutHandle=root.timeoutHandle;
        if(timeoutHandle)~=(ReactFiberHostConfig.noTimeout)then
             root.timeoutHandle=ReactFiberHostConfig.noTimeout;
            ReactFiberHostConfig.cancelTimeout(timeoutHandle)
        end;
        if(workInProgress)~=(nil)then
             local interruptedWork=workInProgress.return_;
            while(interruptedWork)~=(nil)do
                 unwindInterruptedWork(interruptedWork);
                interruptedWork=interruptedWork.return_
             end
         end;
        workInProgressRoot=root;
        workInProgress=ReactFiber.createWorkInProgress(root.current,nil);
        workInProgressRootRenderLanes=lanes;
        exports.subtreeRenderLanes=lanes;
        workInProgressRootIncludedLanes=lanes;
        workInProgressRootExitStatus=RootExitStatus.Incomplete;
        workInProgressRootFatalError=nil;
        workInProgressRootSkippedLanes(ReactFiberLane.NoLanes);
        workInProgressRootUpdatedLanes=ReactFiberLane.NoLanes;
        workInProgressRootPingedLanes=ReactFiberLane.NoLanes;
        if ReactFeatureFlags.enableSchedulerTracing then
             spawnedWorkDuringRender=nil
         end;
        if __DEV__ then
             ReactStrictModeWarnings.discardPendingWarnings()
        end
     end;
    mod.handleError=function(root,thrownValue)
        while true do
             local erroredWork=workInProgress;
            local ok,yetAnotherThrownValue=pcall(function()
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentDebugFiberInDEV();
                ReactCurrentOwner.current=nil;
                if((erroredWork)==(nil))or((erroredWork.return_)==(nil))then
                     workInProgressRootExitStatus=RootExitStatus.FatalErrored;
                    workInProgressRootFatalError=thrownValue;
                    workInProgress=nil;
                    return
                 end;
                if(ReactFeatureFlags.enableProfilerTimer)and((bit32.band((erroredWork).mode,ReactTypeOfMode.ProfileMode))~=(0))then
                     ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(erroredWork,true)
                end;
                throwException(root,(erroredWork).return_,erroredWork,thrownValue,workInProgressRootRenderLanes,exports.onUncaughtError,exports.renderDidError);
                mod.completeUnitOfWork(erroredWork)
            end);
            if not(ok)then
                 thrownValue=yetAnotherThrownValue;
                if((workInProgress)==(erroredWork))and((erroredWork)~=(nil))then
                     erroredWork=erroredWork.return_;
                    workInProgress=erroredWork
                 else
                     erroredWork=workInProgress
                 end;
                continue
             end;
            return
         end
     end;
    mod.pushDispatcher=function()
        local prevDispatcher=ReactCurrentDispatcher.current;
        ReactCurrentDispatcher.current=ContextOnlyDispatcher();
        if(prevDispatcher)==(nil)then
             return ContextOnlyDispatcher()
        else
             return prevDispatcher
         end
     end;
    mod.popDispatcher=function(prevDispatcher)
        ReactCurrentDispatcher.current=prevDispatcher
     end;
    mod.pushInteractions=function(root)
        if ReactFeatureFlags.enableSchedulerTracing then
             local prevInteractions=__interactionsRef.current;
            __interactionsRef.current=root.memoizedInteractions;
            return prevInteractions
         end;
        return nil
     end;
    mod.popInteractions=function(prevInteractions)
        if ReactFeatureFlags.enableSchedulerTracing then
             __interactionsRef.current=prevInteractions
         end
     end;
    exports.markCommitTimeOfFallback=function()
        globalMostRecentFallbackTime=now()
    end;
    exports.markSkippedUpdateLanes=function(lane)
        ReactFiberWorkInProgress.markSkippedUpdateLanes(lane)
    end;
    exports.renderDidSuspend=function()
        if(workInProgressRootExitStatus)==(RootExitStatus.Incomplete)then
             workInProgressRootExitStatus=RootExitStatus.Suspended
         end
     end;
    exports.renderDidSuspendDelayIfPossible=function()
        if((workInProgressRootExitStatus)==(RootExitStatus.Incomplete))or((workInProgressRootExitStatus)==(RootExitStatus.Suspended))then
             workInProgressRootExitStatus=RootExitStatus.SuspendedWithDelay
         end;
        if((workInProgressRoot)~=(nil))and(((includesNonIdleWork(workInProgressRootSkippedLanes()))or(includesNonIdleWork(workInProgressRootUpdatedLanes))))then
             mod.markRootSuspended(workInProgressRoot,workInProgressRootRenderLanes)
        end
     end;
    exports.renderDidError=function()
        if(workInProgressRootExitStatus)~=(RootExitStatus.Completed)then
             workInProgressRootExitStatus=RootExitStatus.Errored
         end
     end;
    exports.renderHasNotSuspendedYet=function()
        return(workInProgressRootExitStatus)==(RootExitStatus.Incomplete)
    end;
    mod.renderRootSync=function(root,lanes)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,RenderContext);
        local prevDispatcher=mod.pushDispatcher();
        if((workInProgressRoot)~=(root))or((workInProgressRootRenderLanes)~=(lanes))then
             mod.prepareFreshStack(root,lanes);
            mod.startWorkOnPendingInteractions(root,lanes)
        end;
        local prevInteractions=mod.pushInteractions(root);
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logRenderStarted(lanes)
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markRenderStarted(lanes)
        end;
        while true do
             local ok,thrownValue;
            if not(__YOLO__)then
                 ok,thrownValue=xpcall(mod.workLoopSync,describeError)
            else
                 ok=true;
                mod.workLoopSync()
            end;
            if not(ok)then
                 mod.handleError(root,thrownValue)
            else
                 break
             end
         end;
        resetContextDependencies();
        if ReactFeatureFlags.enableSchedulerTracing then
             mod.popInteractions(prevInteractions)
        end;
        executionContext=prevExecutionContext;
        mod.popDispatcher(prevDispatcher);
        if(workInProgress)~=(nil)then
             invariant(false,"Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.")
        end;
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logRenderStopped()
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markRenderStopped()
        end;
        workInProgressRoot=nil;
        workInProgressRootRenderLanes=ReactFiberLane.NoLanes;
        return workInProgressRootExitStatus
     end;
    mod.workLoopSync=function()
        while(workInProgress)~=(nil)do
             mod.performUnitOfWork(workInProgress)
        end
     end;
    mod.renderRootConcurrent=function(root,lanes)
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,RenderContext);
        local prevDispatcher=mod.pushDispatcher();
        if((workInProgressRoot)~=(root))or((workInProgressRootRenderLanes)~=(lanes))then
             resetRenderTimer();
            mod.prepareFreshStack(root,lanes);
            mod.startWorkOnPendingInteractions(root,lanes)
        end;
        local prevInteractions=mod.pushInteractions(root);
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logRenderStarted(lanes)
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markRenderStarted(lanes)
        end;
        while true do
             local ok,thrownValue;
            if not(__YOLO__)then
                 ok,thrownValue=xpcall(mod.workLoopConcurrent,describeError);
                if ok then
                     thrownValue="break"
                end
             else
                 ok=true;
                thrownValue="break";
                mod.workLoopConcurrent()
            end;
            if(thrownValue)==("break")then
                 break
             end;
            if not(ok)then
                 mod.handleError(root,thrownValue)
            end
         end;
        resetContextDependencies();
        if ReactFeatureFlags.enableSchedulerTracing then
             mod.popInteractions(prevInteractions)
        end;
        mod.popDispatcher(prevDispatcher);
        executionContext=prevExecutionContext;
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logRenderStopped()
            end
         end;
        if(workInProgress)~=(nil)then
             if enableSchedulingProfiler then
                 SchedulingProfiler.markRenderYielded()
            end;
            return RootExitStatus.Incomplete
         else
             if enableSchedulingProfiler then
                 SchedulingProfiler.markRenderStopped()
            end;
            workInProgressRoot=nil;
            workInProgressRootRenderLanes=ReactFiberLane.NoLanes;
            return workInProgressRootExitStatus
         end
     end;
    mod.workLoopConcurrent=function()
        while((workInProgress)~=(nil))and(not(shouldYield()))do
             mod.performUnitOfWork(workInProgress)
        end
     end;
    mod.performUnitOfWork=function(unitOfWork)
        local profileRunning=RobloxReactProfiling.profileUnitOfWorkBefore(unitOfWork);
        local current=unitOfWork.alternate;
        setCurrentDebugFiberInDEV(unitOfWork);
        local next_;
        if(ReactFeatureFlags.enableProfilerTimer)and((bit32.band(unitOfWork.mode,ReactTypeOfMode.ProfileMode))~=(ReactTypeOfMode.NoMode))then
             ReactProfilerTimer.startProfilerTimer(unitOfWork);
            next_=mod.beginWork(current,unitOfWork,exports.subtreeRenderLanes);
            ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true)
        else
             next_=mod.beginWork(current,unitOfWork,exports.subtreeRenderLanes)
        end;
        resetCurrentDebugFiberInDEV();
        unitOfWork.memoizedProps=unitOfWork.pendingProps;
        if(next_)==(nil)then
             mod.completeUnitOfWork(unitOfWork)
        else
             workInProgress=next_
         end;
        ReactCurrentOwner.current=nil;
        RobloxReactProfiling.profileUnitOfWorkAfter(profileRunning)
    end;
    mod.completeUnitOfWork=function(unitOfWork)
        local completedWork=unitOfWork;
        repeat
             local current=completedWork.alternate;
            local returnFiber=completedWork.return_;
            if(bit32.band(completedWork.flags,ReactFiberFlags.Incomplete))==(ReactFiberFlags.NoFlags)then
                 setCurrentDebugFiberInDEV(completedWork);
                local next_;
                if(not(ReactFeatureFlags.enableProfilerTimer))or((bit32.band(completedWork.mode,ReactTypeOfMode.ProfileMode))==(ReactTypeOfMode.NoMode))then
                     next_=completeWork(current,completedWork,exports.subtreeRenderLanes)
                else
                     ReactProfilerTimer.startProfilerTimer(completedWork);
                    next_=completeWork(current,completedWork,exports.subtreeRenderLanes);
                    ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(completedWork,false)
                end;
                resetCurrentDebugFiberInDEV();
                if(next_)~=(nil)then
                     workInProgress=next_;
                    return
                 end
             else
                 local next_=unwindWork(completedWork,exports.subtreeRenderLanes);
                if(next_)~=(nil)then
                     next_.flags=bit32.band(next_.flags,ReactFiberFlags.HostEffectMask);
                    workInProgress=next_;
                    return
                 end;
                if(ReactFeatureFlags.enableProfilerTimer)and((bit32.band(completedWork.mode,ReactTypeOfMode.ProfileMode))~=(ReactTypeOfMode.NoMode))then
                     ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);
                    local actualDuration=(completedWork.actualDuration)or(0);
                    local child=completedWork.child;
                    while(child)~=(nil)do
                         actualDuration+=(child.actualDuration)or(0);
                        child=child.sibling
                     end;
                    completedWork.actualDuration=actualDuration
                 end;
                if(returnFiber)~=(nil)then
                     returnFiber.flags=bit32.bor(returnFiber.flags,ReactFiberFlags.Incomplete);
                    returnFiber.subtreeFlags=ReactFiberFlags.NoFlags;
                    returnFiber.deletions=nil
                 end
             end;
            local siblingFiber=completedWork.sibling;
            if(siblingFiber)~=(nil)then
                 workInProgress=siblingFiber;
                return
             end;
            completedWork=returnFiber;
            workInProgress=completedWork
         until(completedWork)==(nil);
        if(workInProgressRootExitStatus)==(RootExitStatus.Incomplete)then
             workInProgressRootExitStatus=RootExitStatus.Completed
         end
     end;
    mod.commitRoot=function(root)
        local renderPriorityLevel=getCurrentPriorityLevel();
        runWithPriority(ImmediateSchedulerPriority,function()
            RobloxReactProfiling.profileCommitBefore();
            local ret=mod.commitRootImpl(root,renderPriorityLevel);
            RobloxReactProfiling.profileCommitAfter();
            return ret
         end);
        return nil
     end;
    mod.commitRootImpl=function(root,renderPriorityLevel)
        repeat
             exports.flushPassiveEffects()
        until(rootWithPendingPassiveEffects)==(nil);
        flushRenderPhaseStrictModeWarningsInDEV();
        invariant((bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext),"Should not already be working.");
        local finishedWork=root.finishedWork;
        local lanes=root.finishedLanes;
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logCommitStarted(lanes)
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markCommitStarted(lanes)
        end;
        if(finishedWork)==(nil)then
             if __DEV__ then
                 if enableDebugTracing then
                     DebugTracing.logCommitStopped()
                end
             end;
            if enableSchedulingProfiler then
                 SchedulingProfiler.markCommitStopped()
            end;
            return nil
         end;
        root.finishedWork=nil;
        root.finishedLanes=ReactFiberLane.NoLanes;
        invariant((finishedWork)~=(root.current),"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        root.callbackNode=nil;
        local remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);
        markRootFinished(root,remainingLanes);
        if(rootsWithPendingDiscreteUpdates)~=(nil)then
             if(not(hasDiscreteLanes(remainingLanes)))and(rootsWithPendingDiscreteUpdates:has(root))then
                 rootsWithPendingDiscreteUpdates:delete(root)
            end
         end;
        if(root)==(workInProgressRoot)then
             workInProgressRoot=nil;
            workInProgress=nil;
            workInProgressRootRenderLanes=ReactFiberLane.NoLanes
         end;
        local subtreeHasEffects=(bit32.band(finishedWork.subtreeFlags,bit32.bor(ReactFiberFlags.BeforeMutationMask,ReactFiberFlags.MutationMask,ReactFiberFlags.LayoutMask,ReactFiberFlags.PassiveMask)))~=(ReactFiberFlags.NoFlags);
        local rootHasEffect=(bit32.band(finishedWork.flags,bit32.bor(ReactFiberFlags.BeforeMutationMask,ReactFiberFlags.MutationMask,ReactFiberFlags.LayoutMask,ReactFiberFlags.PassiveMask)))~=(ReactFiberFlags.NoFlags);
        if(subtreeHasEffects)or(rootHasEffect)then
             local previousLanePriority;
            if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
                 previousLanePriority=getCurrentUpdateLanePriority();
                setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
            end;
            local prevExecutionContext=executionContext;
            executionContext=bit32.bor(executionContext,CommitContext);
            local prevInteractions=mod.pushInteractions(root);
            ReactCurrentOwner.current=nil;
            focusedInstanceHandle=ReactFiberHostConfig.prepareForCommit(root.containerInfo);
            shouldFireAfterActiveInstanceBlur=false;
            mod.commitBeforeMutationEffects(finishedWork);
            focusedInstanceHandle=nil;
            if ReactFeatureFlags.enableProfilerTimer then
                 ReactProfilerTimer.recordCommitTime()
            end;
            mod.commitMutationEffects(finishedWork,root,renderPriorityLevel);
            if shouldFireAfterActiveInstanceBlur then
                 ReactFiberHostConfig.afterActiveInstanceBlur()
            end;
            ReactFiberHostConfig.resetAfterCommit(root.containerInfo);
            root.current=finishedWork;
            if __DEV__ then
                 if enableDebugTracing then
                     DebugTracing.logLayoutEffectsStarted(lanes)
                end
             end;
            if enableSchedulingProfiler then
                 SchedulingProfiler.markLayoutEffectsStarted(lanes)
            end;
            if __DEV__ then
                 setCurrentDebugFiberInDEV(finishedWork);
                invokeGuardedCallback(nil,recursivelyCommitLayoutEffects,nil,finishedWork,root,exports.captureCommitPhaseError,exports.schedulePassiveEffectCallback);
                if hasCaughtError()then
                     local err=clearCaughtError();
                    captureCommitPhaseErrorOnRoot(finishedWork,finishedWork,err)
                end;
                resetCurrentDebugFiberInDEV()
            else
                 local ok,result;
                if not(__YOLO__)then
                     ok,result=xpcall(recursivelyCommitLayoutEffects,describeError,finishedWork,root,exports.captureCommitPhaseError,exports.schedulePassiveEffectCallback)
                else
                     ok=true;
                    recursivelyCommitLayoutEffects(finishedWork,root,exports.captureCommitPhaseError,exports.schedulePassiveEffectCallback)
                end;
                if not(ok)then
                     captureCommitPhaseErrorOnRoot(finishedWork,finishedWork,result)
                end
             end;
            if __DEV__ then
                 if enableDebugTracing then
                     DebugTracing.logLayoutEffectsStopped()
                end
             end;
            if enableSchedulingProfiler then
                 SchedulingProfiler.markLayoutEffectsStopped()
            end;
            if((bit32.band(finishedWork.subtreeFlags,ReactFiberFlags.PassiveMask))~=(ReactFiberFlags.NoFlags))or((bit32.band(finishedWork.flags,ReactFiberFlags.PassiveMask))~=(ReactFiberFlags.NoFlags))then
                 if not(rootDoesHavePassiveEffects)then
                     rootDoesHavePassiveEffects=true;
                    scheduleCallback(NormalSchedulerPriority,function()
                        exports.flushPassiveEffects();
                        return nil
                     end)
                end
             end;
            requestPaint();
            if ReactFeatureFlags.enableSchedulerTracing then
                 mod.popInteractions(prevInteractions)
            end;
            executionContext=prevExecutionContext;
            if(ReactFeatureFlags.decoupleUpdatePriorityFromScheduler)and((previousLanePriority)~=(nil))then
                 setCurrentUpdateLanePriority(previousLanePriority)
            end
         else
             root.current=finishedWork;
            if ReactFeatureFlags.enableProfilerTimer then
                 ReactProfilerTimer.recordCommitTime()
            end
         end;
        local rootDidHavePassiveEffects=rootDoesHavePassiveEffects;
        if rootDoesHavePassiveEffects then
             rootDoesHavePassiveEffects=false;
            rootWithPendingPassiveEffects=root;
            pendingPassiveEffectsLanes=lanes;
            pendingPassiveEffectsRenderPriority=renderPriorityLevel
         end;
        remainingLanes=root.pendingLanes;
        if(remainingLanes)~=(ReactFiberLane.NoLanes)then
             if ReactFeatureFlags.enableSchedulerTracing then
                 if(spawnedWorkDuringRender)~=(nil)then
                     local expirationTimes=spawnedWorkDuringRender;
                    spawnedWorkDuringRender=nil;
                    for i=1,#(expirationTimes)do
                         scheduleInteractions(root,expirationTimes[i],root.memoizedInteractions)
                    end
                 end;
                mod.schedulePendingInteractions(root,remainingLanes)
            end
         else
             legacyErrorBoundariesThatAlreadyFailed=nil
         end;
        if(__DEV__)and(enableDoubleInvokingEffects)then
             if not(rootDidHavePassiveEffects)then
                 commitDoubleInvokeEffectsInDEV(root.current,false)
            end
         end;
        if ReactFeatureFlags.enableSchedulerTracing then
             if not(rootDidHavePassiveEffects)then
                 mod.finishPendingInteractions(root,lanes)
            end
         end;
        if(remainingLanes)==(SyncLane)then
             if(root)==(rootWithNestedUpdates)then
                 nestedUpdateCount+=1
             else
                 nestedUpdateCount=0;
                rootWithNestedUpdates=root
             end
         else
             nestedUpdateCount=0
         end;
        onCommitRootDevTools(finishedWork.stateNode,renderPriorityLevel);
        if __DEV__ then
             onCommitRootTestSelector()
        end;
        ensureRootIsScheduled(root,now());
        if hasUncaughtError then
             hasUncaughtError=false;
            local error_=firstUncaughtError;
            firstUncaughtError=nil;
            error(error_)
        end;
        if(bit32.band(executionContext,LegacyUnbatchedContext))~=(NoContext)then
             if __DEV__ then
                 if enableDebugTracing then
                     DebugTracing.logCommitStopped()
                end
             end;
            if enableSchedulingProfiler then
                 SchedulingProfiler.markCommitStopped()
            end;
            return nil
         end;
        flushSyncCallbackQueue();
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logCommitStopped()
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markCommitStopped()
        end;
        return nil
     end;
    mod.commitBeforeMutationEffects=function(firstChild)
        local fiber=firstChild;
        while(fiber)~=(nil)do
             if(fiber.deletions)~=(nil)then
                 mod.commitBeforeMutationEffectsDeletions(fiber.deletions)
            end;
            if(fiber.child)~=(nil)then
                 local primarySubtreeFlags=bit32.band(fiber.subtreeFlags,ReactFiberFlags.BeforeMutationMask);
                if(primarySubtreeFlags)~=(ReactFiberFlags.NoFlags)then
                     mod.commitBeforeMutationEffects(fiber.child)
                end
             end;
            if __DEV__ then
                 setCurrentDebugFiberInDEV(fiber);
                invokeGuardedCallback(nil,mod.commitBeforeMutationEffectsImpl,nil,fiber);
                if hasCaughtError()then
                     local error_=clearCaughtError();
                    exports.captureCommitPhaseError(fiber,fiber.return_,error_)
                end;
                resetCurrentDebugFiberInDEV()
            else
                 local ok,error_;
                if not(__YOLO__)then
                     ok,error_=xpcall(mod.commitBeforeMutationEffectsImpl,describeError,fiber)
                else
                     ok=true;
                    mod.commitBeforeMutationEffectsImpl(fiber)
                end;
                if not(ok)then
                     exports.captureCommitPhaseError(fiber,fiber.return_,error_)
                end
             end;
            fiber=fiber.sibling
         end
     end;
    mod.commitBeforeMutationEffectsImpl=function(fiber)
        local current=fiber.alternate;
        local flags=fiber.flags;
        if(not(shouldFireAfterActiveInstanceBlur))and((focusedInstanceHandle)~=(nil))then
             if(((fiber.tag)==(ReactWorkTags.SuspenseComponent))and(ReactFiberCommitWork.isSuspenseBoundaryBeingHidden(current,fiber)))and(doesFiberContain(fiber,focusedInstanceHandle))then
                 shouldFireAfterActiveInstanceBlur=true;
                ReactFiberHostConfig.beforeActiveInstanceBlur()
            end
         end;
        if(bit32.band(flags,ReactFiberFlags.Snapshot))~=(ReactFiberFlags.NoFlags)then
             setCurrentDebugFiberInDEV(fiber);
            commitBeforeMutationEffectOnFiber(current,fiber);
            resetCurrentDebugFiberInDEV()
        end;
        if(bit32.band(flags,ReactFiberFlags.Passive))~=(ReactFiberFlags.NoFlags)then
             if not(rootDoesHavePassiveEffects)then
                 rootDoesHavePassiveEffects=true;
                scheduleCallback(NormalSchedulerPriority,function()
                    exports.flushPassiveEffects();
                    return nil
                 end)
            end
         end
     end;
    mod.commitBeforeMutationEffectsDeletions=function(deletions)
        for i=1,#(deletions)do
             local fiber=deletions[i];
            if doesFiberContain(fiber,(focusedInstanceHandle))then
                 shouldFireAfterActiveInstanceBlur=true;
                ReactFiberHostConfig.beforeActiveInstanceBlur()
            end
         end
     end;
    mod.commitMutationEffects=function(firstChild,root,renderPriorityLevel)
        local fiber=firstChild;
        while(fiber)~=(nil)do
             local deletions=fiber.deletions;
            if(deletions)~=(nil)then
                 for _,childToDelete in deletions do
                     local ok,error_=xpcall(commitDeletion,describeError,root,childToDelete,fiber,renderPriorityLevel);
                    if not(ok)then
                         exports.captureCommitPhaseError(childToDelete,fiber,error_)
                    end
                 end
             end;
            if(fiber.child)~=(nil)then
                 local mutationFlags=bit32.band(fiber.subtreeFlags,ReactFiberFlags.MutationMask);
                if(mutationFlags)~=(ReactFiberFlags.NoFlags)then
                     mod.commitMutationEffects(fiber.child,root,renderPriorityLevel)
                end
             end;
            if __DEV__ then
                 setCurrentDebugFiberInDEV(fiber);
                invokeGuardedCallback(nil,mod.commitMutationEffectsImpl,nil,fiber,root,renderPriorityLevel);
                if hasCaughtError()then
                     local error_=clearCaughtError();
                    exports.captureCommitPhaseError(fiber,fiber.return_,error_)
                end;
                resetCurrentDebugFiberInDEV()
            else
                 local ok,result;
                if not(__YOLO__)then
                     ok,result=xpcall(mod.commitMutationEffectsImpl,describeError,fiber,root,renderPriorityLevel)
                else
                     ok=true;
                    mod.commitMutationEffectsImpl(fiber,root,renderPriorityLevel)
                end;
                if not(ok)then
                     exports.captureCommitPhaseError(fiber,fiber.return_,result)
                end
             end;
            fiber=fiber.sibling
         end
     end;
    mod.commitMutationEffectsImpl=function(fiber,root,renderPriorityLevel)
        local flags=fiber.flags;
        if(bit32.band(flags,ReactFiberFlags.Ref))~=(0)then
             local current=fiber.alternate;
            if(current)~=(nil)then
                 commitDetachRef(current)
            end
         end;
        local primaryFlags=bit32.band(flags,bit32.bor(ReactFiberFlags.Placement,ReactFiberFlags.Update,ReactFiberFlags.Hydrating));
        if(primaryFlags)==(ReactFiberFlags.Placement)then
             commitPlacement(fiber);
            fiber.flags=bit32.band(fiber.flags,bit32.bnot(ReactFiberFlags.Placement))
        elseif(primaryFlags)==(ReactFiberFlags.PlacementAndUpdate)then
             commitPlacement(fiber);
            fiber.flags=bit32.band(fiber.flags,bit32.bnot(ReactFiberFlags.Placement));
            local current=fiber.alternate;
            commitWork(current,fiber)
        elseif(primaryFlags)==(ReactFiberFlags.Update)then
             local current=fiber.alternate;
            commitWork(current,fiber)
        end
     end;
    mod.commitMutationEffectsDeletions=function(deletions,fiber,root,renderPriorityLevel)
        for _,childToDelete in deletions do
             local ok,error_=xpcall(commitDeletion,describeError,root,childToDelete,fiber,renderPriorityLevel);
            if not(ok)then
                 exports.captureCommitPhaseError(childToDelete,fiber,error_)
            end
         end
     end;
    exports.schedulePassiveEffectCallback=function()
        if not(rootDoesHavePassiveEffects)then
             rootDoesHavePassiveEffects=true;
            scheduleCallback(NormalSchedulerPriority,function()
                exports.flushPassiveEffects();
                return nil
             end)
        end
     end;
    local flushPassiveEffectsImpl;
    exports.flushPassiveEffects=function()
        if(pendingPassiveEffectsRenderPriority)~=(NoSchedulerPriority)then
             local priorityLevel=if(pendingPassiveEffectsRenderPriority)>(NormalSchedulerPriority)then NormalSchedulerPriority else pendingPassiveEffectsRenderPriority;
            pendingPassiveEffectsRenderPriority=NoSchedulerPriority;
            if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
                 local previousLanePriority=getCurrentUpdateLanePriority();
                setCurrentUpdateLanePriority(schedulerPriorityToLanePriority(priorityLevel));
                local ok,result;
                if not(__YOLO__)then
                     ok,result=xpcall(runWithPriority,describeError,priorityLevel,flushPassiveEffectsImpl)
                else
                     ok=true;
                    setCurrentUpdateLanePriority(schedulerPriorityToLanePriority(priorityLevel));
                    result=runWithPriority(priorityLevel,flushPassiveEffectsImpl)
                end;
                setCurrentUpdateLanePriority(previousLanePriority);
                if not(ok)then
                     error(result)
                end;
                return result
             else
                 return runWithPriority(priorityLevel,flushPassiveEffectsImpl)
            end
         end;
        return false
     end;
    flushPassiveMountEffects=function(root,firstChild)
        local fiber=firstChild;
        while(fiber)~=(nil)do
             local prevProfilerOnStack;
            if(ReactFeatureFlags.enableProfilerTimer)and(ReactFeatureFlags.enableProfilerCommitHooks)then
                 if(fiber.tag)==(ReactWorkTags.Profiler)then
                     prevProfilerOnStack=nearestProfilerOnStack;
                    nearestProfilerOnStack=fiber
                 end
             end;
            local primarySubtreeFlags=bit32.band(fiber.subtreeFlags,ReactFiberFlags.PassiveMask);
            if((fiber.child)~=(nil))and((primarySubtreeFlags)~=(ReactFiberFlags.NoFlags))then
                 flushPassiveMountEffects(root,fiber.child)
            end;
            if(bit32.band(fiber.flags,ReactFiberFlags.Passive))~=(ReactFiberFlags.NoFlags)then
                 if __DEV__ then
                     setCurrentDebugFiberInDEV(fiber);
                    invokeGuardedCallback(nil,commitPassiveMountOnFiber,nil,root,fiber);
                    if hasCaughtError()then
                         local error_=clearCaughtError();
                        exports.captureCommitPhaseError(fiber,fiber.return_,error_)
                    end;
                    resetCurrentDebugFiberInDEV()
                else
                     local ok,error_;
                    if not(__YOLO__)then
                         ok,error_=xpcall(commitPassiveMountOnFiber,describeError,root,fiber)
                    else
                         ok=true;
                        commitPassiveMountOnFiber(root,fiber)
                    end;
                    if not(ok)then
                         exports.captureCommitPhaseError(fiber,fiber.return_,error_)
                    end
                 end
             end;
            if(ReactFeatureFlags.enableProfilerTimer)and(ReactFeatureFlags.enableProfilerCommitHooks)then
                 if(fiber.tag)==(ReactWorkTags.Profiler)then
                     if(prevProfilerOnStack)~=(nil)then
                         prevProfilerOnStack.stateNode.passiveEffectDuration+=fiber.stateNode.passiveEffectDuration
                     end;
                    nearestProfilerOnStack=prevProfilerOnStack
                 end
             end;
            fiber=fiber.sibling
         end
     end;
    local function flushPassiveUnmountEffects(firstChild)
        local fiber=firstChild;
        while(fiber)~=(nil)do
             local deletions=fiber.deletions;
            if(deletions)~=(nil)then
                 for i=1,#(deletions)do
                     local fiberToDelete=deletions[i];
                    mod.flushPassiveUnmountEffectsInsideOfDeletedTree(fiberToDelete,fiber);
                    mod.detachFiberAfterEffects(fiberToDelete)
                end
             end;
            local child=fiber.child;
            if(child)~=(nil)then
                 local passiveFlags=bit32.band(fiber.subtreeFlags,ReactFiberFlags.PassiveMask);
                if(passiveFlags)~=(ReactFiberFlags.NoFlags)then
                     flushPassiveUnmountEffects(child)
                end
             end;
            local primaryFlags=bit32.band(fiber.flags,ReactFiberFlags.Passive);
            if(primaryFlags)~=(ReactFiberFlags.NoFlags)then
                 setCurrentDebugFiberInDEV(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentDebugFiberInDEV()
            end;
            fiber=fiber.sibling
         end
     end;
    mod.flushPassiveUnmountEffectsInsideOfDeletedTree=function(fiberToDelete,nearestMountedAncestor)
        if(bit32.band(fiberToDelete.subtreeFlags,ReactFiberFlags.PassiveStatic))~=(ReactFiberFlags.NoFlags)then
             local child=fiberToDelete.child;
            while(child)~=(nil)do
                 mod.flushPassiveUnmountEffectsInsideOfDeletedTree(child,nearestMountedAncestor);
                child=child.sibling
             end
         end;
        if(bit32.band(fiberToDelete.flags,ReactFiberFlags.PassiveStatic))~=(ReactFiberFlags.NoFlags)then
             setCurrentDebugFiberInDEV(fiberToDelete);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiberToDelete,nearestMountedAncestor);
            resetCurrentDebugFiberInDEV()
        end
     end;
    flushPassiveEffectsImpl=function()
        if(rootWithPendingPassiveEffects)==(nil)then
             return false
         end;
        local root=rootWithPendingPassiveEffects;
        local lanes=pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects=nil;
        pendingPassiveEffectsLanes=ReactFiberLane.NoLanes;
        invariant((bit32.band(executionContext,bit32.bor(RenderContext,CommitContext)))==(NoContext),"Cannot flush passive effects while already rendering.");
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logPassiveEffectsStarted(lanes)
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markPassiveEffectsStarted(lanes)
        end;
        local prevExecutionContext=executionContext;
        executionContext=bit32.bor(executionContext,CommitContext);
        local prevInteractions=mod.pushInteractions(root);
        flushPassiveUnmountEffects(root.current);
        flushPassiveMountEffects(root,root.current);
        if __DEV__ then
             if enableDebugTracing then
                 DebugTracing.logPassiveEffectsStopped()
            end
         end;
        if enableSchedulingProfiler then
             SchedulingProfiler.markPassiveEffectsStopped()
        end;
        if(__DEV__)and(enableDoubleInvokingEffects)then
             commitDoubleInvokeEffectsInDEV(root.current,true)
        end;
        if ReactFeatureFlags.enableSchedulerTracing then
             mod.popInteractions(prevInteractions);
            mod.finishPendingInteractions(root,lanes)
        end;
        executionContext=prevExecutionContext;
        flushSyncCallbackQueue();
        if(rootWithPendingPassiveEffects)==(nil)then
             nestedPassiveUpdateCount=0
         else
             nestedPassiveUpdateCount=(nestedPassiveUpdateCount)+(1)
        end;
        return true
     end;
    exports.isAlreadyFailedLegacyErrorBoundary=function(instance)
        return((legacyErrorBoundariesThatAlreadyFailed)~=(nil))and(legacyErrorBoundariesThatAlreadyFailed:has(instance))
    end;
    exports.markLegacyErrorBoundaryAsFailed=function(instance)
        if(legacyErrorBoundariesThatAlreadyFailed)==(nil)then
             legacyErrorBoundariesThatAlreadyFailed=Set.new({instance})
        else
             legacyErrorBoundariesThatAlreadyFailed:add(instance)
        end
     end;
    local function prepareToThrowUncaughtError(error_)
        if not(hasUncaughtError)then
             hasUncaughtError=true;
            firstUncaughtError=error_
         end
     end;
    exports.onUncaughtError=prepareToThrowUncaughtError;
    captureCommitPhaseErrorOnRoot=function(rootFiber,sourceFiber,error_)
        local errorInfo=createCapturedValue(error_,sourceFiber);
        local update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane,exports.onUncaughtError);
        enqueueUpdate(rootFiber,update);
        local eventTime=exports.requestEventTime();
        local root=mod.markUpdateLaneFromFiberToRoot(rootFiber,SyncLane);
        if(root)~=(nil)then
             markRootUpdated(root,SyncLane,eventTime);
            ensureRootIsScheduled(root,eventTime);
            mod.schedulePendingInteractions(root,SyncLane)
        end
     end;
    exports.captureCommitPhaseError=function(sourceFiber,nearestMountedAncestor,error_)
        if(sourceFiber.tag)==(ReactWorkTags.HostRoot)then
             captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error_);
            return
         end;
        local fiber;
        if skipUnmountedBoundaries then
             fiber=nearestMountedAncestor
         else
             fiber=sourceFiber.return_
         end;
        while(fiber)~=(nil)do
             if(fiber.tag)==(ReactWorkTags.HostRoot)then
                 captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error_);
                return
             else
                 if(fiber.tag)==(ReactWorkTags.ClassComponent)then
                     local ctor=fiber.type;
                    local instance=fiber.stateNode;
                    if((typeof(ctor.getDerivedStateFromError))==("function"))or((((typeof(instance.componentDidCatch))==("function"))and(not(exports.isAlreadyFailedLegacyErrorBoundary(instance)))))then
                         local errorInfo=createCapturedValue(error_,sourceFiber);
                        local update=createClassErrorUpdate(fiber,errorInfo,SyncLane);
                        enqueueUpdate(fiber,update);
                        local eventTime=exports.requestEventTime();
                        local root=mod.markUpdateLaneFromFiberToRoot(fiber,SyncLane);
                        if(root)~=(nil)then
                             markRootUpdated(root,SyncLane,eventTime);
                            ensureRootIsScheduled(root,eventTime);
                            mod.schedulePendingInteractions(root,SyncLane)
                        end;
                        return
                     end
                 end;
                fiber=fiber.return_
             end
         end
     end;
    exports.pingSuspendedRoot=function(root,wakeable,pingedLanes)
        local pingCache=root.pingCache;
        if(pingCache)~=(nil)then
             pingCache[wakeable]=nil
         end;
        local eventTime=exports.requestEventTime();
        markRootPinged(root,pingedLanes,eventTime);
        if((workInProgressRoot)==(root))and(isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes))then
             if((workInProgressRootExitStatus)==(RootExitStatus.SuspendedWithDelay))or((((workInProgressRootExitStatus)==(RootExitStatus.Suspended))and(includesOnlyRetries(workInProgressRootRenderLanes)))and(((now())-(globalMostRecentFallbackTime))<(FALLBACK_THROTTLE_MS)))then
                 mod.prepareFreshStack(root,ReactFiberLane.NoLanes)
            else
                 workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes)
            end
         end;
        ensureRootIsScheduled(root,eventTime);
        mod.schedulePendingInteractions(root,pingedLanes)
    end;
    function retryTimedOutBoundary(boundaryFiber,retryLane)
        if(retryLane)==(ReactFiberLane.NoLane)then
             retryLane=requestRetryLane(boundaryFiber)
        end;
        local eventTime=exports.requestEventTime();
        local root=mod.markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);
        if(root)~=(nil)then
             markRootUpdated(root,retryLane,eventTime);
            ensureRootIsScheduled(root,eventTime);
            mod.schedulePendingInteractions(root,retryLane)
        end
     end;
    exports.resolveRetryWakeable=function(boundaryFiber,wakeable)
        local retryLane=ReactFiberLane.NoLane;
        local retryCache;
        retryCache=boundaryFiber.stateNode;
        if(retryCache)~=(nil)then
             retryCache:delete(wakeable)
        end;
        retryTimedOutBoundary(boundaryFiber,retryLane)
    end;
    function jnd(timeElapsed)
        if(timeElapsed)<(120)then
             return 120
         elseif(timeElapsed)<(480)then
             return 480
         elseif(timeElapsed)<(1080)then
             return 1080
         elseif(timeElapsed)<(1920)then
             return 1920
         elseif(timeElapsed)<(3000)then
             return 3000
         elseif(timeElapsed)<(4320)then
             return 4320
         else
             return(math.ceil((timeElapsed)/(1960)))*(1960)
        end
     end;
    mod.checkForNestedUpdates=function()
        if(nestedUpdateCount)>(NESTED_UPDATE_LIMIT)then
             nestedUpdateCount=0;
            rootWithNestedUpdates=nil;
            invariant(false,"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.")
        end;
        if __DEV__ then
             if(nestedPassiveUpdateCount)>(NESTED_PASSIVE_UPDATE_LIMIT)then
                 nestedPassiveUpdateCount=0;
                console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")
            end
         end
     end;
    function flushRenderPhaseStrictModeWarningsInDEV()
        if __DEV__ then
             ReactStrictModeWarnings.flushLegacyContextWarning();
            if ReactFeatureFlags.warnAboutDeprecatedLifecycles then
                 ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()
            end
         end
     end;
    function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             setCurrentDebugFiberInDEV(fiber);
            invokeEffectsInDev(fiber,ReactFiberFlags.MountLayoutDev,invokeLayoutEffectUnmountInDEV);
            if hasPassiveEffects then
                 invokeEffectsInDev(fiber,ReactFiberFlags.MountPassiveDev,invokePassiveEffectUnmountInDEV)
            end;
            invokeEffectsInDev(fiber,ReactFiberFlags.MountLayoutDev,invokeLayoutEffectMountInDEV);
            if hasPassiveEffects then
                 invokeEffectsInDev(fiber,ReactFiberFlags.MountPassiveDev,invokePassiveEffectMountInDEV)
            end;
            resetCurrentDebugFiberInDEV()
        end
     end;
    function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             local fiber=firstChild;
            while(fiber)~=(nil)do
                 if(fiber.child)~=(nil)then
                     local primarySubtreeFlag=bit32.band(fiber.subtreeFlags,fiberFlags);
                    if(primarySubtreeFlag)~=(ReactFiberFlags.NoFlags)then
                         invokeEffectsInDev(fiber.child,fiberFlags,invokeEffectFn)
                    end
                 end;
                if(bit32.band(fiber.flags,fiberFlags))~=(ReactFiberFlags.NoFlags)then
                     invokeEffectFn(fiber)
                end;
                fiber=fiber.sibling
             end
         end
     end;
    local didWarnStateUpdateForNotYetMountedComponent;
    mod.warnAboutUpdateOnNotYetMountedFiberInDEV=function(fiber)
        if __DEV__ then
             if(bit32.band(executionContext,RenderContext))~=(NoContext)then
                 return
             end;
            if(bit32.band(fiber.mode,bit32.bor(ReactTypeOfMode.BlockingMode,ReactTypeOfMode.ConcurrentMode)))==(0)then
                 return
             end;
            local tag=fiber.tag;
            if((((((((tag)~=(ReactWorkTags.IndeterminateComponent))and((tag)~=(ReactWorkTags.HostRoot)))and((tag)~=(ReactWorkTags.ClassComponent)))and((tag)~=(ReactWorkTags.FunctionComponent)))and((tag)~=(ReactWorkTags.ForwardRef)))and((tag)~=(ReactWorkTags.MemoComponent)))and((tag)~=(ReactWorkTags.SimpleMemoComponent)))and((tag)~=(ReactWorkTags.Block))then
                 return
             end;
            local componentName=(getComponentName(fiber.type))or("ReactComponent");
            if(didWarnStateUpdateForNotYetMountedComponent)~=(nil)then
                 if didWarnStateUpdateForNotYetMountedComponent[componentName]then
                     return
                 end;
                didWarnStateUpdateForNotYetMountedComponent[componentName]=true
             else
                 didWarnStateUpdateForNotYetMountedComponent={[componentName]=true}
            end;
            local previousFiber=ReactCurrentFiber.current;
            local ok,result=pcall(function()
                setCurrentDebugFiberInDEV(fiber);
                console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.")
            end);
            if previousFiber then
                 setCurrentDebugFiberInDEV(fiber)
            else
                 resetCurrentDebugFiberInDEV()
            end;
            if not(ok)then
                 error(result)
            end
         end
     end;
    if(__DEV__)and(ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback)then
         local dummyFiber;
        mod.beginWork=function(current,unitOfWork,lanes)
            local originalWorkInProgressCopy=ReactFiber.assignFiberPropertiesInDEV(dummyFiber,unitOfWork);
            local ok,result=xpcall(originalBeginWork,describeError,current,unitOfWork,lanes);
            if not(ok)then
                 local originalError=result;
                if(((originalError)~=(nil))and((typeof(originalError))==("table")))and((typeof(originalError.andThen))==("function"))then
                     error(originalError)
                end;
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(unitOfWork);
                ReactFiber.assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);
                if(ReactFeatureFlags.enableProfilerTimer)and((bit32.band(unitOfWork.mode,ReactTypeOfMode.ProfileMode))~=(0))then
                     ReactProfilerTimer.startProfilerTimer(unitOfWork)
                end;
                invokeGuardedCallback(nil,originalBeginWork,nil,current,unitOfWork,lanes);
                if hasCaughtError()then
                     local replayError=clearCaughtError();
                    error(replayError)
                else
                     error(originalError)
                end
             end;
            return result
         end
     else
         mod.beginWork=originalBeginWork
     end;
    local didWarnAboutUpdateInRender=false;
    local didWarnAboutUpdateInRenderForAnotherComponent;
    if __DEV__ then
         didWarnAboutUpdateInRenderForAnotherComponent={}
    end;
    mod.warnAboutRenderPhaseUpdatesInDEV=function(fiber)
        if __DEV__ then
             if((ReactCurrentFiber.isRendering)and((bit32.band(executionContext,RenderContext))~=(NoContext)))and(not(getIsUpdatingOpaqueValueInRenderPhaseInDEV()))then
                 if(((fiber.tag)==(ReactWorkTags.FunctionComponent))or((fiber.tag)==(ReactWorkTags.ForwardRef)))or((fiber.tag)==(ReactWorkTags.SimpleMemoComponent))then
                     local renderingComponentName=(function()
                        if(workInProgress)~=(nil)then
                             return getComponentName((workInProgress).type)
                        end;
                        return"Unknown"
                    end)();
                    local dedupeKey=renderingComponentName;
                    if(didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey])==(nil)then
                         didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey]=true;
                        local setStateComponentName=(getComponentName(fiber.type))or("Unknown");
                        console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render",setStateComponentName,renderingComponentName,renderingComponentName)
                    end
                 elseif(fiber.tag)==(ReactWorkTags.ClassComponent)then
                     if not(didWarnAboutUpdateInRender)then
                         console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                        didWarnAboutUpdateInRender=true
                     end
                 end
             end
         end
     end;
    exports.IsThisRendererActing={["current"]=false};
    exports.warnIfNotScopedWithMatchingAct=function(fiber)
        if __DEV__ then
             if(((ReactFiberHostConfig.warnsIfNotActing)==(true))and((IsSomeRendererActing.current)==(true)))and((exports.IsThisRendererActing.current)~=(true))then
                 local previousFiber=ReactCurrentFiber.current;
                local ok,result=pcall(function()
                    setCurrentDebugFiberInDEV(fiber);
                    console.error("It looks like you're using the wrong act() around your test interactions.\x0aBe sure to use the matching version of act() corresponding to your renderer:\x0a\x0a-- for react-roblox:\x0alocal React = require(Packages.React)\x0a-- ...\x0aReact.TestUtils.act(function() ... end)\x0a\x0a-- for react-test-renderer:\x0alocal TestRenderer = require(Packages.ReactTestRenderer)\x0a-- ...\x0aTestRenderer.act(function() ... end)")
                end);
                if previousFiber then
                     setCurrentDebugFiberInDEV(fiber)
                else
                     resetCurrentDebugFiberInDEV()
                end;
                if not(ok)then
                     error(result)
                end
             end
         end
     end;
    exports.warnIfNotCurrentlyActingEffectsInDEV=function(fiber)
        if __DEV__ then
             if((((ReactFiberHostConfig.warnsIfNotActing)==(true))and((bit32.band(fiber.mode,ReactTypeOfMode.StrictMode))~=(ReactTypeOfMode.NoMode)))and((IsSomeRendererActing.current)==(false)))and((exports.IsThisRendererActing.current)==(false))then
                 console.error("An update to %s ran an effect, but was not wrapped in act(...).\x0a\x0aWhen testing, code that causes React state updates should be wrapped into act(...):\x0a\x0aact(function()\x0a  --[[ fire events that update state ]]\x0aend)\x0a--[[ assert on the output ]]\x0a\x0aThis ensures that you're testing the behavior the user would see in the real client. Learn more at https://reactjs.org/link/wrap-tests-with-act",getComponentName(fiber.type))
            end
         end
     end;
    exports.warnIfNotCurrentlyActingUpdatesInDEV=function(fiber)
        if __DEV__ then
             if((((ReactFiberHostConfig.warnsIfNotActing)==(true))and((executionContext)==(NoContext)))and((IsSomeRendererActing.current)==(false)))and((exports.IsThisRendererActing.current)==(false))then
                 local previousFiber=ReactCurrentFiberCurrent;
                local ok,result=pcall(function()
                    setCurrentDebugFiberInDEV(fiber);
                    console.error("An update to %s inside a test was not wrapped in act(...).\x0a\x0aWhen testing, code that causes React state updates should be wrapped into act(...):\x0a\x0aact(function()\x0a  --[[ fire events that update state ]]\x0aend)\x0a--[[ assert on the output ]]\x0a\x0aThis ensures that you're testing the behavior the user would see in the client application. Learn more at https://reactjs.org/link/wrap-tests-with-act",getComponentName(fiber.type))
                end);
                if previousFiber then
                     setCurrentDebugFiberInDEV(fiber)
                else
                     resetCurrentDebugFiberInDEV()
                end;
                if ok then
                     return result
                 end
             end
         end;
        return
     end;
    local didWarnAboutUnmockedScheduler=false;
    exports.warnIfUnmockedScheduler=function(fiber)
        if __DEV__ then
             if((didWarnAboutUnmockedScheduler)==(false))and((Scheduler.unstable_flushAllWithoutAsserting)==(nil))then
                 if((bit32.band(fiber.mode,ReactTypeOfMode.BlockingMode))~=(0))or((bit32.band(fiber.mode,ReactTypeOfMode.ConcurrentMode))~=(0))then
                     didWarnAboutUnmockedScheduler=true;
                    console.error("In Concurrent or Sync modes, the 'scheduler' module needs to be mocked to guarantee consistent behaviour across tests and client application. For example, with Jest: \x0ajest.mock('scheduler', function() return require(@pkg/scheduler).unstable_mock end)\x0a\x0aFor more info, visit https://reactjs.org/link/mock-scheduler")
                elseif(ReactFeatureFlags.warnAboutUnmockedScheduler)==(true)then
                     didWarnAboutUnmockedScheduler=true;
                    console.error("Starting from React v18, the 'scheduler' module will need to be mocked to guarantee consistent behaviour across tests and client applications. For example, with Jest: \x0ajest.mock('scheduler', function() return require(@pkg/scheduler).unstable_mock end)\x0a\x0aFor more info, visit https://reactjs.org/link/mock-scheduler")
                end
             end
         end
     end;
    function computeThreadID(root,lane)
        return((lane)*(1000))+(root.interactionThreadID)
    end;
    exports.markSpawnedWork=function(lane)
        if not(ReactFeatureFlags.enableSchedulerTracing)then
             return
         end;
        if(spawnedWorkDuringRender)==(nil)then
             spawnedWorkDuringRender={lane}
        else
             table.insert(spawnedWorkDuringRender,lane)
        end
     end;
    function scheduleInteractions(root,lane,interactions)
        if not(ReactFeatureFlags.enableSchedulerTracing)then
             return
         end;
        if(interactions.size)>(0)then
             local pendingInteractionMap=root.pendingInteractionMap;
            local pendingInteractions=pendingInteractionMap:get(lane);
            if(pendingInteractions)~=(nil)then
                 interactions:forEach(function(interaction)
                    if not(pendingInteractions:has(interaction))then
                         interaction.__count+=1
                     end;
                    pendingInteractions:add(interaction)
                end)
            else
                 pendingInteractionMap:set(lane,Set.new(interactions));
                for _,interaction in interactions do
                     interaction.__count+=1
                 end
             end;
            local subscriber=__subscriberRef.current;
            if(subscriber)~=(nil)then
                 local threadID=computeThreadID(root,lane);
                subscriber.onWorkScheduled(interactions,threadID)
            end
         end
     end;
    mod.schedulePendingInteractions=function(root,lane)
        if not(ReactFeatureFlags.enableSchedulerTracing)then
             return
         end;
        scheduleInteractions(root,lane,__interactionsRef.current)
    end;
    mod.startWorkOnPendingInteractions=function(root,lanes)
        if not(ReactFeatureFlags.enableSchedulerTracing)then
             return
         end;
        local interactions=Set.new();
        root.pendingInteractionMap:forEach(function(scheduledInteractions,scheduledLane)
            if includesSomeLane(lanes,scheduledLane)then
                 scheduledInteractions:forEach(function(interaction)
                    interactions:add(interaction)
                end)
            end
         end);
        root.memoizedInteractions=interactions;
        if(interactions.size)>(0)then
             local subscriber=__subscriberRef.current;
            if(subscriber)~=(nil)then
                 local threadID=computeThreadID(root,lanes);
                local ok,error_=xpcall(subscriber.onWorkStarted,describeError,interactions,threadID);
                if not(ok)then
                     scheduleCallback(ImmediateSchedulerPriority,function()
                        error(error_)
                    end)
                end
             end
         end
     end;
    mod.finishPendingInteractions=function(root,committedLanes)
        if not(ReactFeatureFlags.enableSchedulerTracing)then
             return
         end;
        local remainingLanesAfterCommit=root.pendingLanes;
        local subscriber;
        local ok=true;
        local error_;
        if((subscriber)~=(nil))and((root.memoizedInteractions.size)>(0))then
             local threadID=computeThreadID(root,committedLanes);
            subscriber=__subscriberRef.current;
            ok,error_=xpcall(subscriber.onWorkStopped,describeError,root.memoizedInteractions,threadID)
        end;
        local pendingInteractionMap=root.pendingInteractionMap;
        pendingInteractionMap:forEach(function(scheduledInteractions,lane)
            if not(includesSomeLane(remainingLanesAfterCommit,lane))then
                 pendingInteractionMap:delete(lane);
                scheduledInteractions:forEach(function(interaction)
                    interaction.__count-=1;
                    if((subscriber)~=(nil))and((interaction.__count)==(0))then
                         local ok_,error__=xpcall(subscriber.onInteractionScheduledWorkCompleted,describeError,interaction);
                        if not(ok_)then
                             scheduleCallback(ImmediateSchedulerPriority,function()
                                error(error__)
                            end)
                        end
                     end
                 end)
            end
         end);
        if not(ok)then
             scheduleCallback(ImmediateSchedulerPriority,function()
                error(error_)
            end)
        end
     end;
    local isFlushingAct=false;
    local isInsideThisAct=false;
    local flushMockScheduler=Scheduler.unstable_flushAllWithoutAsserting;
    local isSchedulerMocked=(typeof(flushMockScheduler))==("function");
    local function flushActWork()
        if(flushMockScheduler)~=(nil)then
             local prevIsFlushing=isFlushingAct;
            isFlushingAct=true;
            local ok,result=xpcall(flushMockScheduler,describeError);
            isFlushingAct=prevIsFlushing;
            if not(ok)then
                 error(result)
            else
                 return result
             end
         else
             local prevIsFlushing=isFlushingAct;
            isFlushingAct=true;
            local ok,result=xpcall(function()
                local didFlushWork=false;
                while exports.flushPassiveEffects()do
                     didFlushWork=true
                 end;
                return didFlushWork
             end,describeError);
            isFlushingAct=prevIsFlushing;
            if not(ok)then
                 error(result)
            else
                 return result
             end
         end
     end;
    local function flushWorkAndMicroTasks(onDone)
        local ok,result=xpcall(flushActWork,describeError);
        if ok then
             ok,result=xpcall(enqueueTask,describeError,function()
                if flushActWork()then
                     flushWorkAndMicroTasks(onDone)
                else
                     onDone()
                end
             end)
        end;
        if not(ok)then
             onDone(result)
        end
     end;
    exports.act=function(callback)
        if not(((__DEV__)or(_G.__ROACT_17_MOCK_SCHEDULER__)))then
             if(didWarnAboutUsingActInProd)==(false)then
                 didWarnAboutUsingActInProd=true;
                console.error("act(...) is not supported in production builds of React, and might not behave as expected.")
            end
         end;
        local previousActingUpdatesScopeDepth=actingUpdatesScopeDepth;
        actingUpdatesScopeDepth+=1;
        local previousIsSomeRendererActing=IsSomeRendererActing.current;
        local previousIsThisRendererActing=exports.IsThisRendererActing.current;
        local previousIsInsideThisAct=isInsideThisAct;
        IsSomeRendererActing.current=true;
        exports.IsThisRendererActing.current=true;
        isInsideThisAct=true;
        local function onDone()
            actingUpdatesScopeDepth-=1;
            IsSomeRendererActing.current=previousIsSomeRendererActing;
            exports.IsThisRendererActing.current=previousIsThisRendererActing;
            isInsideThisAct=previousIsInsideThisAct;
            if __DEV__ then
                 if(actingUpdatesScopeDepth)>(previousActingUpdatesScopeDepth)then
                     console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ")
                end
             end
         end;
        local ok,result=xpcall(exports.batchedUpdates,describeError,callback);
        if not(ok)then
             onDone();
            error(result)
        end;
        if(((result)~=(nil))and((typeof(result))==("table")))and((typeof(result.andThen))==("function"))then
             local called=false;
            if __DEV__ then
                 if(typeof(Promise))~=(nil)then
                     Promise.resolve():andThen(function()
                        
                    end):andThen(function()
                        if(called)==(false)then
                             console.error("You called act(Promise.new(function() --[[ ... ]] end)) without :await() or :expect(). This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - act(function() Promise.new(function() --[[ ... ]] end):await() end);")
                        end
                     end)
                end
             end;
            return{["andThen"]=function(self,resolve,reject)
                called=true;
                return result:andThen(function()
                    if((actingUpdatesScopeDepth)>(1))or((((isSchedulerMocked)==(true))and((previousIsSomeRendererActing)==(true))))then
                         onDone();
                        resolve();
                        return
                     end;
                    flushWorkAndMicroTasks(function(err)
                        onDone();
                        if err then
                             reject(err)
                        else
                             resolve()
                        end
                     end)
                end,function(err)
                    onDone();
                    reject(err)
                end)
            end}
        else
             if __DEV__ then
                 if(result)~=(nil)then
                     console.error("The callback passed to act(...) function must return nil, or a Promise. You returned %s",tostring(result))
                end
             end;
            local flushOk,flushResult=xpcall(function()
                if((actingUpdatesScopeDepth)==(1))and((((isSchedulerMocked)==(false))or((previousIsSomeRendererActing)==(false))))then
                     flushActWork()
                end;
                onDone()
            end,describeError);
            if not(flushOk)then
                 onDone();
                error(flushResult)
            end;
            return{["andThen"]=function(self,resolve,reject_)
                if __DEV__ then
                     console.error("Do not await the result of calling act(...) with sync logic, it is not a Promise.")
                end;
                resolve()
            end}
        end
     end;
    mod.detachFiberAfterEffects=function(fiber)
        fiber.child=nil;
        fiber.deletions=nil;
        fiber.dependencies=nil;
        fiber.memoizedProps=nil;
        fiber.memoizedState=nil;
        fiber.pendingProps=nil;
        fiber.sibling=nil;
        fiber.stateNode=nil;
        fiber.updateQueue=nil;
        if __DEV__ then
             fiber._debugOwner=nil
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactUpdateQueue.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new",function()
    local __DEV__=_G.__DEV__;
    local __YOLO__=_G.__YOLO__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    local NoLane=ReactFiberLane.NoLane;
    local NoLanes=ReactFiberLane.NoLanes;
    local isSubsetOfLanes=ReactFiberLane.isSubsetOfLanes;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local ReactFiberNewContext;
    local function enterDisallowedContextReadInDEV()
        if not(ReactFiberNewContext)then
             ReactFiberNewContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new")
        end;
        ReactFiberNewContext.enterDisallowedContextReadInDEV()
    end;
    local function exitDisallowedContextReadInDEV()
        if not(ReactFiberNewContext)then
             ReactFiberNewContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new")
        end;
        ReactFiberNewContext.exitDisallowedContextReadInDEV()
    end;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local Callback=ReactFiberFlags.Callback;
    local ShouldCapture=ReactFiberFlags.ShouldCapture;
    local DidCapture=ReactFiberFlags.DidCapture;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local debugRenderPhaseSideEffectsForStrictMode=ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode;
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local StrictMode=ReactTypeOfMode.StrictMode;
    local markSkippedUpdateLanes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkInProgress").markSkippedUpdateLanes;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ConsolePatchingDev=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ConsolePatchingDev;
    local disableLogs=ConsolePatchingDev.disableLogs;
    local reenableLogs=ConsolePatchingDev.reenableLogs;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    local UpdateState=0;
    exports.UpdateState=UpdateState;
    local ReplaceState=1;
    exports.ReplaceState=ReplaceState;
    local ForceUpdate=2;
    exports.ForceUpdate=ForceUpdate;
    local CaptureUpdate=3;
    exports.CaptureUpdate=CaptureUpdate;
    local hasForceUpdate=false;
    local didWarnUpdateInsideUpdate;
    local currentlyProcessingQueue;
    if __DEV__ then
         didWarnUpdateInsideUpdate=false;
        currentlyProcessingQueue=nil;
        exports.resetCurrentlyProcessingQueue=function()
            currentlyProcessingQueue=nil
         end
     end;
    local poolInitSize=210;
    local updatePool=table.create(poolInitSize);
    local updatePoolIndex=poolInitSize;
    for i=1,poolInitSize do
         updatePool[i]={["eventTime"]=-(1),["lane"]=-(1),["tag"]=-(1),["payload"]=nil,["callback"]=nil,["next"]=nil}
    end;
    local function initializeUpdateQueue(fiber)
        local queue={["baseState"]=fiber.memoizedState,["firstBaseUpdate"]=nil,["lastBaseUpdate"]=nil,["shared"]={["pending"]=nil},["effects"]=nil};
        fiber.updateQueue=queue
     end;
    exports.initializeUpdateQueue=initializeUpdateQueue;
    local function cloneUpdateQueue(current,workInProgress)
        local queue=workInProgress.updateQueue;
        local currentQueue=current.updateQueue;
        if(queue)==(currentQueue)then
             local clone=table.clone(currentQueue);
            workInProgress.updateQueue=clone
         end
     end;
    exports.cloneUpdateQueue=cloneUpdateQueue;
    local function createUpdate(eventTime,lane,payload,callback)
        if(updatePoolIndex)>(0)then
             local update=updatePool[updatePoolIndex];
            updatePool[updatePoolIndex]=nil;
            updatePoolIndex-=1;
            update.eventTime=eventTime;
            update.lane=lane;
            update.tag=UpdateState;
            update.payload=payload;
            update.callback=callback;
            return update
         end;
        local update={["eventTime"]=eventTime,["lane"]=lane,["tag"]=UpdateState,["payload"]=payload,["callback"]=callback,["next"]=nil};
        return update
     end;
    exports.createUpdate=createUpdate;
    local function enqueueUpdate(fiber,update)
        local updateQueue=fiber.updateQueue;
        if(updateQueue)==(nil)then
             return
         end;
        local sharedQueue=(updateQueue).shared;
        local pending=sharedQueue.pending;
        if(pending)==(nil)then
             update.next=update
         else
             update.next=pending.next;
            pending.next=update
         end;
        sharedQueue.pending=update;
        if __DEV__ then
             if((currentlyProcessingQueue)==(sharedQueue))and(not(didWarnUpdateInsideUpdate))then
                 console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate=true
             end
         end
     end;
    exports.enqueueUpdate=enqueueUpdate;
    local function enqueueCapturedUpdate(workInProgress,capturedUpdate)
        local queue=workInProgress.updateQueue;
        local current=workInProgress.alternate;
        if(current)~=(nil)then
             local currentQueue=current.updateQueue;
            if(queue)==(currentQueue)then
                 local newFirst;
                local newLast;
                local firstBaseUpdate=queue.firstBaseUpdate;
                if(firstBaseUpdate)~=(nil)then
                     local update=firstBaseUpdate;
                    repeat
                         local clone={["eventTime"]=update.eventTime,["lane"]=update.lane,["tag"]=update.tag,["payload"]=update.payload,["callback"]=update.callback,["next"]=nil};
                        if(newLast)==(nil)then
                             newLast=clone;
                            newFirst=clone
                         else
                             newLast.next=clone;
                            newLast=clone
                         end;
                        update=update.next
                     until(update)==(nil);
                    if(newLast)==(nil)then
                         newLast=capturedUpdate;
                        newFirst=capturedUpdate
                     else
                         newLast.next=capturedUpdate;
                        newLast=capturedUpdate
                     end
                 else
                     newLast=capturedUpdate;
                    newFirst=capturedUpdate
                 end;
                queue={["baseState"]=currentQueue.baseState,["firstBaseUpdate"]=newFirst,["lastBaseUpdate"]=newLast,["shared"]=currentQueue.shared,["effects"]=currentQueue.effects};
                workInProgress.updateQueue=queue;
                return
             end
         end;
        local lastBaseUpdate=queue.lastBaseUpdate;
        if(lastBaseUpdate)==(nil)then
             queue.firstBaseUpdate=capturedUpdate
         else
             lastBaseUpdate.next=capturedUpdate
         end;
        queue.lastBaseUpdate=capturedUpdate
     end;
    exports.enqueueCapturedUpdate=enqueueCapturedUpdate;
    local function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance)
        local updateTag=update.tag;
        if(updateTag)==(ReplaceState)then
             local payload=update.payload;
            if(type(payload))==("function")then
                 if __DEV__ then
                     enterDisallowedContextReadInDEV()
                end;
                local nextState=payload(prevState,nextProps);
                if __DEV__ then
                     if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                         disableLogs();
                        local ok,result;
                        if not(__YOLO__)then
                             ok,result=xpcall(payload,describeError,prevState,nextProps)
                        else
                             ok=true;
                            payload(prevState,nextProps)
                        end;
                        reenableLogs();
                        if not(ok)then
                             error(result)
                        end
                     end;
                    exitDisallowedContextReadInDEV()
                end;
                return nextState
             end;
            return payload
         elseif((updateTag)==(CaptureUpdate))or((updateTag)==(UpdateState))then
             if(updateTag)==(CaptureUpdate)then
                 workInProgress.flags=bit32.bor(bit32.band(workInProgress.flags,bit32.bnot(ShouldCapture)),DidCapture)
            end;
            local payload=update.payload;
            local partialState;
            if(type(payload))==("function")then
                 if __DEV__ then
                     enterDisallowedContextReadInDEV()
                end;
                partialState=payload(prevState,nextProps);
                if __DEV__ then
                     if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                         disableLogs();
                        local ok,result;
                        if not(__YOLO__)then
                             ok,result=xpcall(payload,describeError,prevState,nextProps)
                        else
                             ok=true;
                            payload(prevState,nextProps)
                        end;
                        reenableLogs();
                        if not(ok)then
                             error(result)
                        end
                     end;
                    exitDisallowedContextReadInDEV()
                end
             else
                 partialState=payload
             end;
            if(partialState)==(nil)then
                 return prevState
             end;
            return Object.assign({},prevState,partialState)
        elseif(updateTag)==(ForceUpdate)then
             hasForceUpdate=true;
            return prevState
         end;
        return prevState
     end;
    exports.getStateFromUpdate=getStateFromUpdate;
    local function processUpdateQueue(workInProgress,props,instance,renderLanes)
        local queue=workInProgress.updateQueue;
        hasForceUpdate=false;
        if __DEV__ then
             currentlyProcessingQueue=queue.shared
         end;
        local firstBaseUpdate=queue.firstBaseUpdate;
        local lastBaseUpdate=queue.lastBaseUpdate;
        local pendingQueue=queue.shared.pending;
        if(pendingQueue)~=(nil)then
             queue.shared.pending=nil;
            local lastPendingUpdate=pendingQueue;
            local firstPendingUpdate=lastPendingUpdate.next;
            lastPendingUpdate.next=nil;
            if(lastBaseUpdate)==(nil)then
                 firstBaseUpdate=firstPendingUpdate
             else
                 lastBaseUpdate.next=firstPendingUpdate
             end;
            lastBaseUpdate=lastPendingUpdate;
            local current=workInProgress.alternate;
            if(current)~=(nil)then
                 local currentQueue=current.updateQueue;
                local currentLastBaseUpdate=currentQueue.lastBaseUpdate;
                if(currentLastBaseUpdate)~=(lastBaseUpdate)then
                     if(currentLastBaseUpdate)==(nil)then
                         currentQueue.firstBaseUpdate=firstPendingUpdate
                     else
                         currentLastBaseUpdate.next=firstPendingUpdate
                     end;
                    currentQueue.lastBaseUpdate=lastPendingUpdate
                 end
             end
         end;
        if(firstBaseUpdate)~=(nil)then
             local newState=queue.baseState;
            local newLanes=NoLanes;
            local newBaseState;
            local newFirstBaseUpdate;
            local newLastBaseUpdate;
            local update=firstBaseUpdate;
            while true do
                 local updateLane=update.lane;
                local updateEventTime=update.eventTime;
                if not(isSubsetOfLanes(renderLanes,updateLane))then
                     local clone={["eventTime"]=updateEventTime,["lane"]=updateLane,["tag"]=update.tag,["payload"]=update.payload,["callback"]=update.callback,["next"]=nil};
                    if(newLastBaseUpdate)==(nil)then
                         newFirstBaseUpdate=clone;
                        newLastBaseUpdate=clone;
                        newBaseState=newState
                     else
                         newLastBaseUpdate.next=clone;
                        newLastBaseUpdate=clone
                     end;
                    newLanes=mergeLanes(newLanes,updateLane)
                else
                     if(newLastBaseUpdate)~=(nil)then
                         local clone={["eventTime"]=updateEventTime,["lane"]=NoLane,["tag"]=update.tag,["payload"]=update.payload,["callback"]=update.callback,["next"]=nil};
                        newLastBaseUpdate.next=clone;
                        newLastBaseUpdate=clone
                     end;
                    newState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);
                    local callback=update.callback;
                    if((callback)~=(nil))and((update.lane)~=(NoLane))then
                         workInProgress.flags=bit32.bor(workInProgress.flags,Callback);
                        local effects=queue.effects;
                        if(effects)==(nil)then
                             queue.effects={update}
                        else
                             table.insert(effects,update)
                        end
                     end
                 end;
                update=update.next;
                if(update)==(nil)then
                     pendingQueue=queue.shared.pending;
                    if(pendingQueue)==(nil)then
                         break
                     else
                         local lastPendingUpdate=pendingQueue;
                        local firstPendingUpdate=(lastPendingUpdate.next);
                        lastPendingUpdate.next=nil;
                        update=firstPendingUpdate;
                        queue.lastBaseUpdate=lastPendingUpdate;
                        queue.shared.pending=nil
                     end
                 end
             end;
            if(newLastBaseUpdate)==(nil)then
                 newBaseState=newState
             end;
            queue.baseState=(newBaseState);
            queue.firstBaseUpdate=newFirstBaseUpdate;
            queue.lastBaseUpdate=newLastBaseUpdate;
            markSkippedUpdateLanes(newLanes);
            workInProgress.lanes=newLanes;
            workInProgress.memoizedState=newState
         end;
        if __DEV__ then
             currentlyProcessingQueue=nil
         end
     end;
    exports.processUpdateQueue=processUpdateQueue;
    local function callCallback(callback,context)
        if(type(callback))~=("function")then
             error(string.format("Invalid argument passed as callback. Expected a function. Instead received: %s",tostring(callback)))
        end;
        callback(context)
    end;
    exports.resetHasForceUpdateBeforeProcessing=function()
        hasForceUpdate=false
     end;
    exports.checkHasForceUpdateAfterProcessing=function()
        return hasForceUpdate
     end;
    local function commitUpdateQueue(finishedWork,finishedQueue,instance)
        local effects=finishedQueue.effects;
        finishedQueue.effects=nil;
        if(effects)~=(nil)then
             for _,effect in effects do
                 local callback=effect.callback;
                if(callback)~=(nil)then
                     callCallback(callback,instance)
                end;
                table.clear(effect);
                table.insert(updatePool,effect);
                updatePoolIndex+=1
             end
         end
     end;
    exports.commitUpdateQueue=commitUpdateQueue;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactCurrentFiber.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber",function()
    local __DEV__=_G.__DEV__;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local ReactFiberComponentStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberComponentStack");
    local getStackByFiberInDevAndProd=ReactFiberComponentStack.getStackByFiberInDevAndProd;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;
    type("not printable... yet");
    local exports={["current"]=nil,["isRendering"]=false};
    exports.getCurrentFiberOwnerNameInDevOrNull=function()
        if __DEV__ then
             if(exports.current)==(nil)then
                 return nil
             end;
            local owner=(exports.current)._debugOwner;
            if owner then
                 return getComponentName(owner.type)
            end
         end;
        return nil
     end;
    local function getCurrentFiberStackInDev()
        if __DEV__ then
             if(exports.current)==(nil)then
                 return""
            end;
            return getStackByFiberInDevAndProd(exports.current)
        end;
        return""
    end;
    exports.resetCurrentFiber=function()
        if __DEV__ then
            (ReactDebugCurrentFrame).getCurrentStack=nil;
            exports.current=nil;
            exports.isRendering=false
         end
     end;
    exports.setCurrentFiber=function(fiber)
        if __DEV__ then
            (ReactDebugCurrentFrame).getCurrentStack=getCurrentFiberStackInDev;
            exports.current=fiber;
            exports.isRendering=false
         end
     end;
    exports.setIsRendering=function(rendering)
        if __DEV__ then
             exports.isRendering=rendering
         end
     end;
    exports.getIsRendering=function()
        if __DEV__ then
             return exports.isRendering
         end;
        return false
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\SchedulingProfiler.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler",function()
    local exports={};
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local WeakMap=LuauPolyfill.WeakMap;
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulingProfiler=ReactFeatureFlags.enableSchedulingProfiler;
    local ReactVersion=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactVersion;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local supportsUserTiming=(_G.performance)~=(nil);
    local performance=(_G.performance)or({["mark"]=function(str)
        debug.profilebegin(str);
        debug.profileend()
    end});
    function formatLanes(laneOrLanes)
        return tostring(laneOrLanes)
    end;
    if enableSchedulingProfiler then
         if supportsUserTiming then
             performance.mark(("--react-init-")..(tostring(ReactVersion)))
        end
     end;
    exports.markCommitStarted=function(lanes)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark(("--commit-start-")..(formatLanes(lanes)))
            end
         end
     end;
    exports.markCommitStopped=function()
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark("--commit-stop")
            end
         end
     end;
    local wakeableIDs=WeakMap.new();
    local wakeableID=0;
    function getWakeableID(wakeable)
        if not(wakeableIDs:has(wakeable))then
             wakeableIDs:set(wakeable,wakeableID);
            wakeableID+=1
         end;
        return wakeableIDs:get(wakeable)
    end;
    exports.markComponentSuspended=function(fiber,wakeable)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 local id=getWakeableID(wakeable);
                local componentName=(getComponentName(fiber.type))or("Unknown");
                performance.mark(("--suspense-suspend-")..((tostring(id))..(("-")..(componentName))));
                wakeable:andThen(function()
                    performance.mark(("--suspense-resolved-")..((tostring(id))..(("-")..(componentName))))
                end,function()
                    performance.mark(("--suspense-rejected-")..((tostring(id))..(("-")..(componentName))))
                end)
            end
         end
     end;
    exports.markLayoutEffectsStarted=function(lanes)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark(("--layout-effects-start-")..(formatLanes(lanes)))
            end
         end
     end;
    exports.markLayoutEffectsStopped=function()
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark("--layout-effects-stop")
            end
         end
     end;
    exports.markPassiveEffectsStarted=function(lanes)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark(("--passive-effects-start-")..(formatLanes(lanes)))
            end
         end
     end;
    exports.markPassiveEffectsStopped=function()
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark("--passive-effects-stop")
            end
         end
     end;
    exports.markRenderStarted=function(lanes)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark(("--render-start-")..(formatLanes(lanes)))
            end
         end
     end;
    exports.markRenderYielded=function()
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark("--render-yield")
            end
         end
     end;
    exports.markRenderStopped=function()
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark("--render-stop")
            end
         end
     end;
    exports.markRenderScheduled=function(lane)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 performance.mark(("--schedule-render-")..(formatLanes(lane)))
            end
         end
     end;
    exports.markForceUpdateScheduled=function(fiber,lane)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 local componentName=(getComponentName(fiber.type))or("Unknown");
                performance.mark(("--schedule-forced-update-")..((formatLanes(lane))..(("-")..(componentName))))
            end
         end
     end;
    exports.markStateUpdateScheduled=function(fiber,lane)
        if enableSchedulingProfiler then
             if supportsUserTiming then
                 local componentName=(getComponentName(fiber.type))or("Unknown");
                performance.mark(("--schedule-state-update-")..((formatLanes(lane))..(("-")..(componentName))))
            end
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactPortal.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactPortal",function()
    local REACT_PORTAL_TYPE=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols.REACT_PORTAL_TYPE;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local function createPortal(children,containerInfo,implementation,key)
        if(key)~=(nil)then
             key=tostring(key)
        end;
        return{["\x24\x24typeof"]=REACT_PORTAL_TYPE,["key"]=key,["children"]=children,["containerInfo"]=containerInfo,["implementation"]=implementation}
    end;
    return{["createPortal"]=createPortal}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\RobloxReactProfiling.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.RobloxReactProfiling",function()
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local LEVEL_ROOTS=1;
    local LEVEL_FIBERS=10;
    local ReactMicroprofilerLevel=(_G.__REACT_MICROPROFILER_LEVEL)or(0);
    type("not printable... yet");
    type("not printable... yet");
    local enableRootSampling=false;
    local timerSamplingCallback;
    function startTimerSampling(timerSamplingCallbackFn)
        if enableRootSampling then
             warn("RobloxReactProfiling Timer Sampling already running.")
        end;
        enableRootSampling=true;
        timerSamplingCallback=timerSamplingCallbackFn
     end;
    function endTimerSampling()
        enableRootSampling=false;
        timerSamplingCallback=nil
     end;
    function getFirstStringKey(t)
        for key,_ in t do
             if(type(key))==("string")then
                 return key
             end
         end;
        return nil
     end;
    function startTimer(marker)
        if enableRootSampling then
             marker.startTime=os.clock()
        end
     end;
    function endTimer(marker)
        if enableRootSampling then
             marker.endTime=os.clock();
            if timerSamplingCallback then
                 timerSamplingCallback(marker)
            end
         end
     end;
    function profileRootBeforeUnitOfWork(root)
        local rootFiber=root.current;
        local profileId;
        if rootFiber then
             if rootFiber.memoizedProps then
                 profileId=getFirstStringKey(rootFiber.memoizedProps)
            end;
            if(((profileId)==(nil))and(rootFiber.stateNode))and(rootFiber.stateNode.containerInfo)then
                 profileId=rootFiber.stateNode.containerInfo.Name
             end
         end;
        if((profileId)==("Folder"))and(rootFiber.child)then
             local fiber=rootFiber.child;
            local folderProfileId;
            if fiber.memoizedProps then
                 folderProfileId=getFirstStringKey(fiber.memoizedProps)
            end;
            if(((folderProfileId)==(nil))and(fiber.stateNode))and(fiber.stateNode.containerInfo)then
                 folderProfileId=fiber.stateNode.containerInfo.Name
             end;
            if(folderProfileId)~=(nil)then
                 profileId=folderProfileId
             end
         end;
        if(profileId)~=(nil)then
             local marker={["id"]=profileId,["startTime"]=0,["endTime"]=0};
            startTimer(marker);
            debug.profilebegin(profileId);
            return marker
         end;
        return nil
     end;
    function profileRootAfterYielding(marker)
        if marker then
             endTimer(marker);
            debug.profileend()
        end
     end;
    function profileUnitOfWorkBefore(unitOfWork)
        local profileId=getComponentName(unitOfWork.type);
        if unitOfWork.key then
             profileId=(tostring(unitOfWork.key))..(("=")..(((profileId)or("?"))))
        end;
        local rootName;
        if unitOfWork.stateNode then
             if((unitOfWork.tag)==(ReactWorkTags.HostComponent))or((unitOfWork.tag)==(ReactWorkTags.HostText))then
                 local layerCollector=unitOfWork.stateNode:FindFirstAncestorWhichIsA("LayerCollector");
                if layerCollector then
                     rootName=("[")..((layerCollector:GetFullName())..("] "))
                end
             end
         end;
        if rootName then
             profileId=(rootName)..((" : ")..(((profileId)or("?"))))
        end;
        if(profileId)~=(nil)then
             debug.profilebegin(profileId);
            return true
         end;
        return false
     end;
    function profileUnitOfWorkAfter(profileRunning)
        if profileRunning then
             debug.profileend()
        end
     end;
    function profileCommitBefore()
        debug.profilebegin("Commit")
    end;
    function profileCommitAfter()
        debug.profileend()
    end;
    function noop(...)
        
    end;
    return{["startTimerSampling"]=startTimerSampling,["endTimerSampling"]=endTimerSampling,["profileRootBeforeUnitOfWork"]=if(ReactMicroprofilerLevel)>=(LEVEL_ROOTS)then profileRootBeforeUnitOfWork else noop,["profileRootAfterYielding"]=if(ReactMicroprofilerLevel)>=(LEVEL_ROOTS)then profileRootAfterYielding else noop,["profileUnitOfWorkBefore"]=if(ReactMicroprofilerLevel)>=(LEVEL_FIBERS)then profileUnitOfWorkBefore else noop,["profileUnitOfWorkAfter"]=if(ReactMicroprofilerLevel)>=(LEVEL_FIBERS)then profileUnitOfWorkAfter else noop,["profileCommitBefore"]=if(ReactMicroprofilerLevel)>=(LEVEL_ROOTS)then profileCommitBefore else noop,["profileCommitAfter"]=if(ReactMicroprofilerLevel)>=(LEVEL_ROOTS)then profileCommitAfter else noop}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\roblox\SingleEventManager.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.SingleEventManager",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").console;
    type("not printable... yet");
    local CHANGE_PREFIX="Change.";
    local EventStatus={["Disabled"]="Disabled",["Suspended"]="Suspended",["Enabled"]="Enabled"};
    type("not printable... yet");
    local SingleEventManager={};
    SingleEventManager.__index=SingleEventManager;
    function SingleEventManager.new(instance)
        local self=setmetatable({["_suspendedEventQueue"]={},["_connections"]={},["_listeners"]={},["_status"]=EventStatus.Disabled,["_isResuming"]=false,["_instance"]=instance},SingleEventManager);
        return(self)
    end;
    function SingleEventManager:connectEvent(key,listener)
        self:_connect(key,self._instance[key],listener)
    end;
    function SingleEventManager:connectPropertyChange(key,listener)
        local success,event=pcall(self._instance.GetPropertyChangedSignal,self._instance,key);
        if not(success)then
             error(string.format("Cannot get changed signal on property %q: %s",tostring(key),event),0)
        end;
        self:_connect((CHANGE_PREFIX)..(key),event,listener)
    end;
    function SingleEventManager:_connect(eventKey,event,listener)
        if(listener)==(nil)then
             if(self._connections[eventKey])~=(nil)then
                 self._connections[eventKey]:Disconnect();
                self._connections[eventKey]=nil
             end;
            self._listeners[eventKey]=nil
         else
             if(self._connections[eventKey])==(nil)then
                 self._connections[eventKey]=event:Connect(function(...)
                    if(self._status)==(EventStatus.Enabled)then
                         self._listeners[eventKey](self._instance,...)
                    elseif(self._status)==(EventStatus.Suspended)then
                         local argumentCount=select("\x23",...);
                        table.insert(self._suspendedEventQueue,{eventKey,argumentCount,...})
                    end
                 end)
            end;
            self._listeners[eventKey]=listener
         end
     end;
    function SingleEventManager:suspend()
        self._status=EventStatus.Suspended
     end;
    function SingleEventManager:resume()
        if self._isResuming then
             return
         end;
        self._isResuming=true;
        for _,eventInvocation in self._suspendedEventQueue do
             local listener=self._listeners[eventInvocation[1]];
            local argumentCount=eventInvocation[2];
            if(listener)~=(nil)then
                 local listenerCo=coroutine.create(listener);
                local success,result=coroutine.resume(listenerCo,self._instance,unpack(eventInvocation,3,(2)+(argumentCount)));
                if not(success)then
                     console.warn("%s",result)
                end
             end
         end;
        self._isResuming=false;
        self._status=EventStatus.Enabled;
        table.clear(self._suspendedEventQueue)
    end;
    return SingleEventManager

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-roblox@17.2.1\react-roblox\src\client\roblox\getDefaultInstanceProperty.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-roblox@17.2.1.react-roblox.client.roblox.getDefaultInstanceProperty",function()
    local Symbol=tkpack.include("game.Packages._Index.jsdotlua_react-roblox@17.2.1.shared").Symbol;
    local Nil=Symbol.named("Nil");
    local _cachedPropertyValues={};
    local function tryPropertyName(instance,propertyName)
        return instance[propertyName]
    end;
    local function getDefaultInstanceProperty(className,propertyName)
        local classCache=_cachedPropertyValues[className];
        if classCache then
             local propValue=classCache[propertyName];
            if(propValue)==(Nil)then
                 return true,nil
             end;
            if(propValue)~=(nil)then
                 return true,propValue
             end
         else
             classCache={};
            _cachedPropertyValues[className]=classCache
         end;
        local created=Instance.new(className);
        local ok,defaultValue=pcall(tryPropertyName,created,propertyName);
        created:Destroy();
        if ok then
             if(defaultValue)==(nil)then
                 classCache[propertyName]=Nil
             else
                 classCache[propertyName]=defaultValue
             end
         end;
        return ok,defaultValue
     end;
    return getDefaultInstanceProperty

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\instance-of.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.instance-of",function()
    return tkpack.include("game.Packages._Index.jsdotlua_instance-of@1.2.7.instance-of")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\from\fromSet.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromSet",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value,mapFn,thisArg)
        local array={};
        if mapFn then
             array={};
            for i,v in value do
                 if(thisArg)~=(nil)then
                    (array)[i]=(mapFn)(thisArg,v,i)
                else
                    (array)[i]=(mapFn)(v,i)
                end
             end
         else
             array=table.clone((value)._array)
        end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\from\fromMap.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromMap",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value,mapFn,thisArg)
        local array={};
        if mapFn then
             array={};
            for i,v in value do
                 if(thisArg)~=(nil)then
                    (array)[i]=(mapFn)(thisArg,v,i)
                else
                    (array)[i]=(mapFn)(v,i)
                end
             end
         else
             array={};
            for i,v in value do
                (array)[i]=v
             end
         end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_collections@1.2.7\collections\src\Array\from\fromArray.lua
 tkpack.declare("game.Packages._Index.jsdotlua_collections@1.2.7.collections.Array.from.fromArray",function()
    local types=tkpack.include("game.Packages._Index.jsdotlua_collections@1.2.7.es7-types");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return function(value,mapFn,thisArg)
        local array={};
        if mapFn then
             local arrayLength=#((value));
            array=table.create(arrayLength);
            for i=1,arrayLength do
                 if(thisArg)~=(nil)then
                    (array)[i]=(mapFn)(thisArg,(value)[i],i)
                else
                    (array)[i]=(mapFn)((value)[i],i)
                end
             end
         else
             array=table.clone(value)
        end;
        return array
     end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\Scheduler.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Scheduler",function()
    return function(hostConfig)
        local describeError=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").describeError;
        local SchedulerFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerFeatureFlags");
        local enableSchedulerDebugging=SchedulerFeatureFlags.enableSchedulerDebugging;
        local enableProfiling=SchedulerFeatureFlags.enableProfiling;
        local SchedulerHostConfig=(hostConfig)or(tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerHostConfig"));
        local requestHostCallback=SchedulerHostConfig.requestHostCallback;
        local requestHostTimeout=SchedulerHostConfig.requestHostTimeout;
        local cancelHostTimeout=SchedulerHostConfig.cancelHostTimeout;
        local shouldYieldToHost=SchedulerHostConfig.shouldYieldToHost;
        local getCurrentTime=SchedulerHostConfig.getCurrentTime;
        local forceFrameRate=SchedulerHostConfig.forceFrameRate;
        local requestPaint=SchedulerHostConfig.requestPaint;
        type("not printable... yet");
        type("not printable... yet");
        local compare,siftUp,siftDown;
        local push=function(heap,node)
            local index=(#(heap))+(1);
            heap[index]=node;
            siftUp(heap,node,index)
        end;
        local peek=function(heap)
            return heap[1]
        end;
        local pop=function(heap)
            local first=heap[1];
            if(first)~=(nil)then
                 local last=heap[#(heap)];
                heap[#(heap)]=nil;
                if(last)~=(first)then
                     heap[1]=last;
                    siftDown(heap,last,1)
                end;
                return first
             else
                 return nil
             end
         end;
        siftUp=function(heap,node,index)
            while true do
                 local parentIndex=math.floor((index)/(2));
                local parent=heap[parentIndex];
                if((parent)~=(nil))and((compare(parent,node))>(0))then
                     heap[parentIndex]=node;
                    heap[index]=parent;
                    index=parentIndex
                 else
                     return
                 end
             end
         end;
        siftDown=function(heap,node,index)
            local length=#(heap);
            while(index)<(length)do
                 local leftIndex=(index)*(2);
                local left=heap[leftIndex];
                local rightIndex=(leftIndex)+(1);
                local right=heap[rightIndex];
                if((left)~=(nil))and((compare(left,node))<(0))then
                     if((right)~=(nil))and((compare(right,left))<(0))then
                         heap[index]=right;
                        heap[rightIndex]=node;
                        index=rightIndex
                     else
                         heap[index]=left;
                        heap[leftIndex]=node;
                        index=leftIndex
                     end
                 elseif((right)~=(nil))and((compare(right,node))<(0))then
                     heap[index]=right;
                    heap[rightIndex]=node;
                    index=rightIndex
                 else
                     return
                 end
             end
         end;
        compare=function(a,b)
            local diff=(a.sortIndex)-(b.sortIndex);
            if(diff)==(0)then
                 return(a.id)-(b.id)
            end;
            return diff
         end;
        local SchedulerPriorities=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerPriorities");
        local ImmediatePriority=SchedulerPriorities.ImmediatePriority;
        local UserBlockingPriority=SchedulerPriorities.UserBlockingPriority;
        local NormalPriority=SchedulerPriorities.NormalPriority;
        local LowPriority=SchedulerPriorities.LowPriority;
        local IdlePriority=SchedulerPriorities.IdlePriority;
        local SchedulerProfiling=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerProfiling");
        local markTaskRun=SchedulerProfiling.markTaskRun;
        local markTaskYield=SchedulerProfiling.markTaskYield;
        local markTaskCompleted=SchedulerProfiling.markTaskCompleted;
        local markTaskCanceled=SchedulerProfiling.markTaskCanceled;
        local markTaskErrored=SchedulerProfiling.markTaskErrored;
        local markSchedulerSuspended=SchedulerProfiling.markSchedulerSuspended;
        local markSchedulerUnsuspended=SchedulerProfiling.markSchedulerUnsuspended;
        local markTaskStart=SchedulerProfiling.markTaskStart;
        local stopLoggingProfilingEvents=SchedulerProfiling.stopLoggingProfilingEvents;
        local startLoggingProfilingEvents=SchedulerProfiling.startLoggingProfilingEvents;
        local maxSigned31BitInt=1073741823;
        local IMMEDIATE_PRIORITY_TIMEOUT=-(1);
        local USER_BLOCKING_PRIORITY_TIMEOUT=250;
        local NORMAL_PRIORITY_TIMEOUT=5000;
        local LOW_PRIORITY_TIMEOUT=10000;
        local IDLE_PRIORITY_TIMEOUT=maxSigned31BitInt;
        local taskQueue={};
        local timerQueue={};
        local taskIdCounter=1;
        local isSchedulerPaused=false;
        local currentTask;
        local currentPriorityLevel=NormalPriority;
        local isPerformingWork=false;
        local isHostCallbackScheduled=false;
        local isHostTimeoutScheduled=false;
        local handleTimeout,flushWork,workLoop;
        local function advanceTimers(currentTime)
            local timer=peek(timerQueue);
            while(timer)~=(nil)do
                 if(timer.callback)==(nil)then
                     pop(timerQueue)
                elseif(timer.startTime)<=(currentTime)then
                     pop(timerQueue);
                    timer.sortIndex=timer.expirationTime;
                    push(taskQueue,timer);
                    if enableProfiling then
                         markTaskStart(timer,currentTime);
                        timer.isQueued=true
                     end
                 else
                     return
                 end;
                timer=peek(timerQueue)
            end
         end;
        handleTimeout=function(currentTime)
            isHostTimeoutScheduled=false;
            advanceTimers(currentTime);
            if not(isHostCallbackScheduled)then
                 if(peek(taskQueue))~=(nil)then
                     isHostCallbackScheduled=true;
                    requestHostCallback(flushWork)
                else
                     local firstTimer=peek(timerQueue);
                    if(firstTimer)~=(nil)then
                         requestHostTimeout(handleTimeout,(firstTimer.startTime)-(currentTime))
                    end
                 end
             end
         end;
        flushWork=function(hasTimeRemaining,initialTime)
            if enableProfiling then
                 markSchedulerUnsuspended(initialTime)
            end;
            isHostCallbackScheduled=false;
            if isHostTimeoutScheduled then
                 isHostTimeoutScheduled=false;
                cancelHostTimeout()
            end;
            isPerformingWork=true;
            local previousPriorityLevel=currentPriorityLevel;
            local ok,result;
            if not(_G.__YOLO__)then
                 if enableProfiling then
                     ok,result=xpcall(workLoop,describeError,hasTimeRemaining,initialTime);
                    if not(ok)then
                         if(currentTask)~=(nil)then
                             local currentTime=getCurrentTime();
                            markTaskErrored(currentTask,currentTime);
                            currentTask.isQueued=false
                         end
                     end
                 else
                     ok=true;
                    result=workLoop(hasTimeRemaining,initialTime)
                end
             else
                 ok=true;
                result=workLoop(hasTimeRemaining,initialTime)
            end;
            currentTask=nil;
            currentPriorityLevel=previousPriorityLevel;
            isPerformingWork=false;
            if enableProfiling then
                 local currentTime=getCurrentTime();
                markSchedulerSuspended(currentTime)
            end;
            if not(ok)then
                 error(result)
            end;
            return result
         end;
        workLoop=function(hasTimeRemaining,initialTime)
            local currentTime=initialTime;
            advanceTimers(currentTime);
            currentTask=peek(taskQueue);
            while((currentTask)~=(nil))and(not(((enableSchedulerDebugging)and(isSchedulerPaused))))do
                 if((currentTask.expirationTime)>(currentTime))and(((not(hasTimeRemaining))or(shouldYieldToHost())))then
                     break
                 end;
                local callback=currentTask.callback;
                if(typeof(callback))==("function")then
                     currentTask.callback=nil;
                    currentPriorityLevel=currentTask.priorityLevel;
                    local didUserCallbackTimeout=(currentTask.expirationTime)<=(currentTime);
                    markTaskRun(currentTask,currentTime);
                    local continuationCallback=callback(didUserCallbackTimeout);
                    currentTime=getCurrentTime();
                    if(typeof(continuationCallback))==("function")then
                         currentTask.callback=continuationCallback;
                        markTaskYield(currentTask,currentTime)
                    else
                         if enableProfiling then
                             markTaskCompleted(currentTask,currentTime);
                            currentTask.isQueued=false
                         end;
                        if(currentTask)==(peek(taskQueue))then
                             pop(taskQueue)
                        end
                     end;
                    advanceTimers(currentTime)
                else
                     pop(taskQueue)
                end;
                currentTask=peek(taskQueue)
            end;
            if(currentTask)~=(nil)then
                 return true
             else
                 local firstTimer=peek(timerQueue);
                if(firstTimer)~=(nil)then
                     requestHostTimeout(handleTimeout,(firstTimer.startTime)-(currentTime))
                end;
                return false
             end
         end;
        local function unstable_runWithPriority(priorityLevel,eventHandler)
            if(((((priorityLevel)==(ImmediatePriority))or((priorityLevel)==(UserBlockingPriority)))or((priorityLevel)==(NormalPriority)))or((priorityLevel)==(LowPriority)))or((priorityLevel)==(IdlePriority))then
                
             else
                 priorityLevel=NormalPriority
             end;
            local previousPriorityLevel=currentPriorityLevel;
            currentPriorityLevel=priorityLevel;
            local ok,result;
            if not(_G.__YOLO__)then
                 ok,result=xpcall(eventHandler,describeError)
            else
                 ok=true;
                result=eventHandler()
            end;
            currentPriorityLevel=previousPriorityLevel;
            if not(ok)then
                 error(result)
            end;
            return result
         end;
        local function unstable_next(eventHandler)
            local priorityLevel;
            if(((currentPriorityLevel)==(ImmediatePriority))or((currentPriorityLevel)==(UserBlockingPriority)))or((currentPriorityLevel)==(NormalPriority))then
                 priorityLevel=NormalPriority
             else
                 priorityLevel=currentPriorityLevel
             end;
            local previousPriorityLevel=currentPriorityLevel;
            currentPriorityLevel=priorityLevel;
            local ok,result;
            if not(_G.__YOLO__)then
                 ok,result=xpcall(eventHandler,describeError)
            else
                 ok=true;
                result=eventHandler()
            end;
            currentPriorityLevel=previousPriorityLevel;
            if not(ok)then
                 error(result)
            end;
            return result
         end;
        local function unstable_wrapCallback(callback)
            local parentPriorityLevel=currentPriorityLevel;
            return function(...)
                local previousPriorityLevel=currentPriorityLevel;
                currentPriorityLevel=parentPriorityLevel;
                local ok,result;
                if not(_G.__YOLO__)then
                     ok,result=xpcall(callback,describeError,...)
                else
                     ok=true;
                    result=callback(...)
                end;
                currentPriorityLevel=previousPriorityLevel;
                if not(ok)then
                     error(result)
                end;
                return result
             end
         end;
        local function unstable_scheduleCallback(priorityLevel,callback,options)
            local currentTime=getCurrentTime();
            local startTime;
            if(typeof(options))==("table")then
                 local delay_=options.delay;
                if((typeof(delay_))==("number"))and((delay_)>(0))then
                     startTime=(currentTime)+(delay_)
                else
                     startTime=currentTime
                 end
             else
                 startTime=currentTime
             end;
            local timeout;
            if(priorityLevel)==(ImmediatePriority)then
                 timeout=IMMEDIATE_PRIORITY_TIMEOUT
             elseif(priorityLevel)==(UserBlockingPriority)then
                 timeout=USER_BLOCKING_PRIORITY_TIMEOUT
             elseif(priorityLevel)==(IdlePriority)then
                 timeout=IDLE_PRIORITY_TIMEOUT
             elseif(priorityLevel)==(LowPriority)then
                 timeout=LOW_PRIORITY_TIMEOUT
             else
                 timeout=NORMAL_PRIORITY_TIMEOUT
             end;
            local expirationTime=(startTime)+(timeout);
            local newTask={["id"]=taskIdCounter,["callback"]=callback,["priorityLevel"]=priorityLevel,["startTime"]=startTime,["expirationTime"]=expirationTime,["sortIndex"]=-(1)};
            taskIdCounter+=1;
            if enableProfiling then
                 newTask.isQueued=false
             end;
            if(startTime)>(currentTime)then
                 newTask.sortIndex=startTime;
                push(timerQueue,newTask);
                if((#(taskQueue))==(0))and((newTask)==(peek(timerQueue)))then
                     if isHostTimeoutScheduled then
                         cancelHostTimeout()
                    else
                         isHostTimeoutScheduled=true
                     end;
                    requestHostTimeout(handleTimeout,(startTime)-(currentTime))
                end
             else
                 newTask.sortIndex=expirationTime;
                push(taskQueue,newTask);
                if enableProfiling then
                     markTaskStart(newTask,currentTime);
                    newTask.isQueued=true
                 end;
                if(not(isHostCallbackScheduled))and(not(isPerformingWork))then
                     isHostCallbackScheduled=true;
                    requestHostCallback(flushWork)
                end
             end;
            return newTask
         end;
        local function unstable_pauseExecution()
            isSchedulerPaused=true
         end;
        local function unstable_continueExecution()
            isSchedulerPaused=false;
            if(not(isHostCallbackScheduled))and(not(isPerformingWork))then
                 isHostCallbackScheduled=true;
                requestHostCallback(flushWork)
            end
         end;
        local function unstable_getFirstCallbackNode()
            return peek(taskQueue)
        end;
        local function unstable_cancelCallback(task)
            if enableProfiling then
                 if task.isQueued then
                     local currentTime=getCurrentTime();
                    markTaskCanceled(task,currentTime);
                    task.isQueued=false
                 end
             end;
            task.callback=nil
         end;
        local function unstable_getCurrentPriorityLevel()
            return currentPriorityLevel
         end;
        local unstable_requestPaint=requestPaint;
        return{["unstable_ImmediatePriority"]=ImmediatePriority,["unstable_UserBlockingPriority"]=UserBlockingPriority,["unstable_NormalPriority"]=NormalPriority,["unstable_IdlePriority"]=IdlePriority,["unstable_LowPriority"]=LowPriority,["unstable_runWithPriority"]=unstable_runWithPriority,["unstable_next"]=unstable_next,["unstable_scheduleCallback"]=unstable_scheduleCallback,["unstable_cancelCallback"]=unstable_cancelCallback,["unstable_wrapCallback"]=unstable_wrapCallback,["unstable_getCurrentPriorityLevel"]=unstable_getCurrentPriorityLevel,["unstable_shouldYield"]=shouldYieldToHost,["unstable_requestPaint"]=unstable_requestPaint,["unstable_continueExecution"]=unstable_continueExecution,["unstable_pauseExecution"]=unstable_pauseExecution,["unstable_getFirstCallbackNode"]=unstable_getFirstCallbackNode,["unstable_now"]=getCurrentTime,["unstable_forceFrameRate"]=forceFrameRate,["unstable_Profiling"]=(function()
            if enableProfiling then
                 return{["startLoggingProfilingEvents"]=startLoggingProfilingEvents,["stopLoggingProfilingEvents"]=stopLoggingProfilingEvents}
            end;
            return nil
         end)()}
    end

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\Tracing.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Tracing",function()
    type("not printable... yet");
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.luau-polyfill");
    type("not printable... yet");
    local Set=LuauPolyfill.Set;
    local exports={};
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local DEFAULT_THREAD_ID=0;
    local interactionIDCounter=0;
    local threadIDCounter=0;
    local interactionsRef;
    local subscriberRef;
    if enableSchedulerTracing then
         interactionsRef={["current"]=Set.new()};
        subscriberRef={["current"]=nil}
    end;
    exports.__interactionsRef=interactionsRef;
    exports.__subscriberRef=subscriberRef;
    exports.unstable_clear=function(callback)
        if not(enableSchedulerTracing)then
             return callback()
        end;
        local prevInteractions=interactionsRef.current;
        interactionsRef.current=Set.new();
        local ok,result=pcall(callback);
        interactionsRef.current=prevInteractions;
        if not(ok)then
             error(result)
        end;
        return result
     end;
    exports.unstable_getCurrent=function()
        if not(enableSchedulerTracing)then
             return nil
         else
             return interactionsRef.current
         end
     end;
    exports.unstable_getThreadID=function()
        threadIDCounter+=1;
        return threadIDCounter
     end;
    exports.unstable_trace=function(name,timestamp,callback,threadID_)
        local threadID=if(threadID_)~=(nil)then threadID_ else DEFAULT_THREAD_ID;
        if not(enableSchedulerTracing)then
             return callback()
        end;
        local interaction={["__count"]=1,["id"]=interactionIDCounter,["name"]=name,["timestamp"]=timestamp};
        interactionIDCounter+=1;
        local prevInteractions=interactionsRef.current;
        local interactions=Set.new(prevInteractions);
        interactions:add(interaction);
        interactionsRef.current=interactions;
        local subscriber=subscriberRef.current;
        local returnValue;
        local ok,result=pcall(function()
            if(subscriber)~=(nil)then
                 subscriber.onInteractionTraced(interaction)
            end
         end);
        local ok2,result2=pcall(function()
            if(subscriber)~=(nil)then
                 subscriber.onWorkStarted(interactions,threadID)
            end
         end);
        local ok3,result3=pcall(function()
            returnValue=callback()
        end);
        interactionsRef.current=prevInteractions;
        local ok4,result4=pcall(function()
            if(subscriber)~=(nil)then
                 subscriber.onWorkStopped(interactions,threadID)
            end
         end);
        interaction.__count-=1;
        if((subscriber)~=(nil))and((interaction.__count)==(0))then
             subscriber.onInteractionScheduledWorkCompleted(interaction)
        end;
        if not(ok4)then
             error(result4)
        end;
        if not(ok3)then
             error(result3)
        end;
        if not(ok2)then
             error(result2)
        end;
        if not(ok)then
             error(result)
        end;
        return returnValue
     end;
    exports.unstable_wrap=function(callback,threadID)
        if(threadID)==(nil)then
             threadID=DEFAULT_THREAD_ID
         end;
        if not(enableSchedulerTracing)then
             return callback
         end;
        local wrappedInteractions=interactionsRef.current;
        local subscriber=subscriberRef.current;
        if(subscriber)~=(nil)then
             subscriber.onWorkScheduled(wrappedInteractions,threadID)
        end;
        for _,interaction in wrappedInteractions do
             interaction.__count+=1
         end;
        local hasRun=false;
        local function _wrapped(self,...)
            local prevInteractions=interactionsRef.current;
            interactionsRef.current=wrappedInteractions;
            subscriber=subscriberRef.current;
            local ok,result=pcall(function(...)
                local returnValue;
                local ok2,result2=pcall(function()
                    if(subscriber)~=(nil)then
                         subscriber.onWorkStarted(wrappedInteractions,threadID)
                    end
                 end);
                local ok3,result3=pcall(function(...)
                    returnValue=callback(...)
                end,...);
                interactionsRef.current=prevInteractions;
                if(subscriber)~=(nil)then
                     subscriber.onWorkStopped(wrappedInteractions,threadID)
                end;
                if not(ok3)then
                     error(result3)
                end;
                if not(ok2)then
                     error(result2)
                end;
                return returnValue
             end,...);
            if not(hasRun)then
                 hasRun=true;
                for _,interaction in wrappedInteractions do
                     interaction.__count-=1;
                    if((subscriber)~=(nil))and((interaction.__count)==(0))then
                         subscriber.onInteractionScheduledWorkCompleted(interaction)
                    end
                 end
             end;
            if not(ok)then
                 error(result)
            end;
            return result
         end;
        local _cancel=function()
            subscriber=subscriberRef.current;
            local ok,result=pcall(function()
                if(subscriber)~=(nil)then
                     subscriber.onWorkCanceled(wrappedInteractions,threadID)
                end
             end);
            for _,interaction in wrappedInteractions do
                 interaction.__count-=1;
                if((subscriber)~=(nil))and((interaction.__count)==(0))then
                     subscriber.onInteractionScheduledWorkCompleted(interaction)
                end
             end;
            if not(ok)then
                 error(result)
            end
         end;
        local wrapped={};
        setmetatable(wrapped,{["__call"]=_wrapped});
        wrapped.cancel=_cancel;
        return wrapped
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\TracingSubscriptions.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.TracingSubscriptions",function()
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    local Object=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.luau-polyfill").Object;
    local Tracing=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Tracing");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    local __subscriberRef=Tracing.__subscriberRef;
    local subscribers={};
    if enableSchedulerTracing then
         subscribers={}
    end;
    exports.unstable_subscribe=function(subscriber)
        if enableSchedulerTracing then
             subscribers[subscriber]=true;
            if(#(Object.keys(subscribers)))==(1)then
                 __subscriberRef.current={["onInteractionScheduledWorkCompleted"]=onInteractionScheduledWorkCompleted,["onInteractionTraced"]=onInteractionTraced,["onWorkCanceled"]=onWorkCanceled,["onWorkScheduled"]=onWorkScheduled,["onWorkStarted"]=onWorkStarted,["onWorkStopped"]=onWorkStopped}
            end
         end
     end;
    exports.unstable_unsubscribe=function(subscriber)
        if enableSchedulerTracing then
             subscribers[subscriber]=nil;
            if(#(Object.keys(subscribers)))==(0)then
                 __subscriberRef.current=nil
             end
         end
     end;
    function onInteractionTraced(interaction)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onInteractionTraced,interaction);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    function onInteractionScheduledWorkCompleted(interaction)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onInteractionScheduledWorkCompleted,interaction);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    function onWorkScheduled(interactions,threadID)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onWorkScheduled,interactions,threadID);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    function onWorkStarted(interactions,threadID)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onWorkStarted,interactions,threadID);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    function onWorkStopped(interactions,threadID)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onWorkStopped,interactions,threadID);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    function onWorkCanceled(interactions,threadID)
        local didCatchError=false;
        local caughtError;
        for subscriber,_ in subscribers do
             local ok,result=pcall(subscriber.onWorkCanceled,interactions,threadID);
            if not(ok)then
                 local error_=result;
                if not(didCatchError)then
                     didCatchError=true;
                    caughtError=error_
                 end
             end
         end;
        if didCatchError then
             error(caughtError)
        end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\unstable_mock.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.unstable_mock",function()
    local Tracing=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Tracing");
    local TracingSubscriptions=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.TracingSubscriptions");
    type("not printable... yet");
    local initializeScheduler=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.Scheduler");
    local HostConfig=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.forks.SchedulerHostConfig.mock");
    local Scheduler=initializeScheduler(HostConfig);
    local exports={};
    exports.tracing={};
    for key,value in Scheduler do
         exports[key]=value
     end;
    for key,value in Tracing do
         exports.tracing[key]=value
     end;
    for key,value in TracingSubscriptions do
         exports.tracing[key]=value
     end;
    exports.unstable_flushAllWithoutAsserting=HostConfig.unstable_flushAllWithoutAsserting;
    exports.unstable_flushNumberOfYields=HostConfig.unstable_flushNumberOfYields;
    exports.unstable_flushExpired=HostConfig.unstable_flushExpired;
    exports.unstable_clearYields=HostConfig.unstable_clearYields;
    exports.unstable_flushUntilNextPaint=HostConfig.unstable_flushUntilNextPaint;
    exports.unstable_flushAll=HostConfig.unstable_flushAll;
    exports.unstable_yieldValue=HostConfig.unstable_yieldValue;
    exports.unstable_advanceTime=HostConfig.unstable_advanceTime;
    exports.unstable_Profiling=Scheduler.unstable_Profiling;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberSchedulerPriorities.roblox.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSchedulerPriorities.roblox",function()
    type("not printable... yet");
    local exports={["ImmediatePriority"]=99,["UserBlockingPriority"]=98,["NormalPriority"]=97,["LowPriority"]=96,["IdlePriority"]=95,["NoPriority"]=90};
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberStack.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local NULL={};
    type("not printable... yet");
    local valueStack={};
    local fiberStack;
    if _G.__DEV__ then
         fiberStack={}
    end;
    local index=0;
    local function createCursor(defaultValue)
        return{["current"]=defaultValue}
    end;
    local function isEmpty()
        return(index)==(0)
    end;
    local function pop(cursor,fiber)
        if(index)<(1)then
             if _G.__DEV__ then
                 console.error("Unexpected pop.")
            end;
            return
         end;
        if _G.__DEV__ then
             if(fiber)~=(fiberStack[index])then
                 console.error("Unexpected Fiber popped.")
            end
         end;
        local value=valueStack[index];
        if(value)==(NULL)then
             cursor.current=nil
         else
             cursor.current=value
         end;
        valueStack[index]=nil;
        if _G.__DEV__ then
             fiberStack[index]=nil
         end;
        index-=1
     end;
    local function push(cursor,value,fiber)
        index+=1;
        local stackValue=cursor.current;
        if(stackValue)==(nil)then
             valueStack[index]=NULL
         else
             valueStack[index]=stackValue
         end;
        if _G.__DEV__ then
             fiberStack[index]=fiber
         end;
        cursor.current=value
     end;
    local function checkThatStackIsEmpty()
        if _G.__DEV__ then
             if(index)~=(0)then
                 console.error("Expected an empty stack. Something was not reset properly.")
            end
         end
     end;
    local function resetStackAfterFatalErrorInDev()
        if _G.__DEV__ then
             index=0;
            table.clear(valueStack);
            table.clear(fiberStack)
        end
     end;
    return{["createCursor"]=createCursor,["isEmpty"]=isEmpty,["pop"]=pop,["push"]=push,["checkThatStackIsEmpty"]=checkThatStackIsEmpty,["resetStackAfterFatalErrorInDev"]=resetStackAfterFatalErrorInDev}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiber.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new",function()
    local __DEV__=_G.__DEV__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local Array=LuauPolyfill.Array;
    local inspect=LuauPolyfill.util.inspect;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local ReactRootTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactRootTags");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    type("not printable... yet");
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    local ReactFiberOffscreenComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberOffscreenComponent");
    type("not printable... yet");
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local NoFlags=ReactFiberFlags.NoFlags;
    local Placement=ReactFiberFlags.Placement;
    local StaticMask=ReactFiberFlags.StaticMask;
    local ConcurrentRoot=ReactRootTags.ConcurrentRoot;
    local BlockingRoot=ReactRootTags.BlockingRoot;
    local IndeterminateComponent=ReactWorkTags.IndeterminateComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local HostComponent=ReactWorkTags.HostComponent;
    local HostText=ReactWorkTags.HostText;
    local HostPortal=ReactWorkTags.HostPortal;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local Fragment=ReactWorkTags.Fragment;
    local Mode=ReactWorkTags.Mode;
    local ContextProvider=ReactWorkTags.ContextProvider;
    local ContextConsumer=ReactWorkTags.ContextConsumer;
    local Profiler=ReactWorkTags.Profiler;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local DehydratedFragment=ReactWorkTags.DehydratedFragment;
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local MemoComponent=ReactWorkTags.MemoComponent;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local LazyComponent=ReactWorkTags.LazyComponent;
    local FundamentalComponent=ReactWorkTags.FundamentalComponent;
    local ScopeComponent=ReactWorkTags.ScopeComponent;
    local OffscreenComponent=ReactWorkTags.OffscreenComponent;
    local LegacyHiddenComponent=ReactWorkTags.LegacyHiddenComponent;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactFiberDevToolsHook=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberDevToolsHook.new");
    local isDevToolsPresent=ReactFiberDevToolsHook.isDevToolsPresent;
    local ReactFiberHotReloading=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHotReloading.new");
    local resolveClassForHotReloading=ReactFiberHotReloading.resolveClassForHotReloading;
    local resolveFunctionForHotReloading=ReactFiberHotReloading.resolveFunctionForHotReloading;
    local resolveForwardRefForHotReloading=ReactFiberHotReloading.resolveForwardRefForHotReloading;
    local NoLanes=ReactFiberLane.NoLanes;
    local NoMode=ReactTypeOfMode.NoMode;
    local ConcurrentMode=ReactTypeOfMode.ConcurrentMode;
    local DebugTracingMode=ReactTypeOfMode.DebugTracingMode;
    local ProfileMode=ReactTypeOfMode.ProfileMode;
    local StrictMode=ReactTypeOfMode.StrictMode;
    local BlockingMode=ReactTypeOfMode.BlockingMode;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols;
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    local REACT_FRAGMENT_TYPE=ReactSymbols.REACT_FRAGMENT_TYPE;
    local REACT_ELEMENT_TYPE=ReactSymbols.REACT_ELEMENT_TYPE;
    local REACT_DEBUG_TRACING_MODE_TYPE=ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE;
    local REACT_STRICT_MODE_TYPE=ReactSymbols.REACT_STRICT_MODE_TYPE;
    local REACT_PROFILER_TYPE=ReactSymbols.REACT_PROFILER_TYPE;
    local REACT_PROVIDER_TYPE=ReactSymbols.REACT_PROVIDER_TYPE;
    local REACT_CONTEXT_TYPE=ReactSymbols.REACT_CONTEXT_TYPE;
    local REACT_SUSPENSE_TYPE=ReactSymbols.REACT_SUSPENSE_TYPE;
    local REACT_SUSPENSE_LIST_TYPE=ReactSymbols.REACT_SUSPENSE_LIST_TYPE;
    local REACT_MEMO_TYPE=ReactSymbols.REACT_MEMO_TYPE;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local REACT_OFFSCREEN_TYPE=ReactSymbols.REACT_OFFSCREEN_TYPE;
    local REACT_LEGACY_HIDDEN_TYPE=ReactSymbols.REACT_LEGACY_HIDDEN_TYPE;
    local createFiberFromScope,createFiberFromProfiler,createFiberFromFragment,createFiberFromFundamental,createFiberFromSuspense,createFiberFromOffscreen,createFiberFromLegacyHidden,createFiberFromSuspenseList;
    local debugCounter=1;
    local function createFiber(tag,pendingProps,key,mode,elementType,type_,stateNode,lanes)
        local node={["tag"]=tag,["key"]=key,["elementType"]=elementType,["type"]=type_,["stateNode"]=stateNode,["index"]=1,["pendingProps"]=pendingProps,["mode"]=mode,["flags"]=NoFlags,["subtreeFlags"]=NoFlags,["lanes"]=if lanes then lanes else NoLanes,["childLanes"]=NoLanes};
        if enableProfilerTimer then
             node.actualDuration=0;
            node.actualStartTime=-(1);
            node.selfBaseDuration=0;
            node.treeBaseDuration=0
         end;
        if __DEV__ then
             node._debugID=debugCounter;
            debugCounter+=1;
            node._debugSource=nil;
            node._debugOwner=nil;
            node._debugNeedsRemount=false;
            node._debugHookTypes=nil
         end;
        return node
     end;
    function _shouldConstruct(Component)
        return((type(Component))~=("function"))and(not(not(Component.isReactComponent)))
    end;
    local function isSimpleFunctionComponent(type_)
        return(type(type_))==("function")
    end;
    local function resolveLazyComponentTag(Component)
        local typeofComponent=typeof(Component);
        if(typeofComponent)==("function")then
             return FunctionComponent
         end;
        if(typeofComponent)==("table")then
             if Component.isReactComponent then
                 return ClassComponent
             end;
            local __typeof=Component["\x24\x24typeof"];
            if(__typeof)==(REACT_FORWARD_REF_TYPE)then
                 return ForwardRef
             end;
            if(__typeof)==(REACT_MEMO_TYPE)then
                 return MemoComponent
             end
         end;
        return IndeterminateComponent
     end;
    local function createWorkInProgress(current,pendingProps)
        local workInProgress=current.alternate;
        if(workInProgress)==(nil)then
             workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode,current.elementType,current.type,current.stateNode);
            if __DEV__ then
                 workInProgress._debugID=current._debugID;
                workInProgress._debugSource=current._debugSource;
                workInProgress._debugOwner=current._debugOwner;
                workInProgress._debugHookTypes=current._debugHookTypes
             end;
            workInProgress.alternate=current;
            current.alternate=workInProgress
         else
             workInProgress.pendingProps=pendingProps;
            workInProgress.type=current.type;
            workInProgress.flags=NoFlags;
            workInProgress.subtreeFlags=NoFlags;
            workInProgress.deletions=nil;
            if enableProfilerTimer then
                 workInProgress.actualDuration=0;
                workInProgress.actualStartTime=-(1)
            end
         end;
        workInProgress.flags=bit32.band(current.flags,StaticMask);
        workInProgress.childLanes=current.childLanes;
        workInProgress.lanes=current.lanes;
        workInProgress.child=current.child;
        workInProgress.memoizedProps=current.memoizedProps;
        workInProgress.memoizedState=current.memoizedState;
        workInProgress.updateQueue=current.updateQueue;
        local currentDependencies=current.dependencies;
        if(currentDependencies)==(nil)then
             workInProgress.dependencies=nil
         else
             workInProgress.dependencies={["lanes"]=currentDependencies.lanes,["firstContext"]=currentDependencies.firstContext}
        end;
        workInProgress.sibling=current.sibling;
        workInProgress.index=current.index;
        workInProgress.ref=current.ref;
        if enableProfilerTimer then
             workInProgress.selfBaseDuration=current.selfBaseDuration;
            workInProgress.treeBaseDuration=current.treeBaseDuration
         end;
        if __DEV__ then
             workInProgress._debugNeedsRemount=current._debugNeedsRemount;
            if(((workInProgress.tag)==(IndeterminateComponent))or((workInProgress.tag)==(FunctionComponent)))or((workInProgress.tag)==(SimpleMemoComponent))then
                 workInProgress.type=resolveFunctionForHotReloading(current.type)
            elseif(workInProgress.tag)==(ClassComponent)then
                 workInProgress.type=resolveClassForHotReloading(current.type)
            elseif(workInProgress.tag)==(ForwardRef)then
                 workInProgress.type=resolveForwardRefForHotReloading(current.type)
            end
         end;
        return workInProgress
     end;
    local function resetWorkInProgress(workInProgress,renderLanes)
        workInProgress.flags=bit32.band(workInProgress.flags,bit32.bor(StaticMask,Placement));
        local current=workInProgress.alternate;
        if(current)==(nil)then
             workInProgress.childLanes=NoLanes;
            workInProgress.lanes=renderLanes;
            workInProgress.child=nil;
            workInProgress.subtreeFlags=NoFlags;
            workInProgress.memoizedProps=nil;
            workInProgress.memoizedState=nil;
            workInProgress.updateQueue=nil;
            workInProgress.dependencies=nil;
            workInProgress.stateNode=nil;
            if enableProfilerTimer then
                 workInProgress.selfBaseDuration=0;
                workInProgress.treeBaseDuration=0
             end
         else
             workInProgress.childLanes=current.childLanes;
            workInProgress.lanes=current.lanes;
            workInProgress.child=current.child;
            workInProgress.subtreeFlags=current.subtreeFlags;
            workInProgress.deletions=nil;
            workInProgress.memoizedProps=current.memoizedProps;
            workInProgress.memoizedState=current.memoizedState;
            workInProgress.updateQueue=current.updateQueue;
            workInProgress.type=current.type;
            local currentDependencies=current.dependencies;
            if(currentDependencies)==(nil)then
                 workInProgress.dependencies=nil
             else
                 workInProgress.dependencies={["lanes"]=currentDependencies.lanes,["firstContext"]=currentDependencies.firstContext}
            end;
            if enableProfilerTimer then
                 workInProgress.selfBaseDuration=current.selfBaseDuration;
                workInProgress.treeBaseDuration=current.treeBaseDuration
             end
         end;
        return workInProgress
     end;
    local function createHostRootFiber(tag)
        local mode;
        if(tag)==(ConcurrentRoot)then
             mode=bit32.bor(ConcurrentMode,BlockingMode,StrictMode)
        elseif(tag)==(BlockingRoot)then
             mode=bit32.bor(BlockingMode,StrictMode)
        else
             mode=NoMode
         end;
        if(enableProfilerTimer)and(isDevToolsPresent())then
             mode=bit32.bor(mode,ProfileMode)
        end;
        return createFiber(HostRoot,nil,nil,mode)
    end;
    local function createFiberFromTypeAndProps(type_,key,pendingProps,owner,mode,lanes)
        local fiberTag=IndeterminateComponent;
        local resolvedType=type_;
        local typeOfType_=type(type_);
        if(typeOfType_)==("function")then
             if __DEV__ then
                 resolvedType=resolveFunctionForHotReloading(resolvedType)
            end
         elseif((typeOfType_)==("table"))and(not(not(type_.isReactComponent)))then
             fiberTag=ClassComponent;
            if __DEV__ then
                 resolvedType=resolveClassForHotReloading(resolvedType)
            end
         elseif(typeOfType_)==("string")then
             fiberTag=HostComponent
         else
             if(type_)==(REACT_FRAGMENT_TYPE)then
                 return createFiberFromFragment(pendingProps.children,mode,lanes,key)
            elseif(type_)==(REACT_DEBUG_TRACING_MODE_TYPE)then
                 fiberTag=Mode;
                mode=bit32.bor(mode,DebugTracingMode)
            elseif(type_)==(REACT_STRICT_MODE_TYPE)then
                 fiberTag=Mode;
                mode=bit32.bor(mode,StrictMode)
            elseif(type_)==(REACT_PROFILER_TYPE)then
                 return createFiberFromProfiler(pendingProps,mode,lanes,key)
            elseif(type_)==(REACT_SUSPENSE_TYPE)then
                 return createFiberFromSuspense(pendingProps,mode,lanes,key)
            elseif(type_)==(REACT_OFFSCREEN_TYPE)then
                 return createFiberFromOffscreen(pendingProps,mode,lanes,key)
            elseif(type_)==(REACT_LEGACY_HIDDEN_TYPE)then
                 return createFiberFromLegacyHidden(pendingProps,mode,lanes,key)
            else
                 local shouldBreak=false;
                local type_typeof;
                if(typeOfType_)==("table")then
                     type_typeof=type_["\x24\x24typeof"];
                    if(type_typeof)==(REACT_PROVIDER_TYPE)then
                         fiberTag=ContextProvider;
                        shouldBreak=true
                     elseif(type_typeof)==(REACT_CONTEXT_TYPE)then
                         fiberTag=ContextConsumer;
                        shouldBreak=true
                     elseif(type_typeof)==(REACT_FORWARD_REF_TYPE)then
                         fiberTag=ForwardRef;
                        if __DEV__ then
                             resolvedType=resolveForwardRefForHotReloading(resolvedType)
                        end;
                        shouldBreak=true
                     elseif(type_typeof)==(REACT_MEMO_TYPE)then
                         fiberTag=MemoComponent;
                        shouldBreak=true
                     elseif(type_typeof)==(REACT_LAZY_TYPE)then
                         fiberTag=LazyComponent;
                        resolvedType=nil;
                        shouldBreak=true
                     end
                 end;
                if not(shouldBreak)then
                     local info="";
                    if __DEV__ then
                         if((type_)==(nil))or((((typeOfType_)==("table"))and((#(Object.keys(type_)))==(0))))then
                             info..=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
                        elseif((type_)~=(nil))and((typeOfType_)==("table"))then
                             info..=("\x0a")..(inspect(type_))
                        end;
                        local ownerName;
                        if owner then
                             ownerName=getComponentName(owner.type)
                        end;
                        if((ownerName)~=(nil))and((ownerName)~=(""))then
                             info..=("\x0a\x0aCheck the render method of `")..((ownerName)..("`."))
                        elseif owner then
                             info..=("\x0a")..(inspect(owner))
                        end
                     end;
                    local typeString;
                    if(type_)==(nil)then
                         typeString="nil"
                    elseif Array.isArray(type_)then
                         typeString="array"
                    elseif((typeOfType_)==("table"))and((type_typeof)==(REACT_ELEMENT_TYPE))then
                         typeString=string.format("<%s />",(getComponentName(type_.type))or("Unknown"));
                        info=" Did you accidentally export a JSX literal or Element instead of a component?"
                    else
                         typeString=typeOfType_
                     end;
                    invariant(false,"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)
                end
             end
         end;
        local fiber=createFiber(fiberTag,pendingProps,key,mode,type_,resolvedType,nil,lanes);
        if __DEV__ then
             fiber._debugOwner=owner
         end;
        return fiber
     end;
    local function createFiberFromElement(element,mode,lanes)
        local owner;
        if __DEV__ then
             owner=element._owner
         end;
        local type=element.type;
        local key=element.key;
        local pendingProps=element.props;
        local fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);
        if __DEV__ then
             fiber._debugSource=element._source;
            fiber._debugOwner=element._owner
         end;
        return fiber
     end;
    function createFiberFromFragment(elements,mode,lanes,key)
        local fiber=createFiber(Fragment,elements,key,mode,nil,nil,nil,lanes);
        return fiber
     end;
    function createFiberFromFundamental(fundamentalComponent,pendingProps,mode,lanes,key)
        local fiber=createFiber(FundamentalComponent,pendingProps,key,mode,fundamentalComponent,fundamentalComponent,nil,lanes);
        return fiber
     end;
    function createFiberFromScope(scope,pendingProps,mode,lanes,key)
        local fiber=createFiber(ScopeComponent,pendingProps,key,mode,scope,scope,nil,lanes);
        return fiber
     end;
    function createFiberFromProfiler(pendingProps,mode,lanes,key)
        if __DEV__ then
             if(typeof(pendingProps.id))~=("string")then
                 console.error("Profiler must specify an \"id\" as a prop")
            end
         end;
        local fiber=createFiber(Profiler,pendingProps,key,bit32.bor(mode,ProfileMode),REACT_PROFILER_TYPE,REACT_PROFILER_TYPE,if enableProfilerTimer then{["effectDuration"]=0,["passiveEffectDuration"]=0}else nil,lanes);
        return fiber
     end;
    function createFiberFromSuspense(pendingProps,mode,lanes,key)
        local fiber=createFiber(SuspenseComponent,pendingProps,key,mode,REACT_SUSPENSE_TYPE,REACT_SUSPENSE_TYPE,nil,lanes);
        return fiber
     end;
    function createFiberFromSuspenseList(pendingProps,mode,lanes,key)
        local fiber=createFiber(SuspenseListComponent,pendingProps,key,mode,REACT_SUSPENSE_LIST_TYPE,if __DEV__ then REACT_SUSPENSE_LIST_TYPE else nil,nil,lanes);
        return fiber
     end;
    function createFiberFromOffscreen(pendingProps,mode,lanes,key)
        local fiber=createFiber(OffscreenComponent,pendingProps,key,mode,REACT_OFFSCREEN_TYPE,if __DEV__ then REACT_OFFSCREEN_TYPE else nil,nil,lanes);
        return fiber
     end;
    function createFiberFromLegacyHidden(pendingProps,mode,lanes,key)
        local fiber=createFiber(LegacyHiddenComponent,pendingProps,key,mode,REACT_LEGACY_HIDDEN_TYPE,if __DEV__ then REACT_LEGACY_HIDDEN_TYPE else nil,nil,lanes);
        return fiber
     end;
    local function createFiberFromText(content,mode,lanes)
        local fiber=createFiber(HostText,content,nil,mode,nil,nil,nil,lanes);
        return fiber
     end;
    local function createFiberFromHostInstanceForDeletion()
        local fiber=createFiber(HostComponent,nil,nil,NoMode,"DELETED","DELETED");
        return fiber
     end;
    local function createFiberFromDehydratedFragment(dehydratedNode)
        local fiber=createFiber(DehydratedFragment,nil,nil,NoMode,nil,nil,dehydratedNode);
        return fiber
     end;
    local function createFiberFromPortal(portal,mode,lanes)
        local pendingProps=if(portal.children)~=(nil)then portal.children else{};
        local fiber=createFiber(HostPortal,pendingProps,portal.key,mode,nil,nil,{["containerInfo"]=portal.containerInfo,["pendingChildren"]=nil,["implementation"]=portal.implementation},lanes);
        return fiber
     end;
    local function assignFiberPropertiesInDEV(target,source)
        if(target)==(nil)then
             target=createFiber(IndeterminateComponent,nil,nil,NoMode)
        end;
        target.tag=source.tag;
        target.key=source.key;
        target.elementType=source.elementType;
        target.type=source.type;
        target.stateNode=source.stateNode;
        target.return_=source.return_;
        target.child=source.child;
        target.sibling=source.sibling;
        target.index=source.index;
        target.ref=source.ref;
        target.pendingProps=source.pendingProps;
        target.memoizedProps=source.memoizedProps;
        target.updateQueue=source.updateQueue;
        target.memoizedState=source.memoizedState;
        target.dependencies=source.dependencies;
        target.mode=source.mode;
        target.flags=source.flags;
        target.subtreeFlags=source.subtreeFlags;
        target.deletions=source.deletions;
        target.lanes=source.lanes;
        target.childLanes=source.childLanes;
        target.alternate=source.alternate;
        if enableProfilerTimer then
             target.actualDuration=source.actualDuration;
            target.actualStartTime=source.actualStartTime;
            target.selfBaseDuration=source.selfBaseDuration;
            target.treeBaseDuration=source.treeBaseDuration
         end;
        target._debugID=source._debugID;
        target._debugSource=source._debugSource;
        target._debugOwner=source._debugOwner;
        target._debugNeedsRemount=source._debugNeedsRemount;
        target._debugHookTypes=source._debugHookTypes;
        return target
     end;
    return{["isSimpleFunctionComponent"]=isSimpleFunctionComponent,["resolveLazyComponentTag"]=resolveLazyComponentTag,["createWorkInProgress"]=createWorkInProgress,["resetWorkInProgress"]=resetWorkInProgress,["createHostRootFiber"]=createHostRootFiber,["createFiberFromTypeAndProps"]=createFiberFromTypeAndProps,["createFiberFromElement"]=createFiberFromElement,["createFiberFromFragment"]=createFiberFromFragment,["createFiberFromFundamental"]=createFiberFromFundamental,["createFiberFromSuspense"]=createFiberFromSuspense,["createFiberFromSuspenseList"]=createFiberFromSuspenseList,["createFiberFromOffscreen"]=createFiberFromOffscreen,["createFiberFromLegacyHidden"]=createFiberFromLegacyHidden,["createFiberFromText"]=createFiberFromText,["createFiberFromHostInstanceForDeletion"]=createFiberFromHostInstanceForDeletion,["createFiberFromDehydratedFragment"]=createFiberFromDehydratedFragment,["createFiberFromPortal"]=createFiberFromPortal,["assignFiberPropertiesInDEV"]=assignFiberPropertiesInDEV}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\SchedulerWithReactIntegration.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulerWithReactIntegration.new",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local Scheduler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local decoupleUpdatePriorityFromScheduler=ReactFeatureFlags.decoupleUpdatePriorityFromScheduler;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    local SyncLanePriority=ReactFiberLane.SyncLanePriority;
    local getCurrentUpdateLanePriority=ReactFiberLane.getCurrentUpdateLanePriority;
    local setCurrentUpdateLanePriority=ReactFiberLane.setCurrentUpdateLanePriority;
    local Scheduler_runWithPriority=Scheduler.unstable_runWithPriority;
    local Scheduler_scheduleCallback=Scheduler.unstable_scheduleCallback;
    local Scheduler_cancelCallback=Scheduler.unstable_cancelCallback;
    local Scheduler_shouldYield=Scheduler.unstable_shouldYield;
    local Scheduler_requestPaint=Scheduler.unstable_requestPaint;
    local Scheduler_now=Scheduler.unstable_now;
    local Scheduler_getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;
    local Scheduler_ImmediatePriority=Scheduler.unstable_ImmediatePriority;
    local Scheduler_UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;
    local Scheduler_NormalPriority=Scheduler.unstable_NormalPriority;
    local Scheduler_LowPriority=Scheduler.unstable_LowPriority;
    local Scheduler_IdlePriority=Scheduler.unstable_IdlePriority;
    local ReactFiberSchedulerPriorities=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSchedulerPriorities.roblox");
    local ImmediatePriority=ReactFiberSchedulerPriorities.ImmediatePriority;
    local UserBlockingPriority=ReactFiberSchedulerPriorities.UserBlockingPriority;
    local NormalPriority=ReactFiberSchedulerPriorities.NormalPriority;
    local LowPriority=ReactFiberSchedulerPriorities.LowPriority;
    local IdlePriority=ReactFiberSchedulerPriorities.IdlePriority;
    local NoPriority=ReactFiberSchedulerPriorities.NoPriority;
    type("not printable... yet");
    local flushSyncCallbackQueueImpl;
    type("not printable... yet");
    type("not printable... yet");
    local fakeCallbackNode={};
    local shouldYield=Scheduler_shouldYield;
    local requestPaint;
    if(Scheduler_requestPaint)~=(nil)then
         requestPaint=Scheduler_requestPaint
     else
         requestPaint=function()
            
        end
     end;
    local syncQueue;
    local immediateQueueCallbackNode;
    local isFlushingSyncQueue=false;
    local initialTimeMs=Scheduler_now();
    local function now()
        return(Scheduler_now())-(initialTimeMs)
    end;
    local function getCurrentPriorityLevel()
        local currentPriorityLevel=Scheduler_getCurrentPriorityLevel();
        if(currentPriorityLevel)==(Scheduler_ImmediatePriority)then
             return ImmediatePriority
         elseif(currentPriorityLevel)==(Scheduler_UserBlockingPriority)then
             return UserBlockingPriority
         elseif(currentPriorityLevel)==(Scheduler_NormalPriority)then
             return NormalPriority
         elseif(currentPriorityLevel)==(Scheduler_LowPriority)then
             return LowPriority
         elseif(currentPriorityLevel)==(Scheduler_IdlePriority)then
             return IdlePriority
         else
             invariant(false,"Unknown priority level.");
            return NoPriority
         end
     end;
    function reactPriorityToSchedulerPriority(reactPriorityLevel)
        if(reactPriorityLevel)==(ImmediatePriority)then
             return Scheduler_ImmediatePriority
         elseif(reactPriorityLevel)==(UserBlockingPriority)then
             return Scheduler_UserBlockingPriority
         elseif(reactPriorityLevel)==(NormalPriority)then
             return Scheduler_NormalPriority
         elseif(reactPriorityLevel)==(LowPriority)then
             return Scheduler_LowPriority
         elseif(reactPriorityLevel)==(IdlePriority)then
             return Scheduler_IdlePriority
         else
             invariant(false,"Unknown priority level.");
            return nil
         end
     end;
    local function runWithPriority(reactPriorityLevel,fn)
        local priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_runWithPriority(priorityLevel,fn)
    end;
    local function scheduleCallback(reactPriorityLevel,callback,options)
        local priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_scheduleCallback(priorityLevel,callback,options)
    end;
    local function scheduleSyncCallback(callback)
        if(syncQueue)==(nil)then
             syncQueue={callback};
            immediateQueueCallbackNode=Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueueImpl)
        else
             local coercedSyncQueue=syncQueue;
            table.insert(coercedSyncQueue,callback)
        end;
        return fakeCallbackNode
     end;
    local function cancelCallback(callbackNode)
        if(callbackNode)~=(fakeCallbackNode)then
             Scheduler_cancelCallback(callbackNode)
        end
     end;
    local function flushSyncCallbackQueue()
        if(immediateQueueCallbackNode)~=(nil)then
             local node=immediateQueueCallbackNode;
            immediateQueueCallbackNode=nil;
            Scheduler_cancelCallback(node)
        end;
        return flushSyncCallbackQueueImpl()
    end;
    flushSyncCallbackQueueImpl=function()
        if(not(isFlushingSyncQueue))and((syncQueue)~=(nil))then
             isFlushingSyncQueue=true;
            local i=1;
            if decoupleUpdatePriorityFromScheduler then
                 local previousLanePriority=getCurrentUpdateLanePriority();
                local ok=true;
                local result;
                if not(_G.__YOLO__)then
                     local isSync=true;
                    local queue=syncQueue;
                    setCurrentUpdateLanePriority(SyncLanePriority);
                    ok,result=xpcall(runWithPriority,describeError,ImmediatePriority,function()
                        for index,callback in queue do
                             i=index;
                            repeat
                                 callback=callback(isSync)
                            until(callback)==(nil)
                        end
                     end);
                    syncQueue=nil
                 else
                     ok=true;
                    local isSync=true;
                    local queue=syncQueue;
                    setCurrentUpdateLanePriority(SyncLanePriority);
                    runWithPriority(ImmediatePriority,function()
                        for index,callback in queue do
                             i=index;
                            repeat
                                 callback=callback(isSync)
                            until(callback)==(nil);
                            i+=1
                         end
                     end);
                    syncQueue=nil
                 end;
                setCurrentUpdateLanePriority(previousLanePriority);
                isFlushingSyncQueue=false;
                if not(ok)then
                     if(syncQueue)~=(nil)then
                         syncQueue=Array.slice(syncQueue,(i)+(1))
                    end;
                    Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueue);
                    error(result)
                end
             else
                 local ok,result;
                if not(_G.__YOLO__)then
                     local isSync=true;
                    local queue=syncQueue;
                    ok,result=xpcall(runWithPriority,describeError,ImmediatePriority,function()
                        for index,callback in queue do
                             i=index;
                            repeat
                                 callback=callback(isSync)
                            until(callback)==(nil)
                        end
                     end);
                    syncQueue=nil
                 else
                     ok=true;
                    local isSync=true;
                    local queue=syncQueue;
                    runWithPriority(ImmediatePriority,function()
                        for index,callback in queue do
                             i=index;
                            repeat
                                 callback=callback(isSync)
                            until(callback)==(nil)
                        end
                     end);
                    syncQueue=nil
                 end;
                isFlushingSyncQueue=false;
                if not(ok)then
                     if(syncQueue)~=(nil)then
                         syncQueue=Array.slice(syncQueue,(i)+(1))
                    end;
                    Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueue);
                    error(result)
                end
             end;
            return true
         else
             return false
         end
     end;
    return{["ImmediatePriority"]=ImmediatePriority,["UserBlockingPriority"]=UserBlockingPriority,["NormalPriority"]=NormalPriority,["LowPriority"]=LowPriority,["IdlePriority"]=IdlePriority,["NoPriority"]=NoPriority,["getCurrentPriorityLevel"]=getCurrentPriorityLevel,["flushSyncCallbackQueue"]=flushSyncCallbackQueue,["runWithPriority"]=runWithPriority,["scheduleCallback"]=scheduleCallback,["scheduleSyncCallback"]=scheduleSyncCallback,["cancelCallback"]=cancelCallback,["now"]=now,["requestPaint"]=requestPaint,["shouldYield"]=shouldYield}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\DebugTracing.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.DebugTracing",function()
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    local console=Shared.console;
    local exports={};
    local log;
    local ReactFiberLaneModule=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local enableDebugTracing=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.enableDebugTracing;
    local nativeConsole=console;
    local nativeConsoleLog;
    local pendingGroupArgs={};
    local printedGroupIndex=0;
    function decimalToBinaryString(decimal)
        local result="";
        repeat
             local divres=(decimal)/(2);
            local int,frac=math.modf(divres);
            decimal=int;
            result=(math.ceil(frac))..(result)
        until(decimal)==(0);
        local nbZero=(31)-(string.len(result));
        return(string.rep("0",nbZero))..(result)
    end;
    local function formatLanes(laneOrLanes)
        return("0b")..(decimalToBinaryString(laneOrLanes))
    end;
    local function group(...)
        for _,groupArg in{...}do
             table.insert(pendingGroupArgs,groupArg)
        end;
        if(nativeConsoleLog)==(nil)then
             nativeConsoleLog=nativeConsole.log;
            nativeConsole.log=log
         end
     end;
    local function groupEnd()
        table.remove(pendingGroupArgs,1);
        while(printedGroupIndex)>(#(pendingGroupArgs))do
             nativeConsole.groupEnd();
            printedGroupIndex-=1
         end;
        if(#(pendingGroupArgs))==(0)then
             nativeConsole.log=nativeConsoleLog;
            nativeConsoleLog=nil
         end
     end;
    function log(...)
        if(printedGroupIndex)<(#(pendingGroupArgs))then
             for i=(printedGroupIndex)+(1),#(pendingGroupArgs)do
                 local groupArgs=pendingGroupArgs[i];
                nativeConsole.group(groupArgs)
            end;
            printedGroupIndex=#(pendingGroupArgs)
        end;
        if(typeof(nativeConsoleLog))==("function")then
            (nativeConsoleLog)(...)
        else
             nativeConsole.log(...)
        end
     end;
    local REACT_LOGO_STYLE="";
    local function logCommitStarted(lanes)
        if _G.__DEV__ then
             if enableDebugTracing then
                 group(string.format("* commit (%s)",formatLanes(lanes)),REACT_LOGO_STYLE,"","")
            end
         end
     end;
    exports.logCommitStarted=logCommitStarted;
    local function logCommitStopped()
        if _G.__DEV__ then
             if enableDebugTracing then
                 groupEnd()
            end
         end
     end;
    exports.logCommitStopped=logCommitStopped;
    local function logComponentSuspended(componentName,wakeable)
        if _G.__DEV__ then
             if enableDebugTracing then
                 log(string.format("* %s suspended",componentName));
                wakeable:andThen(function()
                    log(string.format("* %s resolved",componentName))
                end,function()
                    log(string.format("* %s rejected",componentName))
                end)
            end
         end
     end;
    exports.logComponentSuspended=logComponentSuspended;
    local function logLayoutEffectsStarted(lanes)
        if _G.__DEV__ then
             if enableDebugTracing then
                 group(string.format("* layout effects (%s)",formatLanes(lanes)))
            end
         end
     end;
    exports.logLayoutEffectsStarted=logLayoutEffectsStarted;
    local function logLayoutEffectsStopped()
        if _G.__DEV__ then
             if enableDebugTracing then
                 groupEnd()
            end
         end
     end;
    exports.logLayoutEffectsStopped=logLayoutEffectsStopped;
    local function logPassiveEffectsStarted(lanes)
        if _G.__DEV__ then
             if enableDebugTracing then
                 group(string.format("* passive effects (%s)",formatLanes(lanes)))
            end
         end
     end;
    exports.logPassiveEffectsStarted=logPassiveEffectsStarted;
    local function logPassiveEffectsStopped()
        if _G.__DEV__ then
             if enableDebugTracing then
                 groupEnd()
            end
         end
     end;
    exports.logPassiveEffectsStopped=logPassiveEffectsStopped;
    local function logRenderStarted(lanes)
        if _G.__DEV__ then
             if enableDebugTracing then
                 group(string.format("* render (%s)",formatLanes(lanes)))
            end
         end
     end;
    exports.logRenderStarted=logRenderStarted;
    local function logRenderStopped()
        if _G.__DEV__ then
             if enableDebugTracing then
                 groupEnd()
            end
         end
     end;
    exports.logRenderStopped=logRenderStopped;
    local function logForceUpdateScheduled(componentName,lane)
        if _G.__DEV__ then
             if enableDebugTracing then
                 log(string.format("* %s forced update (%s)",componentName,formatLanes(lane)))
            end
         end
     end;
    exports.logForceUpdateScheduled=logForceUpdateScheduled;
    local function logStateUpdateScheduled(componentName,lane,payloadOrAction)
        if _G.__DEV__ then
             if enableDebugTracing then
                 log(string.format("* %s updated state (%s)",componentName,formatLanes(lane)))
            end
         end
     end;
    exports.logStateUpdateScheduled=logStateUpdateScheduled;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberTransition.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTransition",function()
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;
    return{["NoTransition"]=0,["requestCurrentTransition"]=function()
        return ReactCurrentBatchConfig.transition
     end}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberUnwindWork.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberUnwindWork.new",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local resetMutableSourceWorkInProgressVersions=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactMutableSource.new").resetWorkInProgressVersions;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableSuspenseServerRenderer=ReactFeatureFlags.enableSuspenseServerRenderer;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local ReactFiberHostContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostContext.new");
    local popHostContainer=ReactFiberHostContext.popHostContainer;
    local popHostContext=ReactFiberHostContext.popHostContext;
    local popSuspenseContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseContext.new").popSuspenseContext;
    local resetHydrationState=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHydrationContext.new").resetHydrationState;
    local ReactFiberContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new");
    local isLegacyContextProvider=ReactFiberContext.isContextProvider;
    local popLegacyContext=ReactFiberContext.popContext;
    local popTopLevelLegacyContextObject=ReactFiberContext.popTopLevelContextObject;
    local popProvider=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new").popProvider;
    local popRenderLanesRef;
    local popRenderLanes=function(...)
        if not(popRenderLanesRef)then
             popRenderLanesRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new").popRenderLanes
         end;
        return popRenderLanesRef(...)
    end;
    local transferActualDuration=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new").transferActualDuration;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local function unwindWork(workInProgress,renderLanes)
        if(workInProgress.tag)==(ReactWorkTags.ClassComponent)then
             local Component=workInProgress.type;
            if isLegacyContextProvider(Component)then
                 popLegacyContext(workInProgress)
            end;
            local flags=workInProgress.flags;
            if(bit32.band(flags,ReactFiberFlags.ShouldCapture))~=(0)then
                 workInProgress.flags=bit32.bor(bit32.band(flags,bit32.bnot(ReactFiberFlags.ShouldCapture)),ReactFiberFlags.DidCapture);
                if(enableProfilerTimer)and((bit32.band(workInProgress.mode,ReactTypeOfMode.ProfileMode))~=(ReactTypeOfMode.NoMode))then
                     transferActualDuration(workInProgress)
                end;
                return workInProgress
             end;
            return nil
         elseif(workInProgress.tag)==(ReactWorkTags.HostRoot)then
             popHostContainer(workInProgress);
            popTopLevelLegacyContextObject(workInProgress);
            resetMutableSourceWorkInProgressVersions();
            local flags=workInProgress.flags;
            invariant((bit32.band(flags,ReactFiberFlags.DidCapture))==(ReactFiberFlags.NoFlags),"The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
            workInProgress.flags=bit32.bor(bit32.band(flags,bit32.bnot(ReactFiberFlags.ShouldCapture)),ReactFiberFlags.DidCapture);
            return workInProgress
         elseif(workInProgress.tag)==(ReactWorkTags.HostComponent)then
             popHostContext(workInProgress);
            return nil
         elseif(workInProgress.tag)==(ReactWorkTags.SuspenseComponent)then
             popSuspenseContext(workInProgress);
            if enableSuspenseServerRenderer then
                 local suspenseState=workInProgress.memoizedState;
                if((suspenseState)~=(nil))and((suspenseState.dehydrated)~=(nil))then
                     invariant((workInProgress.alternate)~=(nil),"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                    resetHydrationState()
                end
             end;
            local flags=workInProgress.flags;
            if(bit32.band(flags,ReactFiberFlags.ShouldCapture))~=(0)then
                 workInProgress.flags=bit32.bor(bit32.band(flags,bit32.bnot(ReactFiberFlags.ShouldCapture)),ReactFiberFlags.DidCapture);
                if(enableProfilerTimer)and(((bit32.band(workInProgress.mode,ReactTypeOfMode.ProfileMode))~=(ReactTypeOfMode.NoMode)))then
                     transferActualDuration(workInProgress)
                end;
                return workInProgress
             end;
            return nil
         elseif(workInProgress.tag)==(ReactWorkTags.SuspenseListComponent)then
             popSuspenseContext(workInProgress);
            return nil
         elseif(workInProgress.tag)==(ReactWorkTags.HostPortal)then
             popHostContainer(workInProgress);
            return nil
         elseif(workInProgress.tag)==(ReactWorkTags.ContextProvider)then
             popProvider(workInProgress);
            return nil
         elseif((workInProgress.tag)==(ReactWorkTags.OffscreenComponent))or((workInProgress.tag)==(ReactWorkTags.LegacyHiddenComponent))then
             popRenderLanes(workInProgress);
            return nil
         else
             return nil
         end
     end;
    function unwindInterruptedWork(interruptedWork)
        if(interruptedWork.tag)==(ReactWorkTags.ClassComponent)then
             local childContextTypes;
            if(typeof(interruptedWork.type))==("table")then
                 childContextTypes=interruptedWork.type.childContextTypes
             end;
            if(childContextTypes)~=(nil)then
                 popLegacyContext(interruptedWork)
            end
         elseif(interruptedWork.tag)==(ReactWorkTags.HostRoot)then
             popHostContainer(interruptedWork);
            popTopLevelLegacyContextObject(interruptedWork);
            resetMutableSourceWorkInProgressVersions()
        elseif(interruptedWork.tag)==(ReactWorkTags.HostComponent)then
             popHostContext(interruptedWork)
        elseif(interruptedWork.tag)==(ReactWorkTags.HostPortal)then
             popHostContainer(interruptedWork)
        elseif(interruptedWork.tag)==(ReactWorkTags.SuspenseComponent)then
             popSuspenseContext(interruptedWork)
        elseif(interruptedWork.tag)==(ReactWorkTags.SuspenseListComponent)then
             popSuspenseContext(interruptedWork)
        elseif(interruptedWork.tag)==(ReactWorkTags.ContextProvider)then
             popProvider(interruptedWork)
        elseif((interruptedWork.tag)==(ReactWorkTags.OffscreenComponent))or((interruptedWork.tag)==(ReactWorkTags.LegacyHiddenComponent))then
             popRenderLanes(interruptedWork);
            return
         else
             return
         end
     end;
    return{["unwindWork"]=unwindWork,["unwindInterruptedWork"]=unwindInterruptedWork}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberThrow.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberThrow.new",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local ReactCapturedValue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCapturedValue");
    type("not printable... yet");
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseContext.new");
    type("not printable... yet");
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local IncompleteClassComponent=ReactWorkTags.IncompleteClassComponent;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local DidCapture=ReactFiberFlags.DidCapture;
    local Incomplete=ReactFiberFlags.Incomplete;
    local NoFlags=ReactFiberFlags.NoFlags;
    local ShouldCapture=ReactFiberFlags.ShouldCapture;
    local LifecycleEffectMask=ReactFiberFlags.LifecycleEffectMask;
    local ForceUpdateForLegacySuspense=ReactFiberFlags.ForceUpdateForLegacySuspense;
    local shouldCaptureSuspense=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new").shouldCaptureSuspense;
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local NoMode=ReactTypeOfMode.NoMode;
    local BlockingMode=ReactTypeOfMode.BlockingMode;
    local DebugTracingMode=ReactTypeOfMode.DebugTracingMode;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableDebugTracing=ReactFeatureFlags.enableDebugTracing;
    local enableSchedulingProfiler=ReactFeatureFlags.enableSchedulingProfiler;
    local createCapturedValue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCapturedValue").createCapturedValue;
    local enqueueCapturedUpdate=ReactUpdateQueue.enqueueCapturedUpdate;
    local createUpdate=ReactUpdateQueue.createUpdate;
    local CaptureUpdate=ReactUpdateQueue.CaptureUpdate;
    local ForceUpdate=ReactUpdateQueue.ForceUpdate;
    local enqueueUpdate=ReactUpdateQueue.enqueueUpdate;
    local markFailedErrorBoundaryForHotReloading=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHotReloading.new").markFailedErrorBoundaryForHotReloading;
    local hasSuspenseContext=ReactFiberSuspenseContext.hasSuspenseContext;
    local InvisibleParentSuspenseContext=ReactFiberSuspenseContext.InvisibleParentSuspenseContext;
    local suspenseStackCursor=ReactFiberSuspenseContext.suspenseStackCursor;
    local ReactFiberWorkLoop;
    local markLegacyErrorBoundaryAsFailedRef,isAlreadyFailedLegacyErrorBoundaryRef,pingSuspendedRootRef;
    local markLegacyErrorBoundaryAsFailed=function(...)
        if not(markLegacyErrorBoundaryAsFailedRef)then
             ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
            markLegacyErrorBoundaryAsFailedRef=ReactFiberWorkLoop.markLegacyErrorBoundaryAsFailed
         end;
        return markLegacyErrorBoundaryAsFailedRef(...)
    end;
    local pingSuspendedRoot=function(...)
        if(ReactFiberWorkLoop)==(nil)then
             ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new")
        end;
        pingSuspendedRootRef=ReactFiberWorkLoop.pingSuspendedRoot;
        return pingSuspendedRootRef(...)
    end;
    local isAlreadyFailedLegacyErrorBoundary=function(...)
        if(ReactFiberWorkLoop)==(nil)then
             ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new")
        end;
        isAlreadyFailedLegacyErrorBoundaryRef=ReactFiberWorkLoop.isAlreadyFailedLegacyErrorBoundary;
        return isAlreadyFailedLegacyErrorBoundaryRef(...)
    end;
    local logCapturedError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberErrorLogger").logCapturedError;
    local logComponentSuspended=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.DebugTracing").logComponentSuspended;
    local markComponentSuspended=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler").markComponentSuspended;
    local SyncLane=ReactFiberLane.SyncLane;
    local NoTimestamp=ReactFiberLane.NoTimestamp;
    local includesSomeLane=ReactFiberLane.includesSomeLane;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local pickArbitraryLane=ReactFiberLane.pickArbitraryLane;
    function createRootErrorUpdate(fiber,errorInfo,lane,onUncaughtError)
        local update=createUpdate(NoTimestamp,lane);
        update.tag=CaptureUpdate;
        update.payload={["element"]=Object.None};
        local _error=errorInfo.value;
        update.callback=function()
            if(onUncaughtError)~=(nil)then
                 onUncaughtError(_error)
            end;
            logCapturedError(fiber,errorInfo)
        end;
        return update
     end;
    function createClassErrorUpdate(fiber,errorInfo,lane)
        local update=createUpdate(NoTimestamp,lane);
        update.tag=CaptureUpdate;
        local getDerivedStateFromError=(fiber.type).getDerivedStateFromError;
        if(typeof(getDerivedStateFromError))==("function")then
             local error_=errorInfo.value;
            update.payload=function()
                logCapturedError(fiber,errorInfo);
                return getDerivedStateFromError(error_)
            end
         end;
        local inst=fiber.stateNode;
        if((inst)~=(nil))and((typeof(inst.componentDidCatch))==("function"))then
             update.callback=function()
                if _G.__DEV__ then
                     markFailedErrorBoundaryForHotReloading(fiber)
                end;
                if(typeof(getDerivedStateFromError))~=("function")then
                     markLegacyErrorBoundaryAsFailed(inst);
                    logCapturedError(fiber,errorInfo)
                end;
                local error_=errorInfo.value;
                local stack=errorInfo.stack;
                inst:componentDidCatch(error_,{["componentStack"]=(stack)or("")});
                if _G.__DEV__ then
                     if(typeof(getDerivedStateFromError))~=("function")then
                         if not(includesSomeLane(fiber.lanes,SyncLane))then
                             console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",(getComponentName(fiber.type))or("Unknown"))
                        end
                     end
                 end
             end
         elseif _G.__DEV__ then
             update.callback=function()
                markFailedErrorBoundaryForHotReloading(fiber)
            end
         end;
        return update
     end;
    local function attachPingListener(root,wakeable,lanes)
        local pingCache=root.pingCache;
        local threadIDs;
        if(pingCache)==(nil)then
             threadIDs={};
            root.pingCache={[wakeable]=threadIDs};
            pingCache=root.pingCache
         else
             threadIDs=(pingCache)[wakeable];
            if(threadIDs)==(nil)then
                 threadIDs={};
                (pingCache)[wakeable]=threadIDs
             end
         end;
        if not(threadIDs[lanes])then
             threadIDs[lanes]=true;
            local ping=function()
                return pingSuspendedRoot(root,wakeable,lanes)
            end;
            wakeable:andThen(ping,ping)
        end
     end;
    function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes,onUncaughtError,renderDidError)
        sourceFiber.flags=bit32.bor(sourceFiber.flags,Incomplete);
        if(((value)~=(nil))and((typeof(value))==("table")))and((typeof(value.andThen))==("function"))then
             local wakeable=value;
            if _G.__DEV__ then
                 if enableDebugTracing then
                     if(bit32.band(sourceFiber.mode,DebugTracingMode))~=(0)then
                         local name=(getComponentName(sourceFiber.type))or("Unknown");
                        logComponentSuspended(name,wakeable)
                    end
                 end
             end;
            if enableSchedulingProfiler then
                 markComponentSuspended(sourceFiber,wakeable)
            end;
            if(bit32.band(sourceFiber.mode,BlockingMode))==(NoMode)then
                 local currentSource=sourceFiber.alternate;
                if currentSource then
                     sourceFiber.updateQueue=currentSource.updateQueue;
                    sourceFiber.memoizedState=currentSource.memoizedState;
                    sourceFiber.lanes=currentSource.lanes
                 else
                     sourceFiber.updateQueue=nil;
                    sourceFiber.memoizedState=nil
                 end
             end;
            local hasInvisibleParentBoundary=hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext);
            local workInProgress=returnFiber;
            repeat
                 if((workInProgress.tag)==(SuspenseComponent))and(shouldCaptureSuspense(workInProgress,hasInvisibleParentBoundary))then
                     local wakeables=workInProgress.updateQueue;
                    if(wakeables)==(nil)then
                         local updateQueue={[wakeable]=true};
                        workInProgress.updateQueue=updateQueue
                     else
                         wakeables[wakeable]=true
                     end;
                    if(bit32.band(workInProgress.mode,BlockingMode))==(NoMode)then
                         workInProgress.flags=bit32.bor(workInProgress.flags,DidCapture);
                        sourceFiber.flags=bit32.bor(sourceFiber.flags,ForceUpdateForLegacySuspense);
                        sourceFiber.flags=bit32.band(sourceFiber.flags,bit32.bnot(bit32.bor(LifecycleEffectMask,Incomplete)));
                        if(sourceFiber.tag)==(ClassComponent)then
                             local currentSourceFiber=sourceFiber.alternate;
                            if(currentSourceFiber)==(nil)then
                                 sourceFiber.tag=IncompleteClassComponent
                             else
                                 local update=createUpdate(NoTimestamp,SyncLane);
                                update.tag=ForceUpdate;
                                enqueueUpdate(sourceFiber,update)
                            end
                         end;
                        sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);
                        return
                     end;
                    attachPingListener(root,wakeable,rootRenderLanes);
                    workInProgress.flags=bit32.bor(workInProgress.flags,ShouldCapture);
                    workInProgress.lanes=rootRenderLanes;
                    return
                 end;
                workInProgress=workInProgress.return_
             until(workInProgress)==(nil);
            value=(((getComponentName(sourceFiber.type))or("A React component")))..(" suspended while rendering, but no fallback UI was specified.\x0a\x0aAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")
        end;
        renderDidError();
        value=createCapturedValue(value,sourceFiber);
        local workInProgress=returnFiber;
        repeat
             if(workInProgress.tag)==(HostRoot)then
                 local errorInfo=value;
                workInProgress.flags=bit32.bor(workInProgress.flags,ShouldCapture);
                local lane=pickArbitraryLane(rootRenderLanes);
                workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);
                local update=createRootErrorUpdate(workInProgress,errorInfo,lane,onUncaughtError);
                enqueueCapturedUpdate(workInProgress,update);
                return
             elseif(workInProgress.tag)==(ClassComponent)then
                 local errorInfo=value;
                local ctor=workInProgress.type;
                local instance=workInProgress.stateNode;
                if((bit32.band(workInProgress.flags,DidCapture))==(NoFlags))and((((typeof(ctor.getDerivedStateFromError))==("function"))or(((((instance)~=(nil))and((typeof(instance.componentDidCatch))==("function")))and(not(isAlreadyFailedLegacyErrorBoundary(instance)))))))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,ShouldCapture);
                    local lane=pickArbitraryLane(rootRenderLanes);
                    workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);
                    local update=createClassErrorUpdate(workInProgress,errorInfo,lane);
                    enqueueCapturedUpdate(workInProgress,update);
                    return
                 end
             end;
            workInProgress=workInProgress.return_
         until(workInProgress)==(nil)
    end;
    return{["throwException"]=throwException,["createRootErrorUpdate"]=createRootErrorUpdate,["createClassErrorUpdate"]=createClassErrorUpdate}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberCommitWork.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberCommitWork.new",function()
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(tostring(message)));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")),2)
    end;
    local __DEV__=_G.__DEV__;
    local __YOLO__=_G.__YOLO__;
    local runDepth=0;
    local MAX_RUN_DEPTH=20;
    local function isCallable(value)
        if(typeof(value))==("function")then
             return true
         end;
        if(typeof(value))==("table")then
             local mt=getmetatable(value);
            if(mt)and(rawget(mt,"__call"))then
                 return true
             end;
            if value._isMockFunction then
                 return true
             end
         end;
        return false
     end;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Error=LuauPolyfill.Error;
    local Set=LuauPolyfill.Set;
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local ReactUpdateQueueModule=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberOffscreenComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberOffscreenComponent");
    type("not printable... yet");
    local ReactHookEffectTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactHookEffectTags");
    type("not printable... yet");
    local Schedule_tracing_wrap=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler").tracing.unstable_wrap;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local enableProfilerCommitHooks=ReactFeatureFlags.enableProfilerCommitHooks;
    local enableSuspenseCallback=ReactFeatureFlags.enableSuspenseCallback;
    local enableDoubleInvokingEffects=ReactFeatureFlags.enableDoubleInvokingEffects;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local HostComponent=ReactWorkTags.HostComponent;
    local HostText=ReactWorkTags.HostText;
    local HostPortal=ReactWorkTags.HostPortal;
    local Profiler=ReactWorkTags.Profiler;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local DehydratedFragment=ReactWorkTags.DehydratedFragment;
    local IncompleteClassComponent=ReactWorkTags.IncompleteClassComponent;
    local MemoComponent=ReactWorkTags.MemoComponent;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local FundamentalComponent=ReactWorkTags.FundamentalComponent;
    local ScopeComponent=ReactWorkTags.ScopeComponent;
    local Block=ReactWorkTags.Block;
    local OffscreenComponent=ReactWorkTags.OffscreenComponent;
    local LegacyHiddenComponent=ReactWorkTags.LegacyHiddenComponent;
    local ReactErrorUtils=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactErrorUtils;
    local invokeGuardedCallback=ReactErrorUtils.invokeGuardedCallback;
    local hasCaughtError=ReactErrorUtils.hasCaughtError;
    local clearCaughtError=ReactErrorUtils.clearCaughtError;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local NoFlags=ReactFiberFlags.NoFlags;
    local ContentReset=ReactFiberFlags.ContentReset;
    local Placement=ReactFiberFlags.Placement;
    local Snapshot=ReactFiberFlags.Snapshot;
    local Update=ReactFiberFlags.Update;
    local Callback=ReactFiberFlags.Callback;
    local LayoutMask=ReactFiberFlags.LayoutMask;
    local PassiveMask=ReactFiberFlags.PassiveMask;
    local Ref=ReactFiberFlags.Ref;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ReactCurrentFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber");
    local currentDebugFiberInDEV=ReactCurrentFiber.current;
    local resetCurrentDebugFiberInDEV=ReactCurrentFiber.resetCurrentFiber;
    local setCurrentDebugFiberInDEV=ReactCurrentFiber.setCurrentFiber;
    local onCommitUnmount=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberDevToolsHook.new").onCommitUnmount;
    local resolveDefaultProps=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLazyComponent.new").resolveDefaultProps;
    local ReactProfilerTimer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new");
    local startLayoutEffectTimer=ReactProfilerTimer.startLayoutEffectTimer;
    local recordPassiveEffectDuration=ReactProfilerTimer.recordPassiveEffectDuration;
    local recordLayoutEffectDuration=ReactProfilerTimer.recordLayoutEffectDuration;
    local startPassiveEffectTimer=ReactProfilerTimer.startPassiveEffectTimer;
    local getCommitTime=ReactProfilerTimer.getCommitTime;
    local ProfileMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode").ProfileMode;
    local commitUpdateQueue=ReactUpdateQueueModule.commitUpdateQueue;
    local getPublicInstance=ReactFiberHostConfig.getPublicInstance;
    local supportsMutation=ReactFiberHostConfig.supportsMutation;
    local supportsPersistence=ReactFiberHostConfig.supportsPersistence;
    local supportsHydration=ReactFiberHostConfig.supportsHydration;
    local commitMount=ReactFiberHostConfig.commitMount;
    local commitUpdate=ReactFiberHostConfig.commitUpdate;
    local resetTextContent=ReactFiberHostConfig.resetTextContent;
    local commitTextUpdate=ReactFiberHostConfig.commitTextUpdate;
    local appendChild=ReactFiberHostConfig.appendChild;
    local appendChildToContainer=ReactFiberHostConfig.appendChildToContainer;
    local insertBefore=ReactFiberHostConfig.insertBefore;
    local insertInContainerBefore=ReactFiberHostConfig.insertInContainerBefore;
    local removeChild=ReactFiberHostConfig.removeChild;
    local removeChildFromContainer=ReactFiberHostConfig.removeChildFromContainer;
    local hideInstance=ReactFiberHostConfig.hideInstance;
    local hideTextInstance=ReactFiberHostConfig.hideTextInstance;
    local unhideInstance=ReactFiberHostConfig.unhideInstance;
    local unhideTextInstance=ReactFiberHostConfig.unhideTextInstance;
    local commitHydratedSuspenseInstance=ReactFiberHostConfig.commitHydratedSuspenseInstance;
    local clearContainer=ReactFiberHostConfig.clearContainer;
    local ReactFiberWorkLoop;
    local function resolveRetryWakeable(boundaryFiber,wakeable)
        if not(ReactFiberWorkLoop)then
             ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new")
        end;
        ReactFiberWorkLoop.resolveRetryWakeable(boundaryFiber,wakeable)
    end;
    local function markCommitTimeOfFallback()
        if not(ReactFiberWorkLoop)then
             ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new")
        end;
        ReactFiberWorkLoop.markCommitTimeOfFallback()
    end;
    local function schedulePassiveEffectCallback()
        console.warn(("ReactFiberCommitWork: schedulePassiveEffectCallback causes a dependency cycle\x0a")..(debug.traceback()))
    end;
    local function captureCommitPhaseError(rootFiber,sourceFiber,error_)
        console.warn("ReactFiberCommitWork: captureCommitPhaseError causes a dependency cycle");
        error(error_)
    end;
    local NoHookEffect=ReactHookEffectTags.NoFlags;
    local HookHasEffect=ReactHookEffectTags.HasEffect;
    local HookLayout=ReactHookEffectTags.Layout;
    local HookPassive=ReactHookEffectTags.Passive;
    local didWarnAboutReassigningPropsRef;
    local didWarnAboutReassigningProps=function()
        if not(didWarnAboutReassigningPropsRef)then
             didWarnAboutReassigningPropsRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberBeginWork.new").didWarnAboutReassigningProps
         end;
        return didWarnAboutReassigningPropsRef
     end;
    type("not printable... yet");
    local isHostParent,getHostSibling,insertOrAppendPlacementNode,insertOrAppendPlacementNodeIntoContainer,commitLayoutEffectsForHostRoot,commitLayoutEffectsForHostComponent,commitLayoutEffectsForClassComponent,unmountHostComponents,commitNestedUnmounts,commitUnmount;
    local nearestProfilerOnStack;
    local function callComponentWillUnmountWithTimer(current,instance)
        instance.props=current.memoizedProps;
        instance.state=current.memoizedState;
        if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(current.mode,ProfileMode))~=(0))then
             local ok,exception=xpcall(function()
                startLayoutEffectTimer();
                instance:componentWillUnmount()
            end,describeError);
            recordLayoutEffectDuration(current);
            if not(ok)then
                 error(exception)
            end
         else
             instance:componentWillUnmount()
        end
     end;
    function safelyCallComponentWillUnmount(current,instance,nearestMountedAncestor)
        local ok,error_=xpcall(callComponentWillUnmountWithTimer,describeError,current,instance);
        if not(ok)then
             captureCommitPhaseError(current,nearestMountedAncestor,error_)
        end
     end;
    local function safelyDetachRef(current,nearestMountedAncestor)
        local ref=current.ref;
        if(ref)~=(nil)then
             if(typeof(ref))==("function")then
                 local ok,error_=xpcall(ref,describeError);
                if not(ok)then
                     captureCommitPhaseError(current,nearestMountedAncestor,error_)
                end
             else
                 ref.current=nil
             end
         end
     end;
    local function safelyCallDestroy(current,nearestMountedAncestor,destroy)
        local ok,error_=xpcall(destroy,describeError);
        if not(ok)then
             captureCommitPhaseError(current,nearestMountedAncestor,error_)
        end
     end;
    local function commitBeforeMutationLifeCycles(current,finishedWork)
        if((((finishedWork.tag)==(FunctionComponent))or((finishedWork.tag)==(ForwardRef)))or((finishedWork.tag)==(SimpleMemoComponent)))or((finishedWork.tag)==(Block))then
             return
         elseif(finishedWork.tag)==(ClassComponent)then
             if(bit32.band(finishedWork.flags,Snapshot))~=(0)then
                 if(current)~=(nil)then
                     local prevProps=(current).memoizedProps;
                    local prevState=(current).memoizedState;
                    local instance=finishedWork.stateNode;
                    if __DEV__ then
                         if((finishedWork.type)==(finishedWork.elementType))and(not(didWarnAboutReassigningProps))then
                             if(instance.props)~=(finishedWork.memoizedProps)then
                                 console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                            end;
                            if(instance.state)~=(finishedWork.memoizedState)then
                                 console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                            end
                         end
                     end;
                    local snapshot=instance:getSnapshotBeforeUpdate((((finishedWork.elementType)==(finishedWork.type))and(prevProps))or(resolveDefaultProps(finishedWork.type,prevProps)),prevState);
                    if __DEV__ then
                        
                     end;
                    instance.__reactInternalSnapshotBeforeUpdate=snapshot
                 end
             end;
            return
         elseif(finishedWork.tag)==(HostRoot)then
             if supportsMutation then
                 if(bit32.band(finishedWork.flags,Snapshot))~=(0)then
                     local root=finishedWork.stateNode;
                    clearContainer(root.containerInfo)
                end
             end;
            return
         elseif((((finishedWork.tag)==(HostComponent))or((finishedWork.tag)==(HostText)))or((finishedWork.tag)==(HostPortal)))or((finishedWork.tag)==(IncompleteClassComponent))then
             return
         end;
        invariant(false,"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")
    end;
    local function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor)
        local updateQueue=finishedWork.updateQueue;
        local lastEffect;
        if(updateQueue)~=(nil)then
             lastEffect=(updateQueue).lastEffect
         end;
        if(lastEffect)~=(nil)then
             local firstEffect=lastEffect.next;
            local effect=firstEffect;
            repeat
                 if(bit32.band(effect.tag,flags))==(flags)then
                     local destroy=effect.destroy;
                    effect.destroy=nil;
                    if(destroy)~=(nil)then
                         safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy)
                    end
                 end;
                effect=effect.next
             until(effect)==(firstEffect)
        end
     end;
    local function commitHookEffectListMount(flags,finishedWork)
        local updateQueue=finishedWork.updateQueue;
        local lastEffect=if(updateQueue)~=(nil)then updateQueue.lastEffect else nil;
        if(lastEffect)~=(nil)then
             local firstEffect=lastEffect.next;
            local effect=firstEffect;
            repeat
                 if(bit32.band(effect.tag,flags))==(flags)then
                     local create=effect.create;
                    effect.destroy=create();
                    if __DEV__ then
                         local destroy=effect.destroy;
                        if((destroy)~=(nil))and((typeof(destroy))~=("function"))then
                             local addendum;
                            if(destroy)==(nil)then
                                 addendum=" You returned nil. If your effect does not require clean up, return nil (or nothing)."
                            elseif(typeof(destroy.andThen))==("function")then
                                 addendum="\x0a\x0aIt looks like you wrote useEffect(Promise.new(function() --[[...]] end) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\x0a\x0auseEffect(function()\x0a  function fetchData()\x0a    -- You can await here\x0a    local response = MyAPI.getData(someId):await()\x0a    -- ...\x0a  end\x0a  fetchData()\x0aend, {someId}) -- Or {} if effect doesn't need props or state\x0a\x0aLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"
                            else
                                 addendum=(" You returned: ")..(destroy)
                            end;
                            console.error("An effect function must not return anything besides a function, which is used for clean-up.%s",addendum)
                        end
                     end
                 end;
                effect=effect.next
             until(effect)==(firstEffect)
        end
     end;
    function commitProfilerPassiveEffect(finishedRoot,finishedWork)
        if(enableProfilerTimer)and(enableProfilerCommitHooks)then
             if(finishedWork.tag)==(Profiler)then
                 local passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;
                local id,onPostCommit=finishedWork.memoizedProps.id,finishedWork.memoizedProps.onPostCommit;
                local commitTime=getCommitTime();
                if(typeof(onPostCommit))==("function")then
                     if enableSchedulerTracing then
                         onPostCommit(id,if(finishedWork.alternate)==(nil)then"mount"else"update",passiveEffectDuration,commitTime,finishedRoot.memoizedInteractions)
                    else
                         onPostCommit(id,if(finishedWork.alternate)==(nil)then"mount"else"update",passiveEffectDuration,commitTime)
                    end
                 end
             end
         end
     end;
    local function recursivelyCommitLayoutEffects(finishedWork,finishedRoot,_captureCommitPhaseError,_schedulePassiveEffectCallback)
        if(_captureCommitPhaseError)~=(nil)then
             captureCommitPhaseError=_captureCommitPhaseError
         end;
        if(_schedulePassiveEffectCallback)~=(nil)then
             schedulePassiveEffectCallback=_schedulePassiveEffectCallback
         end;
        local flags=finishedWork.flags;
        local tag=finishedWork.tag;
        if(tag)==(Profiler)then
             local prevProfilerOnStack;
            if(enableProfilerTimer)and(enableProfilerCommitHooks)then
                 prevProfilerOnStack=nearestProfilerOnStack;
                nearestProfilerOnStack=finishedWork
             end;
            local child=finishedWork.child;
            while(child)~=(nil)do
                 local primarySubtreeFlags=bit32.band(finishedWork.subtreeFlags,LayoutMask);
                if(primarySubtreeFlags)~=(NoFlags)then
                     if __DEV__ then
                         local prevCurrentFiberInDEV=currentDebugFiberInDEV;
                        setCurrentDebugFiberInDEV(child);
                        invokeGuardedCallback(nil,recursivelyCommitLayoutEffects,nil,child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback);
                        if hasCaughtError()then
                             local error_=clearCaughtError();
                            captureCommitPhaseError(child,finishedWork,error_)
                        end;
                        if(prevCurrentFiberInDEV)~=(nil)then
                             setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
                        else
                             resetCurrentDebugFiberInDEV()
                        end
                     else
                         local ok,error_=xpcall(recursivelyCommitLayoutEffects,describeError,child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback);
                        if not(ok)then
                             captureCommitPhaseError(child,finishedWork,error_)
                        end
                     end
                 end;
                child=child.sibling
             end;
            local primaryFlags=bit32.band(flags,bit32.bor(Update,Callback));
            if(primaryFlags)~=(NoFlags)then
                 if enableProfilerTimer then
                     if __DEV__ then
                         local prevCurrentFiberInDEV=currentDebugFiberInDEV;
                        setCurrentDebugFiberInDEV(finishedWork);
                        invokeGuardedCallback(nil,commitLayoutEffectsForProfiler,nil,finishedWork,finishedRoot);
                        if hasCaughtError()then
                             local error_=clearCaughtError();
                            captureCommitPhaseError(finishedWork,finishedWork.return_,error_)
                        end;
                        if(prevCurrentFiberInDEV)~=(nil)then
                             setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
                        else
                             resetCurrentDebugFiberInDEV()
                        end
                     else
                         local ok,error_=xpcall(commitLayoutEffectsForProfiler,describeError,finishedWork,finishedRoot);
                        if not(ok)then
                             captureCommitPhaseError(finishedWork,finishedWork.return_,error_)
                        end
                     end
                 end
             end;
            if(enableProfilerTimer)and(enableProfilerCommitHooks)then
                 if(prevProfilerOnStack)~=(nil)then
                     prevProfilerOnStack.stateNode.effectDuration+=finishedWork.stateNode.effectDuration
                 end;
                nearestProfilerOnStack=prevProfilerOnStack
             end
         else
             local child=finishedWork.child;
            while(child)~=(nil)do
                 local primarySubtreeFlags=bit32.band(finishedWork.subtreeFlags,LayoutMask);
                if(primarySubtreeFlags)~=(NoFlags)then
                     if __DEV__ then
                         local prevCurrentFiberInDEV=ReactCurrentFiber.current;
                        setCurrentDebugFiberInDEV(child);
                        if(runDepth)<(MAX_RUN_DEPTH)then
                             runDepth+=1;
                            invokeGuardedCallback(nil,recursivelyCommitLayoutEffects,nil,child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback);
                            runDepth-=1;
                            if hasCaughtError()then
                                 local error_=clearCaughtError();
                                captureCommitPhaseError(child,finishedWork,error_)
                            end
                         else
                             recursivelyCommitLayoutEffects(child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback)
                        end;
                        if(prevCurrentFiberInDEV)~=(nil)then
                             setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
                        else
                             resetCurrentDebugFiberInDEV()
                        end
                     else
                         local ok,error_;
                        if(not(__YOLO__))and((runDepth)<(MAX_RUN_DEPTH))then
                             runDepth+=1;
                            ok,error_=xpcall(recursivelyCommitLayoutEffects,describeError,child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback);
                            runDepth-=1
                         else
                             ok=true;
                            recursivelyCommitLayoutEffects(child,finishedRoot,captureCommitPhaseError,schedulePassiveEffectCallback)
                        end;
                        if not(ok)then
                             captureCommitPhaseError(child,finishedWork,error_)
                        end
                     end
                 end;
                child=child.sibling
             end;
            local primaryFlags=bit32.band(flags,bit32.bor(Update,Callback));
            if(primaryFlags)~=(NoFlags)then
                 if((((tag)==(FunctionComponent))or((tag)==(ForwardRef)))or((tag)==(SimpleMemoComponent)))or((tag)==(Block))then
                     if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                         local ok,error_=xpcall(function()
                            startLayoutEffectTimer();
                            commitHookEffectListMount(bit32.bor(HookLayout,HookHasEffect),finishedWork)
                        end,describeError);
                        recordLayoutEffectDuration(finishedWork);
                        if not(ok)then
                             error(error_)
                        end
                     else
                         commitHookEffectListMount(bit32.bor(HookLayout,HookHasEffect),finishedWork)
                    end;
                    if(bit32.band(finishedWork.subtreeFlags,PassiveMask))~=(NoFlags)then
                         schedulePassiveEffectCallback()
                    end
                 elseif(tag)==(ClassComponent)then
                     commitLayoutEffectsForClassComponent(finishedWork)
                elseif(tag)==(HostRoot)then
                     commitLayoutEffectsForHostRoot(finishedWork)
                elseif(tag)==(HostComponent)then
                     commitLayoutEffectsForHostComponent(finishedWork)
                elseif(tag)==(SuspenseComponent)then
                     commitSuspenseHydrationCallbacks(finishedRoot,finishedWork)
                elseif((((((((tag)==(FundamentalComponent))or((tag)==(HostPortal)))or((tag)==(HostText)))or((tag)==(IncompleteClassComponent)))or((tag)==(LegacyHiddenComponent)))or((tag)==(OffscreenComponent)))or((tag)==(ScopeComponent)))or((tag)==(SuspenseListComponent))then
                    
                 else
                     invariant(false,"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")
                end
             end;
            if(bit32.band(flags,Ref))~=(0)then
                 commitAttachRef(finishedWork)
            end
         end
     end;
    function commitLayoutEffectsForProfiler(finishedWork,finishedRoot)
        if enableProfilerTimer then
             local flags=finishedWork.flags;
            local current=finishedWork.alternate;
            local onCommit,onRender=finishedWork.memoizedProps.onCommit,finishedWork.memoizedProps.onRender;
            local effectDuration=finishedWork.stateNode.effectDuration;
            local commitTime=getCommitTime();
            local OnRenderFlag=Update;
            local OnCommitFlag=Callback;
            if((bit32.band(flags,OnRenderFlag))~=(NoFlags))and(isCallable(onRender))then
                 if enableSchedulerTracing then
                     onRender(finishedWork.memoizedProps.id,if(current)==(nil)then"mount"else"update",finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime,finishedRoot.memoizedInteractions)
                else
                     onRender(finishedWork.memoizedProps.id,if(current)==(nil)then"mount"else"update",finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime)
                end
             end;
            if enableProfilerCommitHooks then
                 if((bit32.band(flags,OnCommitFlag))~=(NoFlags))and(isCallable(onCommit))then
                     if enableSchedulerTracing then
                         onCommit(finishedWork.memoizedProps.id,if(current)==(nil)then"mount"else"update",effectDuration,commitTime,finishedRoot.memoizedInteractions)
                    else
                         onCommit(finishedWork.memoizedProps.id,if(current)==(nil)then"mount"else"update",effectDuration,commitTime)
                    end
                 end
             end
         end
     end;
    function commitLayoutEffectsForClassComponent(finishedWork)
        local instance=finishedWork.stateNode;
        local current=finishedWork.alternate;
        if(bit32.band(finishedWork.flags,Update))~=(0)then
             if(current)==(nil)then
                 if __DEV__ then
                     if((finishedWork.type)==(finishedWork.elementType))and(not(didWarnAboutReassigningProps))then
                         if(instance.props)~=(finishedWork.memoizedProps)then
                             console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                        end;
                        if(instance.state)~=(finishedWork.memoizedState)then
                             console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                        end
                     end
                 end;
                if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                     local ok,result=xpcall(function()
                        startLayoutEffectTimer();
                        instance:componentDidMount()
                    end,describeError);
                    recordLayoutEffectDuration(finishedWork);
                    if not(ok)then
                         error(result)
                    end
                 else
                     instance:componentDidMount()
                end
             else
                 local prevProps=(((finishedWork.elementType)==(finishedWork.type))and(current.memoizedProps))or(resolveDefaultProps(finishedWork.type,current.memoizedProps));
                local prevState=current.memoizedState;
                if __DEV__ then
                     if((finishedWork.type)==(finishedWork.elementType))and(not(didWarnAboutReassigningProps))then
                         if(instance.props)~=(finishedWork.memoizedProps)then
                             console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                        end;
                        if(instance.state)~=(finishedWork.memoizedState)then
                             console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                        end
                     end
                 end;
                if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                     local ok,result=xpcall(function()
                        startLayoutEffectTimer();
                        instance:componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)
                    end,describeError);
                    recordLayoutEffectDuration(finishedWork);
                    if not(ok)then
                         error(result)
                    end
                 else
                     instance:componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)
                end
             end
         end;
        local updateQueue=finishedWork.updateQueue;
        if(updateQueue)~=(nil)then
             if __DEV__ then
                 if((finishedWork.type)==(finishedWork.elementType))and(not(didWarnAboutReassigningProps))then
                     if(instance.props)~=(finishedWork.memoizedProps)then
                         console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                    end;
                    if(instance.state)~=(finishedWork.memoizedState)then
                         console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",(getComponentName(finishedWork.type))or("instance"))
                    end
                 end
             end;
            commitUpdateQueue(finishedWork,updateQueue,instance)
        end
     end;
    function commitLayoutEffectsForHostRoot(finishedWork)
        local updateQueue=finishedWork.updateQueue;
        if(updateQueue)~=(nil)then
             local instance;
            if(finishedWork.child)~=(nil)then
                 local child=finishedWork.child;
                if(child.tag)==(HostComponent)then
                     instance=getPublicInstance(child.stateNode)
                elseif(child.tag)==(ClassComponent)then
                     instance=child.stateNode
                 end
             end;
            commitUpdateQueue(finishedWork,updateQueue,instance)
        end
     end;
    function commitLayoutEffectsForHostComponent(finishedWork)
        local instance=finishedWork.stateNode;
        local current=finishedWork.alternate;
        if((current)==(nil))and((bit32.band(finishedWork.flags,Update))~=(0))then
             local type=finishedWork.type;
            local props=finishedWork.memoizedProps;
            commitMount(instance,type,props,finishedWork)
        end
     end;
    local function hideOrUnhideAllChildren(finishedWork,isHidden)
        if supportsMutation then
             local node=finishedWork;
            while true do
                 if(node.tag)==(HostComponent)then
                     local instance=node.stateNode;
                    if isHidden then
                         hideInstance(instance)
                    else
                         unhideInstance(node.stateNode,node.memoizedProps)
                    end
                 elseif(node.tag)==(HostText)then
                     local instance=node.stateNode;
                    if isHidden then
                         hideTextInstance(instance)
                    else
                         unhideTextInstance(instance,node.memoizedProps)
                    end
                 elseif(((((node.tag)==(OffscreenComponent))or((node.tag)==(LegacyHiddenComponent))))and(((node.memoizedState))~=(nil)))and((node)~=(finishedWork))then
                    
                 elseif(node.child)~=(nil)then
                    (node.child).return_=node;
                    node=node.child;
                    continue
                 end;
                if(node)==(finishedWork)then
                     return
                 end;
                while(node.sibling)==(nil)do
                     if((node.return_)==(nil))or((node.return_)==(finishedWork))then
                         return
                     end;
                    node=node.return_
                 end;
                (node.sibling).return_=node.return_;
                node=node.sibling
             end
         end
     end;
    function commitAttachRef(finishedWork)
        local ref=finishedWork.ref;
        if(ref)~=(nil)then
             local instance=finishedWork.stateNode;
            local instanceToUse;
            if(finishedWork.tag)==(HostComponent)then
                 instanceToUse=getPublicInstance(instance)
            else
                 instanceToUse=instance
             end;
            if(typeof(ref))==("function")then
                 ref(instanceToUse)
            else
                 if __DEV__ then
                     if(typeof(ref))~=("table")then
                         console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",(getComponentName(finishedWork.type))or("instance"));
                        return
                     end
                 end;
                ref.current=instanceToUse
             end
         end
     end;
    function commitDetachRef(current)
        local currentRef=current.ref;
        if(currentRef)~=(nil)then
             if(typeof(currentRef))==("function")then
                 currentRef(nil)
            else
                 currentRef.current=nil
             end
         end
     end;
    function commitUnmount(finishedRoot,current,nearestMountedAncestor,renderPriorityLevel)
        onCommitUnmount(current);
        if(((((current.tag)==(FunctionComponent))or((current.tag)==(ForwardRef)))or((current.tag)==(MemoComponent)))or((current.tag)==(SimpleMemoComponent)))or((current.tag)==(Block))then
             local updateQueue=current.updateQueue;
            if(updateQueue)~=(nil)then
                 local lastEffect=(updateQueue).lastEffect;
                if(lastEffect)~=(nil)then
                     local firstEffect=lastEffect.next;
                    local effect=firstEffect;
                    repeat
                         if(effect.destroy)~=(nil)then
                             if(bit32.band(effect.tag,HookLayout))~=(NoHookEffect)then
                                 if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(current.mode,ProfileMode))~=(0))then
                                     startLayoutEffectTimer();
                                    safelyCallDestroy(current,nearestMountedAncestor,effect.destroy);
                                    recordLayoutEffectDuration(current)
                                else
                                     safelyCallDestroy(current,nearestMountedAncestor,effect.destroy)
                                end
                             end
                         end;
                        effect=effect.next
                     until(effect)==(firstEffect)
                end
             end;
            return
         elseif(current.tag)==(ClassComponent)then
             safelyDetachRef(current,nearestMountedAncestor);
            local instance=current.stateNode;
            if(typeof(instance.componentWillUnmount))==("function")then
                 safelyCallComponentWillUnmount(current,instance,nearestMountedAncestor)
            end;
            return
         elseif(current.tag)==(HostComponent)then
             safelyDetachRef(current,nearestMountedAncestor);
            return
         elseif(current.tag)==(HostPortal)then
             if supportsMutation then
                 unmountHostComponents(finishedRoot,current,nearestMountedAncestor,renderPriorityLevel)
            elseif supportsPersistence then
                 unimplemented("emptyPortalContainer")
            end;
            return
         end
     end;
    function commitNestedUnmounts(finishedRoot,root,nearestMountedAncestor,renderPriorityLevel)
        local node=root;
        while true do
             commitUnmount(finishedRoot,node,nearestMountedAncestor,renderPriorityLevel);
            if((node.child)~=(nil))and(((not(supportsMutation))or((node.tag)~=(HostPortal))))then
                (node.child).return_=node;
                node=node.child;
                continue
             end;
            if(node)==(root)then
                 return
             end;
            while(node.sibling)==(nil)do
                 if((node.return_)==(nil))or((node.return_)==(root))then
                     return
                 end;
                node=node.return_
             end;
            (node.sibling).return_=node.return_;
            node=node.sibling
         end
     end;
    local function detachFiberMutation(fiber)
        local alternate=fiber.alternate;
        if(alternate)~=(nil)then
             alternate.return_=nil;
            fiber.alternate=nil
         end;
        fiber.return_=nil
     end;
    local function getHostParentFiber(fiber)
        local parent=fiber.return_;
        while(parent)~=(nil)do
             if isHostParent(parent)then
                 return parent
             end;
            parent=parent.return_
         end;
        error(Error.new("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."))
    end;
    function isHostParent(fiber)
        return(((fiber.tag)==(HostComponent))or((fiber.tag)==(HostRoot)))or((fiber.tag)==(HostPortal))
    end;
    function getHostSibling(fiber)
        local node=fiber;
        while true do
             local continueOuter=false;
            while(node.sibling)==(nil)do
                 if((node.return_)==(nil))or(isHostParent(node.return_))then
                     return nil
                 end;
                node=node.return_
             end;
            (node.sibling).return_=node.return_;
            node=node.sibling;
            while(((node.tag)~=(HostComponent))and((node.tag)~=(HostText)))and((node.tag)~=(DehydratedFragment))do
                 if(bit32.band(node.flags,Placement))~=(0)then
                     continueOuter=true;
                    break
                 end;
                if((node.child)==(nil))or((node.tag)==(HostPortal))then
                     continueOuter=true;
                    break
                 else
                    (node.child).return_=node;
                    node=node.child
                 end
             end;
            if continueOuter then
                 continue
             end;
            if(bit32.band(node.flags,Placement))==(0)then
                 return node.stateNode
             end
         end
     end;
    local function commitPlacement(finishedWork)
        if not(supportsMutation)then
             return
         end;
        local parentFiber=getHostParentFiber(finishedWork);
        local parent;
        local isContainer;
        local parentStateNode=parentFiber.stateNode;
        if(parentFiber.tag)==(HostComponent)then
             parent=parentStateNode;
            isContainer=false
         elseif(parentFiber.tag)==(HostRoot)then
             parent=parentStateNode.containerInfo;
            isContainer=true
         elseif(parentFiber.tag)==(HostPortal)then
             parent=parentStateNode.containerInfo;
            isContainer=true
         else
             invariant(false,"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.")
        end;
        if(bit32.band(parentFiber.flags,ContentReset))~=(0)then
             resetTextContent(parent);
            parentFiber.flags=bit32.band(parentFiber.flags,bit32.bnot(ContentReset))
        end;
        local before=getHostSibling(finishedWork);
        if isContainer then
             insertOrAppendPlacementNodeIntoContainer(finishedWork,before,parent)
        else
             insertOrAppendPlacementNode(finishedWork,before,parent)
        end
     end;
    function insertOrAppendPlacementNodeIntoContainer(node,before,parent)
        local tag=node.tag;
        local isHost=((tag)==(HostComponent))or((tag)==(HostText));
        if isHost then
             local stateNode=node.stateNode;
            if before then
                 insertInContainerBefore(parent,stateNode,before)
            else
                 appendChildToContainer(parent,stateNode)
            end
         elseif(tag)==(HostPortal)then
            
         else
             local child=node.child;
            if(child)~=(nil)then
                 insertOrAppendPlacementNodeIntoContainer(child,before,parent);
                local sibling=child.sibling;
                while(sibling)~=(nil)do
                     insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);
                    sibling=sibling.sibling
                 end
             end
         end
     end;
    function insertOrAppendPlacementNode(node,before,parent)
        local tag=node.tag;
        local isHost=((tag)==(HostComponent))or((tag)==(HostText));
        if isHost then
             local stateNode=node.stateNode;
            if before then
                 insertBefore(parent,stateNode,before)
            else
                 appendChild(parent,stateNode)
            end
         elseif(tag)==(HostPortal)then
            
         else
             local child=node.child;
            if(child)~=(nil)then
                 insertOrAppendPlacementNode(child,before,parent);
                local sibling=child.sibling;
                while(sibling)~=(nil)do
                     insertOrAppendPlacementNode(sibling,before,parent);
                    sibling=sibling.sibling
                 end
             end
         end
     end;
    function unmountHostComponents(finishedRoot,current,nearestMountedAncestor,renderPriorityLevel)
        local node=current;
        local currentParentIsValid=false;
        local currentParent;
        local currentParentIsContainer;
        while true do
             if not(currentParentIsValid)then
                 local parent=node.return_;
                while true do
                     if(parent)==(nil)then
                         error(Error.new("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."))
                    end;
                    local parentStateNode=parent.stateNode;
                    if(parent.tag)==(HostComponent)then
                         currentParent=parentStateNode;
                        currentParentIsContainer=false;
                        break
                     elseif(parent.tag)==(HostRoot)then
                         currentParent=parentStateNode.containerInfo;
                        currentParentIsContainer=true;
                        break
                     elseif(parent.tag)==(HostPortal)then
                         currentParent=parentStateNode.containerInfo;
                        currentParentIsContainer=true;
                        break
                     end;
                    parent=parent.return_
                 end;
                currentParentIsValid=true
             end;
            if((node.tag)==(HostComponent))or((node.tag)==(HostText))then
                 commitNestedUnmounts(finishedRoot,node,nearestMountedAncestor,renderPriorityLevel);
                if currentParentIsContainer then
                     removeChildFromContainer(currentParent,node.stateNode)
                else
                     removeChild(currentParent,node.stateNode)
                end
             elseif(node.tag)==(HostPortal)then
                 if(node.child)~=(nil)then
                     currentParent=node.stateNode.containerInfo;
                    currentParentIsContainer=true;
                    node.child.return_=node;
                    node=node.child;
                    continue
                 end
             else
                 commitUnmount(finishedRoot,node,nearestMountedAncestor,renderPriorityLevel);
                if(node.child)~=(nil)then
                     node.child.return_=node;
                    node=node.child;
                    continue
                 end
             end;
            if(node)==(current)then
                 return
             end;
            while(node.sibling)==(nil)do
                 if((node.return_)==(nil))or((node.return_)==(current))then
                     return
                 end;
                node=node.return_;
                if(node.tag)==(HostPortal)then
                     currentParentIsValid=false
                 end
             end;
            (node.sibling).return_=node.return_;
            node=node.sibling
         end
     end;
    local function commitDeletion(finishedRoot,current,nearestMountedAncestor,renderPriorityLevel)
        unmountHostComponents(finishedRoot,current,nearestMountedAncestor,renderPriorityLevel);
        local alternate=current.alternate;
        detachFiberMutation(current);
        if(alternate)~=(nil)then
             detachFiberMutation(alternate)
        end
     end;
    local function commitWork(current,finishedWork)
        if(((((finishedWork.tag)==(FunctionComponent))or((finishedWork.tag)==(ForwardRef)))or((finishedWork.tag)==(MemoComponent)))or((finishedWork.tag)==(SimpleMemoComponent)))or((finishedWork.tag)==(Block))then
             if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                 local ok,result=xpcall(function()
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(bit32.bor(HookLayout,HookHasEffect),finishedWork,finishedWork.return_)
                end,describeError);
                recordLayoutEffectDuration(finishedWork);
                if not(ok)then
                     error(result)
                end
             else
                 commitHookEffectListUnmount(bit32.bor(HookLayout,HookHasEffect),finishedWork,finishedWork.return_)
            end;
            return
         elseif(finishedWork.tag)==(ClassComponent)then
             return
         elseif(finishedWork.tag)==(HostComponent)then
             local instance=finishedWork.stateNode;
            if(instance)~=(nil)then
                 local newProps=finishedWork.memoizedProps;
                local oldProps;
                if current then
                     oldProps=current.memoizedProps
                 else
                     oldProps=newProps
                 end;
                local type=finishedWork.type;
                local updatePayload=finishedWork.updateQueue;
                finishedWork.updateQueue=nil;
                if(updatePayload)~=(nil)then
                     commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork)
                end
             end;
            return
         elseif(finishedWork.tag)==(HostText)then
             invariant((finishedWork.stateNode)~=(nil),"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            local textInstance=finishedWork.stateNode;
            local newText=finishedWork.memoizedProps;
            local oldText;
            if(current)~=(nil)then
                 oldText=(current).memoizedProps;
                oldText=newText
             end;
            commitTextUpdate(textInstance,oldText,newText);
            return
         elseif(finishedWork.tag)==(HostRoot)then
             if supportsHydration then
                 local root=finishedWork.stateNode;
                if root.hydrate then
                     root.hydrate=false;
                    unimplemented("commitWork: HostRoot: commitHydratedContainer")
                end
             end;
            return
         elseif(finishedWork.tag)==(Profiler)then
             return
         elseif(finishedWork.tag)==(SuspenseComponent)then
             commitSuspenseComponent(finishedWork);
            attachSuspenseRetryListeners(finishedWork);
            return
         elseif(finishedWork.tag)==(SuspenseListComponent)then
             unimplemented("commitWork: SuspenseListComponent")
        elseif(finishedWork.tag)==(IncompleteClassComponent)then
             return
         elseif((finishedWork.tag)==(OffscreenComponent))or((finishedWork.tag)==(LegacyHiddenComponent))then
             local newState=finishedWork.memoizedState;
            local isHidden=(newState)~=(nil);
            hideOrUnhideAllChildren(finishedWork,isHidden);
            return
         end;
        invariant(false,"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")
    end;
    function commitSuspenseComponent(finishedWork)
        local newState=finishedWork.memoizedState;
        if(newState)~=(nil)then
             markCommitTimeOfFallback();
            if supportsMutation then
                 local primaryChildParent=finishedWork.child;
                hideOrUnhideAllChildren(primaryChildParent,true)
            end
         end;
        if(enableSuspenseCallback)and((newState)~=(nil))then
             local suspenseCallback=finishedWork.memoizedProps.suspenseCallback;
            if(typeof(suspenseCallback))==("function")then
                 local wakeables=finishedWork.updateQueue;
                if(wakeables)~=(nil)then
                     suspenseCallback(table.clone(wakeables))
                end
             elseif __DEV__ then
                 if(suspenseCallback)~=(nil)then
                     console.error("Unexpected type for suspenseCallback: %s",tostring(suspenseCallback))
                end
             end
         end
     end;
    function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork)
        if not(supportsHydration)then
             return
         end;
        local newState=finishedWork.memoizedState;
        if(newState)==(nil)then
             local current=finishedWork.alternate;
            if(current)~=(nil)then
                 local prevState=current.memoizedState;
                if(prevState)~=(nil)then
                     local suspenseInstance=prevState.dehydrated;
                    if(suspenseInstance)~=(nil)then
                         commitHydratedSuspenseInstance(suspenseInstance);
                        if enableSuspenseCallback then
                             local hydrationCallbacks=finishedRoot.hydrationCallbacks;
                            if(hydrationCallbacks)~=(nil)then
                                 local onHydrated=hydrationCallbacks.onHydrated;
                                if onHydrated then
                                     onHydrated(suspenseInstance)
                                end
                             end
                         end
                     end
                 end
             end
         end
     end;
    function attachSuspenseRetryListeners(finishedWork)
        local wakeables=finishedWork.updateQueue;
        if(wakeables)~=(nil)then
             finishedWork.updateQueue=nil;
            local retryCache=finishedWork.stateNode;
            if(retryCache)==(nil)then
                 finishedWork.stateNode=Set.new();
                retryCache=finishedWork.stateNode
             end;
            for wakeable,_ in wakeables do
                 local retry=function()
                    return resolveRetryWakeable(finishedWork,wakeable)
                end;
                if not(retryCache:has(wakeable))then
                     if enableSchedulerTracing then
                         if(wakeable.__reactDoNotTraceInteractions)~=(true)then
                             retry=Schedule_tracing_wrap(retry)
                        end
                     end;
                    retryCache:add(wakeable);
                    wakeable:andThen(function()
                        return retry()
                    end,function()
                        return retry()
                    end)
                end
             end
         end
     end;
    function isSuspenseBoundaryBeingHidden(current,finishedWork)
        if(current)~=(nil)then
             local oldState=(current).memoizedState;
            if((oldState)==(nil))or(((oldState).dehydrated)~=(nil))then
                 local newState=finishedWork.memoizedState;
                return((newState)~=(nil))and(((newState).dehydrated)==(nil))
            end
         end;
        return false
     end;
    function commitResetTextContent(current)
        if not(supportsMutation)then
             return
         end;
        resetTextContent(current.stateNode)
    end;
    local function commitPassiveUnmount(finishedWork)
        if((((finishedWork.tag)==(FunctionComponent))or((finishedWork.tag)==(ForwardRef)))or((finishedWork.tag)==(SimpleMemoComponent)))or((finishedWork.tag)==(Block))then
             if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                 startPassiveEffectTimer();
                commitHookEffectListUnmount(bit32.bor(HookPassive,HookHasEffect),finishedWork,finishedWork.return_);
                recordPassiveEffectDuration(finishedWork)
            else
                 commitHookEffectListUnmount(bit32.bor(HookPassive,HookHasEffect),finishedWork,finishedWork.return_)
            end
         end
     end;
    local function commitPassiveUnmountInsideDeletedTree(current,nearestMountedAncestor)
        if((((current.tag)==(FunctionComponent))or((current.tag)==(ForwardRef)))or((current.tag)==(SimpleMemoComponent)))or((current.tag)==(Block))then
             if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(current.mode,ProfileMode))~=(0))then
                 startPassiveEffectTimer();
                commitHookEffectListUnmount(HookPassive,current,nearestMountedAncestor);
                recordPassiveEffectDuration(current)
            else
                 commitHookEffectListUnmount(HookPassive,current,nearestMountedAncestor)
            end
         end
     end;
    local function commitPassiveMount(finishedRoot,finishedWork)
        if((((finishedWork.tag)==(FunctionComponent))or((finishedWork.tag)==(ForwardRef)))or((finishedWork.tag)==(SimpleMemoComponent)))or((finishedWork.tag)==(Block))then
             if((enableProfilerTimer)and(enableProfilerCommitHooks))and((bit32.band(finishedWork.mode,ProfileMode))~=(0))then
                 startPassiveEffectTimer();
                local ok,error_=xpcall(commitHookEffectListMount,describeError,bit32.bor(HookPassive,HookHasEffect),finishedWork);
                recordPassiveEffectDuration(finishedWork);
                if not(ok)then
                     error(error_)
                end
             else
                 commitHookEffectListMount(bit32.bor(HookPassive,HookHasEffect),finishedWork)
            end
         elseif(finishedWork.tag)==(Profiler)then
             commitProfilerPassiveEffect(finishedRoot,finishedWork)
        end
     end;
    function invokeLayoutEffectMountInDEV(fiber)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             if((((fiber.tag)==(FunctionComponent))or((fiber.tag)==(ForwardRef)))or((fiber.tag)==(SimpleMemoComponent)))or((fiber.tag)==(Block))then
                 invokeGuardedCallback(nil,commitHookEffectListMount,nil,bit32.bor(HookLayout,HookHasEffect),fiber);
                if hasCaughtError()then
                     local mountError=clearCaughtError();
                    captureCommitPhaseError(fiber,fiber.return_,mountError)
                end;
                return
             end
         elseif(fiber.tag)==(ClassComponent)then
             local instance=fiber.stateNode;
            invokeGuardedCallback(nil,instance.componentDidMount,instance);
            if hasCaughtError()then
                 local mountError=clearCaughtError();
                captureCommitPhaseError(fiber,fiber.return_,mountError)
            end;
            return
         end
     end;
    function invokePassiveEffectMountInDEV(fiber)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             if((((fiber.tag)==(FunctionComponent))or((fiber.tag)==(ForwardRef)))or((fiber.tag)==(SimpleMemoComponent)))or((fiber.tag)==(Block))then
                 invokeGuardedCallback(nil,commitHookEffectListMount,nil,bit32.bor(HookPassive,HookHasEffect),fiber);
                if hasCaughtError()then
                     local mountError=clearCaughtError();
                    captureCommitPhaseError(fiber,fiber.return_,mountError)
                end;
                return
             end
         end
     end;
    function invokeLayoutEffectUnmountInDEV(fiber)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             if((((fiber.tag)==(FunctionComponent))or((fiber.tag)==(ForwardRef)))or((fiber.tag)==(SimpleMemoComponent)))or((fiber.tag)==(Block))then
                 invokeGuardedCallback(nil,commitHookEffectListUnmount,nil,bit32.bor(HookLayout,HookHasEffect),fiber,fiber.return_);
                if hasCaughtError()then
                     local unmountError=clearCaughtError();
                    captureCommitPhaseError(fiber,fiber.return_,unmountError)
                end;
                return
             end
         elseif(fiber.tag)==(ClassComponent)then
             local instance=fiber.stateNode;
            if(typeof(instance.componentWillUnmount))==("function")then
                 safelyCallComponentWillUnmount(fiber,instance,fiber.return_)
            end;
            return
         end
     end;
    function invokePassiveEffectUnmountInDEV(fiber)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             if((((fiber.tag)==(FunctionComponent))or((fiber.tag)==(ForwardRef)))or((fiber.tag)==(SimpleMemoComponent)))or((fiber.tag)==(Block))then
                 invokeGuardedCallback(nil,commitHookEffectListUnmount,nil,bit32.bor(HookPassive,HookHasEffect),fiber,fiber.return_);
                if hasCaughtError()then
                     local unmountError=clearCaughtError();
                    captureCommitPhaseError(fiber,fiber.return_,unmountError)
                end;
                return
             end
         end
     end;
    return{["safelyCallDestroy"]=safelyCallDestroy,["commitBeforeMutationLifeCycles"]=commitBeforeMutationLifeCycles,["commitResetTextContent"]=commitResetTextContent,["commitPlacement"]=commitPlacement,["commitDeletion"]=commitDeletion,["commitWork"]=commitWork,["commitAttachRef"]=commitAttachRef,["commitDetachRef"]=commitDetachRef,["commitPassiveUnmount"]=commitPassiveUnmount,["commitPassiveUnmountInsideDeletedTree"]=commitPassiveUnmountInsideDeletedTree,["commitPassiveMount"]=commitPassiveMount,["invokeLayoutEffectMountInDEV"]=invokeLayoutEffectMountInDEV,["invokeLayoutEffectUnmountInDEV"]=invokeLayoutEffectUnmountInDEV,["invokePassiveEffectMountInDEV"]=invokePassiveEffectMountInDEV,["invokePassiveEffectUnmountInDEV"]=invokePassiveEffectUnmountInDEV,["isSuspenseBoundaryBeingHidden"]=isSuspenseBoundaryBeingHidden,["recursivelyCommitLayoutEffects"]=recursivelyCommitLayoutEffects}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\promise.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.promise",function()
    return tkpack.include("game.Packages._Index.jsdotlua_promise@3.5.2.promise")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberNewContext.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Number=LuauPolyfill.Number;
    local Error=LuauPolyfill.Error;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local isPrimaryRenderer=ReactFiberHostConfig.isPrimaryRenderer;
    local createCursor=ReactFiberStack.createCursor;
    local push=ReactFiberStack.push;
    local pop=ReactFiberStack.pop;
    local MAX_SIGNED_31_BIT_INT=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.MaxInts").MAX_SIGNED_31_BIT_INT;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local ContextProvider=ReactWorkTags.ContextProvider;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local NoLanes=ReactFiberLane.NoLanes;
    local NoTimestamp=ReactFiberLane.NoTimestamp;
    local isSubsetOfLanes=ReactFiberLane.isSubsetOfLanes;
    local includesSomeLane=ReactFiberLane.includesSomeLane;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local pickArbitraryLane=ReactFiberLane.pickArbitraryLane;
    local is=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").objectIs;
    local createUpdate=ReactUpdateQueue.createUpdate;
    local ForceUpdate=ReactUpdateQueue.ForceUpdate;
    local exports={};
    local valueCursor=createCursor(nil);
    local rendererSigil;
    if _G.__DEV__ then
         rendererSigil={}
    end;
    local currentlyRenderingFiber;
    local lastContextDependency;
    local lastContextWithAllBitsObserved;
    local isDisallowedContextReadInDEV=false;
    exports.resetContextDependencies=function()
        currentlyRenderingFiber=nil;
        lastContextDependency=nil;
        lastContextWithAllBitsObserved=nil;
        if _G.__DEV__ then
             isDisallowedContextReadInDEV=false
         end
     end;
    exports.enterDisallowedContextReadInDEV=function()
        if _G.__DEV__ then
             isDisallowedContextReadInDEV=true
         end
     end;
    exports.exitDisallowedContextReadInDEV=function()
        if _G.__DEV__ then
             isDisallowedContextReadInDEV=false
         end
     end;
    exports.pushProvider=function(providerFiber,nextValue)
        local context=providerFiber.type._context;
        if isPrimaryRenderer then
             push(valueCursor,context._currentValue,providerFiber);
            context._currentValue=nextValue;
            if _G.__DEV__ then
                 if((context._currentRenderer)~=(nil))and((context._currentRenderer)~=(rendererSigil))then
                     console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.")
                end;
                context._currentRenderer=rendererSigil
             end
         else
             push(valueCursor,context._currentValue2,providerFiber);
            context._currentValue2=nextValue;
            if _G.__DEV__ then
                 if((context._currentRenderer2)~=(nil))and((context._currentRenderer2)~=(rendererSigil))then
                     console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.")
                end;
                context._currentRenderer2=rendererSigil
             end
         end
     end;
    exports.popProvider=function(providerFiber)
        local currentValue=valueCursor.current;
        pop(valueCursor,providerFiber);
        local context=providerFiber.type._context;
        if isPrimaryRenderer then
             context._currentValue=currentValue
         else
             context._currentValue2=currentValue
         end
     end;
    exports.calculateChangedBits=function(context,newValue,oldValue)
        if is(oldValue,newValue)then
             return 0
         else
             local changedBits=MAX_SIGNED_31_BIT_INT;
            if(typeof(context._calculateChangedBits))==("function")then
                 changedBits=context._calculateChangedBits(oldValue,newValue)
            end;
            return math.floor(changedBits)
        end
     end;
    exports.scheduleWorkOnParentPath=function(parent,renderLanes)
        local node=parent;
        while(node)~=(nil)do
             local alternate=node.alternate;
            if not(isSubsetOfLanes(node.childLanes,renderLanes))then
                 node.childLanes=mergeLanes(node.childLanes,renderLanes);
                if(alternate)~=(nil)then
                     alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes)
                end
             elseif((alternate)~=(nil))and(not(isSubsetOfLanes(alternate.childLanes,renderLanes)))then
                 alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes)
            else
                 break
             end;
            node=node.return_
         end
     end;
    exports.propagateContextChange=function(workInProgress,context,changedBits,renderLanes)
        local fiber=workInProgress.child;
        if(fiber)~=(nil)then
             fiber.return_=workInProgress
         end;
        while(fiber)~=(nil)do
             local nextFiber;
            local list=fiber.dependencies;
            if(list)~=(nil)then
                 nextFiber=fiber.child;
                local dependency=list.firstContext;
                while(dependency)~=(nil)do
                     if((dependency.context)==(context))and((bit32.band(dependency.observedBits,changedBits))~=(0))then
                         if(fiber.tag)==(ClassComponent)then
                             local update=createUpdate(NoTimestamp,pickArbitraryLane(renderLanes));
                            update.tag=ForceUpdate;
                            local updateQueue=fiber.updateQueue;
                            if(updateQueue)==(nil)then
                                
                             else
                                 local sharedQueue=(updateQueue).shared;
                                local pending=sharedQueue.pending;
                                if(pending)==(nil)then
                                     update.next=update
                                 else
                                     update.next=pending.next;
                                    pending.next=update
                                 end;
                                sharedQueue.pending=update
                             end
                         end;
                        fiber.lanes=bit32.bor(fiber.lanes,renderLanes);
                        local alternate=fiber.alternate;
                        if(alternate)~=(nil)then
                             alternate.lanes=bit32.bor(alternate.lanes,renderLanes)
                        end;
                        exports.scheduleWorkOnParentPath(fiber.return_,renderLanes);
                        list.lanes=bit32.bor(list.lanes,renderLanes);
                        break
                     end;
                    dependency=dependency.next
                 end
             elseif(fiber.tag)==(ContextProvider)then
                 if(fiber.type)==(workInProgress.type)then
                     nextFiber=nil
                 else
                     nextFiber=fiber.child
                 end
             else
                 nextFiber=fiber.child
             end;
            if(nextFiber)~=(nil)then
                 nextFiber.return_=fiber
             else
                 nextFiber=fiber;
                while(nextFiber)~=(nil)do
                     if(nextFiber)==(workInProgress)then
                         nextFiber=nil;
                        break
                     end;
                    local sibling=nextFiber.sibling;
                    if(sibling)~=(nil)then
                         sibling.return_=nextFiber.return_;
                        nextFiber=sibling;
                        break
                     end;
                    nextFiber=nextFiber.return_
                 end
             end;
            fiber=nextFiber
         end
     end;
    exports.prepareToReadContext=function(workInProgress,renderLanes,markWorkInProgressReceivedUpdate)
        currentlyRenderingFiber=workInProgress;
        lastContextDependency=nil;
        lastContextWithAllBitsObserved=nil;
        local dependencies=workInProgress.dependencies;
        if(dependencies)~=(nil)then
             local firstContext=dependencies.firstContext;
            if(firstContext)~=(nil)then
                 if includesSomeLane(dependencies.lanes,renderLanes)then
                     markWorkInProgressReceivedUpdate()
                end;
                dependencies.firstContext=nil
             end
         end
     end;
    exports.readContext=function(context,observedBits)
        if _G.__DEV__ then
             if isDisallowedContextReadInDEV then
                 console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")
            end
         end;
        if(lastContextWithAllBitsObserved)==(context)then
            
         elseif((observedBits)==(false))or((observedBits)==(0))then
            
         else
             local resolvedObservedBits;
            if((typeof(observedBits))~=("number"))or((observedBits)==(Number.MAX_SAFE_INTEGER))then
                 lastContextWithAllBitsObserved=context;
                resolvedObservedBits=Number.MAX_SAFE_INTEGER
             else
                 resolvedObservedBits=observedBits
             end;
            local contextItem={["context"]=context,["observedBits"]=resolvedObservedBits,["next"]=nil};
            if(lastContextDependency)==(nil)then
                 if(currentlyRenderingFiber)==(nil)then
                     error(Error.new("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."))
                end;
                lastContextDependency=contextItem;
                (currentlyRenderingFiber).dependencies={["lanes"]=NoLanes,["firstContext"]=contextItem,["responders"]=nil}
            else
                (lastContextDependency).next=contextItem;
                lastContextDependency=contextItem
             end
         end;
        return if isPrimaryRenderer then context._currentValue else context._currentValue2
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberBeginWork.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberBeginWork.new",function()
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(tostring(message)));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")),2)
    end;
    local __DEV__=_G.__DEV__;
    local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__=_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__;
    local __COMPAT_WARNINGS__=_G.__COMPAT_WARNINGS__;
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    local console=Shared.console;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local Object=LuauPolyfill.Object;
    local inspect=LuauPolyfill.util.inspect;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local React=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseContext.new");
    type("not printable... yet");
    local ReactFiberOffscreenComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberOffscreenComponent");
    type("not printable... yet");
    type("not printable... yet");
    local checkPropTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").checkPropTypes;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local HostComponent=ReactWorkTags.HostComponent;
    local HostText=ReactWorkTags.HostText;
    local HostPortal=ReactWorkTags.HostPortal;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local Fragment=ReactWorkTags.Fragment;
    local Mode=ReactWorkTags.Mode;
    local ContextProvider=ReactWorkTags.ContextProvider;
    local ContextConsumer=ReactWorkTags.ContextConsumer;
    local Profiler=ReactWorkTags.Profiler;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local MemoComponent=ReactWorkTags.MemoComponent;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local LazyComponent=ReactWorkTags.LazyComponent;
    local IncompleteClassComponent=ReactWorkTags.IncompleteClassComponent;
    local OffscreenComponent=ReactWorkTags.OffscreenComponent;
    local LegacyHiddenComponent=ReactWorkTags.LegacyHiddenComponent;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local NoFlags=ReactFiberFlags.NoFlags;
    local StaticMask=ReactFiberFlags.StaticMask;
    local PerformedWork=ReactFiberFlags.PerformedWork;
    local Placement=ReactFiberFlags.Placement;
    local Hydrating=ReactFiberFlags.Hydrating;
    local ContentReset=ReactFiberFlags.ContentReset;
    local DidCapture=ReactFiberFlags.DidCapture;
    local Ref=ReactFiberFlags.Ref;
    local Deletion=ReactFiberFlags.Deletion;
    local ForceUpdateForLegacySuspense=ReactFiberFlags.ForceUpdateForLegacySuspense;
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local debugRenderPhaseSideEffectsForStrictMode=ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode;
    local disableLegacyContext=ReactFeatureFlags.disableLegacyContext;
    local disableModulePatternComponents=ReactFeatureFlags.disableModulePatternComponents;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    local enableSuspenseServerRenderer=ReactFeatureFlags.enableSuspenseServerRenderer;
    local warnAboutDefaultPropsOnFunctionComponents=ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local shallowEqual=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").shallowEqual;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local _getIteratorFn=ReactSymbols.getIteratorFn;
    local ReactStrictModeWarnings=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactStrictModeWarnings.new");
    local ReactCurrentFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber");
    local getCurrentFiberOwnerNameInDevOrNull=ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull;
    local setIsRendering=ReactCurrentFiber.setIsRendering;
    local ReactFiberHotReloadingModule=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHotReloading.new");
    local resolveFunctionForHotReloading=ReactFiberHotReloadingModule.resolveFunctionForHotReloading;
    local resolveForwardRefForHotReloading=ReactFiberHotReloadingModule.resolveForwardRefForHotReloading;
    local resolveClassForHotReloading=ReactFiberHotReloadingModule.resolveClassForHotReloading;
    local ReactChildFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactChildFiber.new");
    local mountChildFibers=ReactChildFiber.mountChildFibers;
    local reconcileChildFibers=ReactChildFiber.reconcileChildFibers;
    local cloneChildFibers=ReactChildFiber.cloneChildFibers;
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    local processUpdateQueue=ReactUpdateQueue.processUpdateQueue;
    local cloneUpdateQueue=ReactUpdateQueue.cloneUpdateQueue;
    local initializeUpdateQueue=ReactUpdateQueue.initializeUpdateQueue;
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local ConcurrentMode=ReactTypeOfMode.ConcurrentMode;
    local NoMode=ReactTypeOfMode.NoMode;
    local ProfileMode=ReactTypeOfMode.ProfileMode;
    local StrictMode=ReactTypeOfMode.StrictMode;
    local BlockingMode=ReactTypeOfMode.BlockingMode;
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local shouldSetTextContent=ReactFiberHostConfig.shouldSetTextContent;
    local isSuspenseInstancePending=ReactFiberHostConfig.isSuspenseInstancePending;
    local isSuspenseInstanceFallback=ReactFiberHostConfig.isSuspenseInstanceFallback;
    local registerSuspenseInstanceRetry=ReactFiberHostConfig.registerSuspenseInstanceRetry;
    local supportsHydration=ReactFiberHostConfig.supportsHydration;
    type("not printable... yet");
    local ReactFiberHostContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostContext.new");
    local pushHostContext=ReactFiberHostContext.pushHostContext;
    local pushHostContainer=ReactFiberHostContext.pushHostContainer;
    local suspenseStackCursor=ReactFiberSuspenseContext.suspenseStackCursor;
    local hasSuspenseContext=ReactFiberSuspenseContext.hasSuspenseContext;
    local ForceSuspenseFallback=ReactFiberSuspenseContext.ForceSuspenseFallback;
    local addSubtreeSuspenseContext=ReactFiberSuspenseContext.addSubtreeSuspenseContext;
    local InvisibleParentSuspenseContext=ReactFiberSuspenseContext.InvisibleParentSuspenseContext;
    local pushSuspenseContext=ReactFiberSuspenseContext.pushSuspenseContext;
    local setDefaultShallowSuspenseContext=ReactFiberSuspenseContext.setDefaultShallowSuspenseContext;
    local ReactFiberNewContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new");
    local propagateContextChange=ReactFiberNewContext.propagateContextChange;
    local readContext=ReactFiberNewContext.readContext;
    local calculateChangedBits=ReactFiberNewContext.calculateChangedBits;
    local prepareToReadContext=ReactFiberNewContext.prepareToReadContext;
    local pushProvider=ReactFiberNewContext.pushProvider;
    local lazyRefs={["renderWithHooksRef"]=nil,["bailoutHooksRef"]=nil,["shouldSuspendRef"]=nil};
    local function shouldSuspend(fiber)
        if not(lazyRefs.shouldSuspendRef)then
             lazyRefs.shouldSuspendRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberReconciler").shouldSuspend
         end;
        return lazyRefs.shouldSuspendRef(fiber)
    end;
    local function initReactFiberHooks()
        local ReactFiberHooks=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHooks.new");
        lazyRefs.renderWithHooksRef=ReactFiberHooks.renderWithHooks;
        lazyRefs.bailoutHooksRef=ReactFiberHooks.bailoutHooks
     end;
    local function renderWithHooks(...)
        if not(lazyRefs.renderWithHooksRef)then
             initReactFiberHooks()
        end;
        return lazyRefs.renderWithHooksRef(...)
    end;
    local function bailoutHooks(...)
        if not(lazyRefs.bailoutHooksRef)then
             initReactFiberHooks()
        end;
        return lazyRefs.bailoutHooksRef(...)
    end;
    local stopProfilerTimerIfRunning=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new").stopProfilerTimerIfRunning;
    local ReactFiberContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new");
    local getMaskedContext=ReactFiberContext.getMaskedContext;
    local getUnmaskedContext=ReactFiberContext.getUnmaskedContext;
    local hasLegacyContextChanged=ReactFiberContext.hasContextChanged;
    local pushLegacyContextProvider=ReactFiberContext.pushContextProvider;
    local isLegacyContextProvider=ReactFiberContext.isContextProvider;
    local pushTopLevelContextObject=ReactFiberContext.pushTopLevelContextObject;
    local invalidateContextProvider=ReactFiberContext.invalidateContextProvider;
    local ReactFiberHydrationContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHydrationContext.new");
    local resetHydrationState=ReactFiberHydrationContext.resetHydrationState;
    local enterHydrationState=ReactFiberHydrationContext.enterHydrationState;
    local reenterHydrationStateFromDehydratedSuspenseInstance=ReactFiberHydrationContext.reenterHydrationStateFromDehydratedSuspenseInstance;
    local tryToClaimNextHydratableInstance=ReactFiberHydrationContext.tryToClaimNextHydratableInstance;
    local warnIfHydrating=ReactFiberHydrationContext.warnIfHydrating;
    local ReactFiberClassComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberClassComponent.new");
    local adoptClassInstance=ReactFiberClassComponent.adoptClassInstance;
    local applyDerivedStateFromProps=ReactFiberClassComponent.applyDerivedStateFromProps;
    local constructClassInstance=ReactFiberClassComponent.constructClassInstance;
    local mountClassInstance=ReactFiberClassComponent.mountClassInstance;
    local resumeMountClassInstance=ReactFiberClassComponent.resumeMountClassInstance;
    local updateClassInstance=ReactFiberClassComponent.updateClassInstance;
    local resolveDefaultProps=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLazyComponent.new").resolveDefaultProps;
    local ReactFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new");
    local resolveLazyComponentTag=ReactFiber.resolveLazyComponentTag;
    local createFiberFromFragment=ReactFiber.createFiberFromFragment;
    local createFiberFromOffscreen=ReactFiber.createFiberFromOffscreen;
    local createFiberFromTypeAndProps=ReactFiber.createFiberFromTypeAndProps;
    local isSimpleFunctionComponent=ReactFiber.isSimpleFunctionComponent;
    local createWorkInProgress=ReactFiber.createWorkInProgress;
    local ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
    local pushRenderLanes=ReactFiberWorkLoop.pushRenderLanes;
    local markSpawnedWork=ReactFiberWorkLoop.markSpawnedWork;
    local retryDehydratedSuspenseBoundary=ReactFiberWorkLoop.retryDehydratedSuspenseBoundary;
    local scheduleUpdateOnFiber=ReactFiberWorkLoop.scheduleUpdateOnFiber;
    local renderDidSuspendDelayIfPossible=ReactFiberWorkLoop.renderDidSuspendDelayIfPossible;
    local getWorkInProgressRoot=ReactFiberWorkLoop.getWorkInProgressRoot;
    local getExecutionContext=ReactFiberWorkLoop.getExecutionContext;
    local RetryAfterError=ReactFiberWorkLoop.RetryAfterError;
    local NoContext=ReactFiberWorkLoop.NoContext;
    local Schedule_tracing_wrap;
    local setWorkInProgressVersion=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactMutableSource.new").setWorkInProgressVersion;
    local markSkippedUpdateLanes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkInProgress").markSkippedUpdateLanes;
    local ConsolePatchingDev=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ConsolePatchingDev;
    local disableLogs=ConsolePatchingDev.disableLogs;
    local reenableLogs=ConsolePatchingDev.reenableLogs;
    local ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;
    local exports={};
    local bailoutOnAlreadyFinishedWork,updateFunctionComponent;
    local didReceiveUpdate=false;
    local DidWarn={["didWarnAboutBadClass"]={},["didWarnAboutModulePatternComponent"]={},["didWarnAboutContextTypeOnFunctionComponent"]={},["didWarnAboutGetDerivedStateOnFunctionComponent"]={},["didWarnAboutFunctionRefs"]={},["didWarnAboutDefaultPropsOnFunctionComponent"]={}};
    local updateSimpleMemoComponent;
    if __DEV__ then
         DidWarn.didWarnAboutBadClass={};
        DidWarn.didWarnAboutModulePatternComponent={};
        DidWarn.didWarnAboutContextTypeOnFunctionComponent={};
        DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent={};
        DidWarn.didWarnAboutFunctionRefs={};
        exports.didWarnAboutReassigningProps=false;
        DidWarn.didWarnAboutDefaultPropsOnFunctionComponent={}
    end;
    local function reconcileChildren(current,workInProgress,nextChildren,renderLanes)
        if(current)==(nil)then
             workInProgress.child=mountChildFibers(workInProgress,nil,nextChildren,renderLanes)
        else
             workInProgress.child=reconcileChildFibers(workInProgress,(current).child,nextChildren,renderLanes)
        end
     end;
    local function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes)
        workInProgress.child=reconcileChildFibers(workInProgress,current.child,nil,renderLanes);
        workInProgress.child=reconcileChildFibers(workInProgress,nil,nextChildren,renderLanes)
    end;
    local function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes)
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if(workInProgress.type)~=(workInProgress.elementType)then
                 local innerPropTypes=Component.propTypes;
                local validateProps=Component.validateProps;
                if(innerPropTypes)or(validateProps)then
                     checkPropTypes(innerPropTypes,validateProps,nextProps,"prop",getComponentName(Component))
                end
             end
         end;
        local render=Component.render;
        local ref=workInProgress.ref;
        local nextChildren;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        if __DEV__ then
             ReactCurrentOwner.current=workInProgress;
            setIsRendering(true);
            nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);
            if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                 disableLogs();
                local ok,result=xpcall(renderWithHooks,describeError,current,workInProgress,render,nextProps,ref,renderLanes);
                if ok then
                     nextChildren=result
                 end;
                reenableLogs();
                if not(ok)then
                     error(result)
                end
             end;
            setIsRendering(false)
        else
             nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes)
        end;
        if((current)~=(nil))and(not(didReceiveUpdate))then
             bailoutHooks(current,workInProgress,renderLanes);
            return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
        end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    local function updateMemoComponent(current,workInProgress,Component,nextProps,updateLanes,renderLanes)
        if(current)==(nil)then
             local type_=Component.type;
            if((isSimpleFunctionComponent(type_))and((Component.compare)==(nil)))and((Component.defaultProps)==(nil))then
                 local resolvedType=type_;
                if __DEV__ then
                     resolvedType=resolveFunctionForHotReloading(type_)
                end;
                workInProgress.tag=SimpleMemoComponent;
                workInProgress.type=resolvedType;
                if __DEV__ then
                     validateFunctionComponentInDev(workInProgress,type_)
                end;
                return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,updateLanes,renderLanes)
            end;
            if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
                 local innerPropTypes;
                local validateProps;
                if(type(type_))==("table")then
                     innerPropTypes=type_.propTypes;
                    validateProps=type_.validateProps
                 end;
                if(innerPropTypes)or(validateProps)then
                     checkPropTypes(innerPropTypes,validateProps,nextProps,"prop",getComponentName(type_))
                end
             end;
            local child=createFiberFromTypeAndProps(Component.type,nil,nextProps,workInProgress,workInProgress.mode,renderLanes);
            child.ref=workInProgress.ref;
            child.return_=workInProgress;
            workInProgress.child=child;
            return child
         end;
        local current=current;
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             local type_=Component.type;
            local innerPropTypes;
            local validateProps;
            if(type(type_))==("table")then
                 innerPropTypes=type_.propTypes;
                validateProps=type_.validateProps
             end;
            if(innerPropTypes)or(validateProps)then
                 checkPropTypes(innerPropTypes,validateProps,nextProps,"prop",getComponentName(type_))
            end
         end;
        local currentChild=(current.child);
        if not(ReactFiberLane.includesSomeLane(updateLanes,renderLanes))then
             local prevProps=currentChild.memoizedProps;
            local compare=Component.compare;
            if(compare)==(nil)then
                 compare=shallowEqual
             end;
            if(compare(prevProps,nextProps))and((current.ref)==(workInProgress.ref))then
                 return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
            end
         end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        local newChild=createWorkInProgress(currentChild,nextProps);
        newChild.ref=workInProgress.ref;
        newChild.return_=workInProgress;
        workInProgress.child=newChild;
        return newChild
     end;
    function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,updateLanes,renderLanes)
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if(workInProgress.type)~=(workInProgress.elementType)then
                 local outerMemoType=workInProgress.elementType;
                if(outerMemoType["\x24\x24typeof"])==(REACT_LAZY_TYPE)then
                     local lazyComponent=outerMemoType;
                    local payload=lazyComponent._payload;
                    local init=lazyComponent._init;
                    local ok,result=xpcall(init,describeError,payload);
                    if ok then
                         outerMemoType=result
                     else
                         outerMemoType=nil
                     end;
                    local outerPropTypes;
                    local validateProps;
                    if((outerMemoType)~=(nil))and((type(outerMemoType))==("table"))then
                         outerPropTypes=(outerMemoType).propTypes;
                        validateProps=(outerMemoType).validateProps
                     end;
                    if(outerPropTypes)or(validateProps)then
                         checkPropTypes(outerPropTypes,validateProps,nextProps,"prop",getComponentName(outerMemoType))
                    end
                 end
             end
         end;
        if(current)~=(nil)then
             local current=current;
            local prevProps=current.memoizedProps;
            local preventBailout=true;
            if __DEV__ then
                 preventBailout=(workInProgress.type)==(current.type)
            end;
            if((shallowEqual(prevProps,nextProps))and((current.ref)==(workInProgress.ref)))and(preventBailout)then
                 didReceiveUpdate=false;
                if not(ReactFiberLane.includesSomeLane(renderLanes,updateLanes))then
                     workInProgress.lanes=current.lanes;
                    return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
                elseif(bit32.band(current.flags,ForceUpdateForLegacySuspense))~=(NoFlags)then
                     didReceiveUpdate=true
                 end
             end
         end;
        return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes)
    end;
    local function updateOffscreenComponent(current,workInProgress,renderLanes)
        local nextProps=workInProgress.pendingProps;
        local nextChildren=nextProps.children;
        local prevState;
        if(current)~=(nil)then
             prevState=(current).memoizedState
         end;
        if((nextProps.mode)==("hidden"))or((nextProps.mode)==("unstable-defer-without-hiding"))then
             if(bit32.band(workInProgress.mode,ConcurrentMode))==(NoMode)then
                 local nextState={["baseLanes"]=ReactFiberLane.NoLanes};
                workInProgress.memoizedState=nextState;
                pushRenderLanes(workInProgress,renderLanes)
            elseif not(ReactFiberLane.includesSomeLane(renderLanes,ReactFiberLane.OffscreenLane))then
                 local nextBaseLanes;
                if(prevState)~=(nil)then
                     local prevBaseLanes=(prevState).baseLanes;
                    nextBaseLanes=ReactFiberLane.mergeLanes(prevBaseLanes,renderLanes)
                else
                     nextBaseLanes=renderLanes
                 end;
                if enableSchedulerTracing then
                     markSpawnedWork(ReactFiberLane.OffscreenLane)
                end;
                workInProgress.childLanes=ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane);
                workInProgress.lanes=workInProgress.childLanes;
                local nextState={["baseLanes"]=nextBaseLanes};
                workInProgress.memoizedState=nextState;
                pushRenderLanes(workInProgress,nextBaseLanes);
                return nil
             else
                 local nextState={["baseLanes"]=ReactFiberLane.NoLanes};
                workInProgress.memoizedState=nextState;
                local subtreeRenderLanes=renderLanes;
                if(prevState)~=(nil)then
                     subtreeRenderLanes=(prevState).baseLanes
                 end;
                pushRenderLanes(workInProgress,subtreeRenderLanes)
            end
         else
             local subtreeRenderLanes;
            if(prevState)~=(nil)then
                 subtreeRenderLanes=ReactFiberLane.mergeLanes((prevState).baseLanes,renderLanes);
                workInProgress.memoizedState=nil
             else
                 subtreeRenderLanes=renderLanes
             end;
            pushRenderLanes(workInProgress,subtreeRenderLanes)
        end;
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    local updateLegacyHiddenComponent=updateOffscreenComponent;
    function updateFragment(current,workInProgress,renderLanes)
        local nextChildren=workInProgress.pendingProps;
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    function updateMode(current,workInProgress,renderLanes)
        local nextChildren=workInProgress.pendingProps.children;
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    function updateProfiler(current,workInProgress,renderLanes)
        if enableProfilerTimer then
             local stateNode=workInProgress.stateNode;
            stateNode.effectDuration=0;
            stateNode.passiveEffectDuration=0
         end;
        local nextProps=workInProgress.pendingProps;
        local nextChildren=nextProps.children;
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    local function markRef(current,workInProgress)
        local ref=workInProgress.ref;
        if((((current)==(nil))and((ref)~=(nil))))or((((current)~=(nil))and(((current).ref)~=(ref))))then
             workInProgress.flags=bit32.bor(workInProgress.flags,Ref)
        end
     end;
    function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes)
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if((type(Component))~=("function"))and(((workInProgress.type)~=(workInProgress.elementType)))then
                 local innerPropTypes;
                local validateProps;
                if(type(Component))==("table")then
                     innerPropTypes=(Component).propTypes;
                    validateProps=(Component).validateProps
                 end;
                if(innerPropTypes)or(validateProps)then
                     checkPropTypes(innerPropTypes,validateProps,nextProps,"prop",getComponentName(Component))
                end
             end
         end;
        local context;
        if not(disableLegacyContext)then
             local unmaskedContext=getUnmaskedContext(workInProgress,Component,true);
            context=getMaskedContext(workInProgress,unmaskedContext)
        end;
        local nextChildren;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        if __DEV__ then
             ReactCurrentOwner.current=workInProgress;
            setIsRendering(true);
            nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);
            if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                 disableLogs();
                local ok,result=xpcall(renderWithHooks,describeError,current,workInProgress,Component,nextProps,context,renderLanes);
                reenableLogs();
                if ok then
                     nextChildren=result
                 else
                     error(result)
                end
             end;
            setIsRendering(false)
        else
             nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes)
        end;
        if((current)~=(nil))and(not(didReceiveUpdate))then
             bailoutHooks(current,workInProgress,renderLanes);
            return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
        end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    local function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes)
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if(workInProgress.type)~=(workInProgress.elementType)then
                 local innerPropTypes=Component.propTypes;
                local validateProps=Component.validateProps;
                if(innerPropTypes)or(validateProps)then
                     checkPropTypes(innerPropTypes,validateProps,nextProps,"prop",getComponentName(Component))
                end
             end
         end;
        local hasContext;
        if isLegacyContextProvider(Component)then
             hasContext=true;
            pushLegacyContextProvider(workInProgress)
        else
             hasContext=false
         end;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        local instance=workInProgress.stateNode;
        local shouldUpdate;
        if(instance)==(nil)then
             if(current)~=(nil)then
                 current.alternate=nil;
                workInProgress.alternate=nil;
                workInProgress.flags=bit32.bor(workInProgress.flags,Placement)
            end;
            constructClassInstance(workInProgress,Component,nextProps);
            mountClassInstance(workInProgress,Component,nextProps,renderLanes);
            shouldUpdate=true
         elseif(current)==(nil)then
             shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes)
        else
             shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes)
        end;
        local nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);
        if __DEV__ then
             local inst=workInProgress.stateNode;
            if(shouldUpdate)and((inst.props)~=(nextProps))then
                 if not(exports.didWarnAboutReassigningProps)then
                     console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",(getComponentName(workInProgress.type))or("a component"))
                end;
                exports.didWarnAboutReassigningProps=true
             end
         end;
        return nextUnitOfWork
     end;
    function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes)
        markRef(current,workInProgress);
        local didCaptureError=(bit32.band(workInProgress.flags,DidCapture))~=(NoFlags);
        if(not(shouldUpdate))and(not(didCaptureError))then
             if hasContext then
                 invalidateContextProvider(workInProgress,Component,false)
            end;
            return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
        end;
        local instance=workInProgress.stateNode;
        ReactCurrentOwner.current=workInProgress;
        local nextChildren;
        if(didCaptureError)and((((Component.getDerivedStateFromError)==(nil))or((type(Component.getDerivedStateFromError))~=("function"))))then
             nextChildren=nil;
            if enableProfilerTimer then
                 stopProfilerTimerIfRunning(workInProgress)
            end
         else
             if __DEV__ then
                 setIsRendering(true);
                nextChildren=instance:render();
                if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                     disableLogs();
                    local ok,result=xpcall(instance.render,describeError,instance);
                    reenableLogs();
                    if not(ok)then
                         error(result)
                    end
                 end;
                setIsRendering(false)
            else
                 nextChildren=instance:render()
            end
         end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        if((current)~=(nil))and(didCaptureError)then
             forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes)
        else
             reconcileChildren(current,workInProgress,nextChildren,renderLanes)
        end;
        workInProgress.memoizedState=instance.state;
        if hasContext then
             invalidateContextProvider(workInProgress,Component,true)
        end;
        return workInProgress.child
     end;
    local function pushHostRootContext(workInProgress)
        local root=workInProgress.stateNode;
        if root.pendingContext then
             pushTopLevelContextObject(workInProgress,root.pendingContext,(root.pendingContext)~=(root.context))
        elseif root.context then
             pushTopLevelContextObject(workInProgress,root.context,false)
        end;
        pushHostContainer(workInProgress,root.containerInfo)
    end;
    local function updateHostRoot(current,workInProgress,renderLanes)
        pushHostRootContext(workInProgress);
        local updateQueue=workInProgress.updateQueue;
        invariant(((current)~=(nil))and((updateQueue)~=(nil)),"If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        local nextProps=workInProgress.pendingProps;
        local prevState=workInProgress.memoizedState;
        local prevChildren;
        if(prevState)~=(nil)then
             prevChildren=prevState.element
         end;
        cloneUpdateQueue(current,workInProgress);
        processUpdateQueue(workInProgress,nextProps,nil,renderLanes);
        local nextState=workInProgress.memoizedState;
        local nextChildren=nextState.element;
        if(nextChildren)==(prevChildren)then
             resetHydrationState();
            return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
        end;
        local root=workInProgress.stateNode;
        if(root.hydrate)and(enterHydrationState(workInProgress))then
             if supportsHydration then
                 local mutableSourceEagerHydrationData=root.mutableSourceEagerHydrationData;
                if(mutableSourceEagerHydrationData)~=(nil)then
                     for i=1,#(mutableSourceEagerHydrationData),2 do
                         local mutableSource=mutableSourceEagerHydrationData[i];
                        local version=mutableSourceEagerHydrationData[(i)+(1)];
                        setWorkInProgressVersion(mutableSource,version)
                    end
                 end
             end;
            local child=mountChildFibers(workInProgress,nil,nextChildren,renderLanes);
            workInProgress.child=child;
            local node=child;
            while node do
                 node.flags=bit32.bor(bit32.band(node.flags,bit32.bnot(Placement)),Hydrating);
                node=node.sibling
             end
         else
             reconcileChildren(current,workInProgress,nextChildren,renderLanes);
            resetHydrationState()
        end;
        return workInProgress.child
     end;
    local function updateHostComponent(current,workInProgress,renderLanes)
        pushHostContext(workInProgress);
        if(current)==(nil)then
             tryToClaimNextHydratableInstance(workInProgress)
        end;
        local type_=workInProgress.type;
        local nextProps=workInProgress.pendingProps;
        local prevProps;
        if(current)~=(nil)then
             prevProps=current.memoizedProps
         end;
        local nextChildren=nextProps.children;
        local isDirectTextChild=shouldSetTextContent(type_,nextProps);
        if isDirectTextChild then
             nextChildren=nil
         elseif((prevProps)~=(nil))and(shouldSetTextContent(type_,prevProps))then
             workInProgress.flags=bit32.bor(workInProgress.flags,ContentReset)
        end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        markRef(current,workInProgress);
        reconcileChildren(current,workInProgress,nextChildren,renderLanes);
        return workInProgress.child
     end;
    local function updateHostText(current,workInProgress)
        if(current)==(nil)then
             tryToClaimNextHydratableInstance(workInProgress)
        end;
        return nil
     end;
    local function mountLazyComponent(_current,workInProgress,elementType,updateLanes,renderLanes)
        if(_current)~=(nil)then
             _current.alternate=nil;
            workInProgress.alternate=nil;
            workInProgress.flags=bit32.bor(workInProgress.flags,Placement)
        end;
        local props=workInProgress.pendingProps;
        local lazyComponent=elementType;
        local payload=lazyComponent._payload;
        local init=lazyComponent._init;
        local Component=init(payload);
        workInProgress.type=Component;
        workInProgress.tag=resolveLazyComponentTag(Component);
        local resolvedTag=workInProgress.tag;
        local resolvedProps=resolveDefaultProps(Component,props);
        local child;
        if(resolvedTag)==(FunctionComponent)then
             if __DEV__ then
                 validateFunctionComponentInDev(workInProgress,Component);
                Component=resolveFunctionForHotReloading(Component);
                workInProgress.type=Component
             end;
            child=updateFunctionComponent(nil,workInProgress,Component,resolvedProps,renderLanes);
            return child
         elseif(resolvedTag)==(ClassComponent)then
             if __DEV__ then
                 Component=resolveClassForHotReloading(Component);
                workInProgress.type=Component
             end;
            child=updateClassComponent(nil,workInProgress,Component,resolvedProps,renderLanes);
            return child
         elseif(resolvedTag)==(ForwardRef)then
             if __DEV__ then
                 Component=resolveForwardRefForHotReloading(Component);
                workInProgress.type=Component
             end;
            child=updateForwardRef(nil,workInProgress,Component,resolvedProps,renderLanes);
            return child
         elseif(resolvedTag)==(MemoComponent)then
             if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
                 if(workInProgress.type)~=(workInProgress.elementType)then
                     local outerPropTypes=Component.propTypes;
                    local validateProps=Component.validateProps;
                    if(outerPropTypes)or(validateProps)then
                         checkPropTypes(outerPropTypes,validateProps,resolvedProps,"prop",getComponentName(Component))
                    end
                 end
             end;
            child=updateMemoComponent(nil,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),updateLanes,renderLanes);
            return child
         end;
        local hint="";
        if __DEV__ then
             if(((Component)~=(nil))and((type(Component))==("table")))and((Component["\x24\x24typeof"])==(REACT_LAZY_TYPE))then
                 hint=" Did you wrap a component in React.lazy() more than once?"
            elseif((type(Component))==("table"))and((Component["\x24\x24typeof"])==(nil))then
                 hint=("\x0a")..(inspect(Component))
            end
         end;
        invariant(false,"Element type is invalid. Received a promise that resolves to: %s. Lazy element type must resolve to a class or function.%s",tostring(Component),hint);
        return nil
     end;
    function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes)
        if(_current)~=(nil)then
             _current.alternate=nil;
            workInProgress.alternate=nil;
            workInProgress.flags=bit32.bor(workInProgress.flags,Placement)
        end;
        workInProgress.tag=ClassComponent;
        local hasContext;
        if isLegacyContextProvider(Component)then
             hasContext=true;
            pushLegacyContextProvider(workInProgress)
        else
             hasContext=false
         end;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        constructClassInstance(workInProgress,Component,nextProps);
        mountClassInstance(workInProgress,Component,nextProps,renderLanes);
        return finishClassComponent(nil,workInProgress,Component,true,hasContext,renderLanes)
    end;
    local function mountIndeterminateComponent(current,workInProgress,Component,renderLanes)
        if(current)~=(nil)then
             current.alternate=nil;
            workInProgress.alternate=nil;
            workInProgress.flags=bit32.bor(workInProgress.flags,Placement)
        end;
        local props=workInProgress.pendingProps;
        local context;
        if not(disableLegacyContext)then
             local unmaskedContext=getUnmaskedContext(workInProgress,Component,false);
            context=getMaskedContext(workInProgress,unmaskedContext)
        end;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        local value;
        if __DEV__ then
             if((type(Component))==("table"))and((type(Component.render))==("function"))then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutBadClass[componentName])then
                     console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",componentName,componentName);
                    DidWarn.didWarnAboutBadClass[componentName]=true
                 end
             end;
            if(bit32.band(workInProgress.mode,StrictMode))~=(0)then
                 ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress)
            end;
            setIsRendering(true);
            ReactCurrentOwner.current=workInProgress;
            value=renderWithHooks(nil,workInProgress,Component,props,context,renderLanes);
            setIsRendering(false)
        else
             value=renderWithHooks(nil,workInProgress,Component,props,context,renderLanes)
        end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        local typeofValue=type(value);
        if __DEV__ then
             if((((value)~=(nil))and((typeofValue)==("table")))and((type(value.render))==("function")))and((value["\x24\x24typeof"])==(nil))then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutModulePatternComponent[componentName])then
                     console.error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. ",componentName,componentName);
                    DidWarn.didWarnAboutModulePatternComponent[componentName]=true
                 end
             end
         end;
        if((((not(disableModulePatternComponents))and((value)~=(nil)))and((typeofValue)==("table")))and((type(value.render))==("function")))and((value["\x24\x24typeof"])==(nil))then
             if __DEV__ then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutModulePatternComponent[componentName])then
                     console.error(("The <%s /> component appears to be a function component that returns a class instance. ")..(("Change %s to a class that extends React.Component instead. ")..(componentName)),componentName);
                    DidWarn.didWarnAboutModulePatternComponent[componentName]=true
                 end
             end;
            workInProgress.tag=ClassComponent;
            workInProgress.memoizedState=nil;
            workInProgress.updateQueue=nil;
            local hasContext=false;
            if isLegacyContextProvider(Component)then
                 hasContext=true;
                pushLegacyContextProvider(workInProgress)
            else
                 hasContext=false
             end;
            workInProgress.memoizedState=value.state;
            initializeUpdateQueue(workInProgress);
            local getDerivedStateFromProps;
            if(type(Component))~=("function")then
                 getDerivedStateFromProps=(Component).getDerivedStateFromProps
             end;
            if((getDerivedStateFromProps)~=(nil))and((type(getDerivedStateFromProps))==("function"))then
                 applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,props)
            end;
            adoptClassInstance(workInProgress,value);
            mountClassInstance(workInProgress,Component,props,renderLanes);
            return finishClassComponent(nil,workInProgress,Component,true,hasContext,renderLanes)
        else
             workInProgress.tag=FunctionComponent;
            if __DEV__ then
                 if(disableLegacyContext)and(Component.contextTypes)then
                     console.error("%s uses the legacy contextTypes API which is no longer supported. Use React.createContext() with React.useContext() instead.",(getComponentName(Component))or("Unknown"))
                end;
                if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                     disableLogs();
                    local ok,result=xpcall(renderWithHooks,describeError,nil,workInProgress,Component,props,context,renderLanes);
                    reenableLogs();
                    if ok then
                         value=result
                     else
                         error(result)
                    end
                 end
             end;
            reconcileChildren(nil,workInProgress,value,renderLanes);
            if __DEV__ then
                 validateFunctionComponentInDev(workInProgress,Component)
            end;
            return workInProgress.child
         end
     end;
    function validateFunctionComponentInDev(workInProgress,Component)
        if __DEV__ then
             if(workInProgress.ref)~=(nil)then
                 local info="";
                local ownerName=getCurrentFiberOwnerNameInDevOrNull();
                if ownerName then
                     info..=("\x0a\x0aCheck the render method of `")..((ownerName)..("`."))
                end;
                local warningKey=((ownerName)or(workInProgress._debugID))or("");
                local debugSource=workInProgress._debugSource;
                if debugSource then
                     warningKey=(debugSource.fileName)..((":")..(debugSource.lineNumber))
                end;
                if not(DidWarn.didWarnAboutFunctionRefs[warningKey])then
                     DidWarn.didWarnAboutFunctionRefs[warningKey]=true;
                    console.error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s",info)
                end
             end;
            if((warnAboutDefaultPropsOnFunctionComponents)and((type(Component))~=("function")))and((Component.defaultProps)~=(nil))then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName])then
                     console.error("%s: Support for defaultProps will be removed from function components in a future major release.",componentName);
                    DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName]=true
                 end
             end;
            if(((type(Component))~=("function"))and((Component.getDerivedStateFromProps)~=(nil)))and((type(Component.getDerivedStateFromProps))==("function"))then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName])then
                     console.error("%s: Function components do not support getDerivedStateFromProps.",componentName);
                    DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName]=true
                 end
             end;
            if(((type(Component))~=("function"))and((Component.contextType)~=(nil)))and((type(Component.contextType))==("table"))then
                 local componentName=(getComponentName(Component))or("Unknown");
                if not(DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName])then
                     console.error("%s: Function components do not support contextType.",componentName);
                    DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName]=true
                 end
             end
         end
     end;
    local SUSPENDED_MARKER={["dehydrated"]=nil,["retryLane"]=ReactFiberLane.NoLane};
    local function mountSuspenseOffscreenState(renderLanes)
        return{["baseLanes"]=renderLanes}
    end;
    local function updateSuspenseOffscreenState(prevOffscreenState,renderLanes)
        return{["baseLanes"]=ReactFiberLane.mergeLanes(prevOffscreenState.baseLanes,renderLanes)}
    end;
    local function shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes)
        if(current)~=(nil)then
             local suspenseState=(current).memoizedState;
            if(suspenseState)==(nil)then
                 return false
             end
         end;
        return hasSuspenseContext(suspenseContext,ForceSuspenseFallback)
    end;
    local function getRemainingWorkInPrimaryTree(current,renderLanes)
        return ReactFiberLane.removeLanes(current.childLanes,renderLanes)
    end;
    local updateSuspensePrimaryChildren;
    local mountDehydratedSuspenseComponent;
    local mountSuspensePrimaryChildren;
    local updateSuspenseFallbackChildren;
    local updateDehydratedSuspenseComponent;
    local function updateSuspenseComponent(current,workInProgress,renderLanes)
        local nextProps=workInProgress.pendingProps;
        if __DEV__ then
             if shouldSuspend(workInProgress)then
                 workInProgress.flags=bit32.bor(workInProgress.flags,DidCapture)
            end
         end;
        local suspenseContext=suspenseStackCursor.current;
        local showFallback=false;
        local didSuspend=(bit32.band(workInProgress.flags,DidCapture))~=(NoFlags);
        if(didSuspend)or(shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes))then
             showFallback=true;
            workInProgress.flags=bit32.band(workInProgress.flags,bit32.bnot(DidCapture))
        else
             if((current)==(nil))or((current.memoizedState)~=(nil))then
                 if((nextProps.fallback)~=(nil))and((nextProps.unstable_avoidThisFallback)~=(true))then
                     suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext)
                end
             end
         end;
        suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress,suspenseContext);
        if(current)==(nil)then
             if(nextProps.fallback)~=(nil)then
                 tryToClaimNextHydratableInstance(workInProgress);
                if enableSuspenseServerRenderer then
                     local suspenseState=workInProgress.memoizedState;
                    if(suspenseState)~=(nil)then
                         local dehydrated=(suspenseState).dehydrated;
                        if(dehydrated)~=(nil)then
                             return mountDehydratedSuspenseComponent(workInProgress,dehydrated,renderLanes)
                        end
                     end
                 end
             end;
            local nextPrimaryChildren=nextProps.children;
            local nextFallbackChildren=nextProps.fallback;
            if showFallback then
                 local fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);
                local primaryChildFragment=workInProgress.child;
                primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);
                workInProgress.memoizedState=SUSPENDED_MARKER;
                return fallbackFragment
             elseif((nextProps.unstable_expectedLoadTime)~=(nil))and((type(nextProps.unstable_expectedLoadTime))==("number"))then
                 local fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);
                local primaryChildFragment=workInProgress.child;
                primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);
                workInProgress.memoizedState=SUSPENDED_MARKER;
                workInProgress.lanes=ReactFiberLane.SomeRetryLane;
                if enableSchedulerTracing then
                     markSpawnedWork(ReactFiberLane.SomeRetryLane)
                end;
                return fallbackFragment
             else
                 return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren,renderLanes)
            end
         else
             local prevState=current.memoizedState;
            if(prevState)~=(nil)then
                 if enableSuspenseServerRenderer then
                     local dehydrated=(prevState).dehydrated;
                    if(dehydrated)~=(nil)then
                         if not(didSuspend)then
                             return updateDehydratedSuspenseComponent(current,workInProgress,dehydrated,prevState,renderLanes)
                        elseif(workInProgress.memoizedState)~=(nil)then
                             workInProgress.child=current.child;
                            workInProgress.flags=bit32.bor(workInProgress.flags,DidCapture);
                            return nil
                         else
                             local nextPrimaryChildren=nextProps.children;
                            local nextFallbackChildren=nextProps.fallback;
                            local fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);
                            local primaryChildFragment=workInProgress.child;
                            primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);
                            workInProgress.memoizedState=SUSPENDED_MARKER;
                            return fallbackChildFragment
                         end
                     end
                 end;
                if showFallback then
                     local nextFallbackChildren=nextProps.fallback;
                    local nextPrimaryChildren=nextProps.children;
                    local fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);
                    local primaryChildFragment=workInProgress.child;
                    local prevOffscreenState=(current.child).memoizedState;
                    if(prevOffscreenState)==(nil)then
                         primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes)
                    else
                         primaryChildFragment.memoizedState=updateSuspenseOffscreenState(prevOffscreenState,renderLanes)
                    end;
                    primaryChildFragment.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);
                    workInProgress.memoizedState=SUSPENDED_MARKER;
                    return fallbackChildFragment
                 else
                     local nextPrimaryChildren=nextProps.children;
                    local primaryChildFragment=updateSuspensePrimaryChildren(current,workInProgress,nextPrimaryChildren,renderLanes);
                    workInProgress.memoizedState=nil;
                    return primaryChildFragment
                 end
             else
                 if showFallback then
                     local nextFallbackChildren=nextProps.fallback;
                    local nextPrimaryChildren=nextProps.children;
                    local fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);
                    local primaryChildFragment=workInProgress.child;
                    local prevOffscreenState=(current.child).memoizedState;
                    if(prevOffscreenState)==(nil)then
                         primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes)
                    else
                         primaryChildFragment.memoizedState=updateSuspenseOffscreenState(prevOffscreenState,renderLanes)
                    end;
                    primaryChildFragment.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);
                    workInProgress.memoizedState=SUSPENDED_MARKER;
                    return fallbackChildFragment
                 else
                     local nextPrimaryChildren=nextProps.children;
                    local primaryChildFragment=updateSuspensePrimaryChildren(current,workInProgress,nextPrimaryChildren,renderLanes);
                    workInProgress.memoizedState=nil;
                    return primaryChildFragment
                 end
             end
         end
     end;
    function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes)
        local mode=workInProgress.mode;
        local primaryChildProps={["mode"]="visible",["children"]=primaryChildren};
        local primaryChildFragment=createFiberFromOffscreen(primaryChildProps,mode,renderLanes,nil);
        primaryChildFragment.return_=workInProgress;
        workInProgress.child=primaryChildFragment;
        return primaryChildFragment
     end;
    function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes)
        local mode=workInProgress.mode;
        local progressedPrimaryFragment=workInProgress.child;
        local primaryChildProps={["mode"]="hidden",["children"]=primaryChildren};
        local primaryChildFragment;
        local fallbackChildFragment;
        if((bit32.band(mode,BlockingMode))==(NoMode))and((progressedPrimaryFragment)~=(nil))then
             primaryChildFragment=progressedPrimaryFragment;
            primaryChildFragment.childLanes=ReactFiberLane.NoLanes;
            primaryChildFragment.pendingProps=primaryChildProps;
            if(enableProfilerTimer)and((bit32.band(workInProgress.mode,ProfileMode))~=(0))then
                 primaryChildFragment.actualDuration=0;
                primaryChildFragment.actualStartTime=-(1);
                primaryChildFragment.selfBaseDuration=0;
                primaryChildFragment.treeBaseDuration=0
             end;
            fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,nil)
        else
             primaryChildFragment=createFiberFromOffscreen(primaryChildProps,mode,ReactFiberLane.NoLanes,nil);
            fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,nil)
        end;
        primaryChildFragment.return_=workInProgress;
        fallbackChildFragment.return_=workInProgress;
        primaryChildFragment.sibling=fallbackChildFragment;
        workInProgress.child=primaryChildFragment;
        return fallbackChildFragment
     end;
    local function createWorkInProgressOffscreenFiber(current,offscreenProps)
        return createWorkInProgress(current,offscreenProps)
    end;
    function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes)
        local currentPrimaryChildFragment=current.child;
        local currentFallbackChildFragment=currentPrimaryChildFragment.sibling;
        local primaryChildFragment=createWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{["mode"]="visible",["children"]=primaryChildren});
        if(bit32.band(workInProgress.mode,BlockingMode))==(NoMode)then
             primaryChildFragment.lanes=renderLanes
         end;
        primaryChildFragment.return_=workInProgress;
        primaryChildFragment.sibling=nil;
        if(currentFallbackChildFragment)~=(nil)then
             local deletions=workInProgress.deletions;
            if(deletions)==(nil)then
                 workInProgress.deletions={currentFallbackChildFragment};
                workInProgress.flags=bit32.bor(workInProgress.flags,Deletion)
            else
                 table.insert(deletions,currentFallbackChildFragment)
            end
         end;
        workInProgress.child=primaryChildFragment;
        return primaryChildFragment
     end;
    function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes)
        local mode=workInProgress.mode;
        local currentPrimaryChildFragment=current.child;
        local currentFallbackChildFragment=currentPrimaryChildFragment.sibling;
        local primaryChildProps={["mode"]="hidden",["children"]=primaryChildren};
        local primaryChildFragment;
        if((bit32.band(mode,BlockingMode))==(NoMode))and((workInProgress.child)~=(currentPrimaryChildFragment))then
             local progressedPrimaryFragment=workInProgress.child;
            primaryChildFragment=progressedPrimaryFragment;
            primaryChildFragment.childLanes=ReactFiberLane.NoLanes;
            primaryChildFragment.pendingProps=primaryChildProps;
            if(enableProfilerTimer)and((bit32.band(workInProgress.mode,ProfileMode))~=(0))then
                 primaryChildFragment.actualDuration=0;
                primaryChildFragment.actualStartTime=-(1);
                primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration
             end;
            workInProgress.deletions=nil
         else
             primaryChildFragment=createWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);
            primaryChildFragment.subtreeFlags=bit32.band(currentPrimaryChildFragment.subtreeFlags,StaticMask)
        end;
        local fallbackChildFragment;
        if(currentFallbackChildFragment)~=(nil)then
             fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren)
        else
             fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,nil);
            fallbackChildFragment.flags=bit32.bor(fallbackChildFragment.flags,Placement)
        end;
        fallbackChildFragment.return_=workInProgress;
        primaryChildFragment.return_=workInProgress;
        primaryChildFragment.sibling=fallbackChildFragment;
        workInProgress.child=primaryChildFragment;
        return fallbackChildFragment
     end;
    local function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)
        reconcileChildFibers(workInProgress,current.child,nil,renderLanes);
        local nextProps=workInProgress.pendingProps;
        local primaryChildren=nextProps.children;
        local primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes);
        primaryChildFragment.flags=bit32.bor(primaryChildFragment.flags,Placement);
        workInProgress.memoizedState=nil;
        return primaryChildFragment
     end;
    function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes)
        local mode=workInProgress.mode;
        local primaryChildFragment=createFiberFromOffscreen(primaryChildren,mode,ReactFiberLane.NoLanes,nil);
        local fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,nil);
        fallbackChildFragment.flags=bit32.bor(fallbackChildFragment.flags,Placement);
        primaryChildFragment.return_=workInProgress;
        fallbackChildFragment.return_=workInProgress;
        primaryChildFragment.sibling=fallbackChildFragment;
        workInProgress.child=primaryChildFragment;
        if(bit32.band(workInProgress.mode,BlockingMode))~=(NoMode)then
             reconcileChildFibers(workInProgress,current.child,nil,renderLanes)
        end;
        return fallbackChildFragment
     end;
    function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes)
        if(bit32.band(workInProgress.mode,BlockingMode))==(NoMode)then
             if __DEV__ then
                 console.error("Cannot hydrate Suspense in legacy mode. Switch fromReactDOM.hydrate(element, container) to ReactDOM.createBlockingRoot(container, { hydrate: true }).render(element) or remove the Suspense componentsthe server rendered components.")
            end;
            workInProgress.lanes=ReactFiberLane.laneToLanes(ReactFiberLane.SyncLane)
        elseif isSuspenseInstanceFallback(suspenseInstance)then
             if enableSchedulerTracing then
                 markSpawnedWork(ReactFiberLane.DefaultHydrationLane)
            end;
            workInProgress.lanes=ReactFiberLane.laneToLanes(ReactFiberLane.DefaultHydrationLane)
        else
             workInProgress.lanes=ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane);
            if enableSchedulerTracing then
                 markSpawnedWork(ReactFiberLane.OffscreenLane)
            end
         end;
        return nil
     end;
    function updateDehydratedSuspenseComponent(current,workInProgress,suspenseInstance,suspenseState,renderLanes)
        warnIfHydrating();
        if(bit32.band(getExecutionContext(),RetryAfterError))~=(NoContext)then
             return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)
        end;
        if(bit32.band(workInProgress.mode,BlockingMode))==(NoMode)then
             return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)
        end;
        if isSuspenseInstanceFallback(suspenseInstance)then
             return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)
        end;
        local hasContextChanged=ReactFiberLane.includesSomeLane(renderLanes,current.childLanes);
        if(didReceiveUpdate)or(hasContextChanged)then
             local root=getWorkInProgressRoot();
            if(root)~=(nil)then
                 local attemptHydrationAtLane=ReactFiberLane.getBumpedLaneForHydration(root,renderLanes);
                if((attemptHydrationAtLane)~=(ReactFiberLane.NoLane))and((attemptHydrationAtLane)~=(suspenseState.retryLane))then
                     suspenseState.retryLane=attemptHydrationAtLane;
                    local eventTime=ReactFiberLane.NoTimestamp;
                    scheduleUpdateOnFiber(current,attemptHydrationAtLane,eventTime)
                end
             end;
            renderDidSuspendDelayIfPossible();
            return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)
        elseif isSuspenseInstancePending(suspenseInstance)then
             workInProgress.flags=bit32.bor(workInProgress.flags,DidCapture);
            workInProgress.child=current.child;
            local retry=function()
                return retryDehydratedSuspenseBoundary(current)
            end;
            if enableSchedulerTracing then
                 if(Schedule_tracing_wrap)==(nil)then
                     Schedule_tracing_wrap=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler").tracing.unstable_wrap
                 end;
                retry=Schedule_tracing_wrap(retry)
            end;
            registerSuspenseInstanceRetry(suspenseInstance,retry);
            return nil
         else
             reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance);
            local nextProps=workInProgress.pendingProps;
            local primaryChildren=nextProps.children;
            local primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes);
            primaryChildFragment.flags=bit32.bor(primaryChildFragment.flags,Hydrating);
            return primaryChildFragment
         end
     end;
    function updatePortalComponent(current,workInProgress,renderLanes)
        pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);
        local nextChildren=workInProgress.pendingProps;
        if(current)==(nil)then
             workInProgress.child=reconcileChildFibers(workInProgress,nil,nextChildren,renderLanes)
        else
             reconcileChildren(current,workInProgress,nextChildren,renderLanes)
        end;
        return workInProgress.child
     end;
    local hasWarnedAboutUsingNoValuePropOnContextProvider=false;
    local function updateContextProvider(current,workInProgress,renderLanes)
        local providerType=workInProgress.type;
        local context=providerType._context;
        local newProps=workInProgress.pendingProps;
        local oldProps=workInProgress.memoizedProps;
        local newValue=newProps.value;
        if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
             if(Array.indexOf(Object.keys(newProps),"value"))<(1)then
                 if not(hasWarnedAboutUsingNoValuePropOnContextProvider)then
                     hasWarnedAboutUsingNoValuePropOnContextProvider=true;
                    console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")
                end
             end;
            local providerPropTypes=workInProgress.type.propTypes;
            local validateProps=workInProgress.type.validateProps;
            if(providerPropTypes)or(validateProps)then
                 checkPropTypes(providerPropTypes,validateProps,newProps,"prop","Context.Provider")
            end
         end;
        pushProvider(workInProgress,newValue);
        if(oldProps)~=(nil)then
             local oldValue=oldProps.value;
            local changedBits=calculateChangedBits(context,newValue,oldValue);
            if(changedBits)==(0)then
                 if((oldProps.children)==(newProps.children))and(not(hasLegacyContextChanged()))then
                     return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
                end
             else
                 propagateContextChange(workInProgress,context,changedBits,renderLanes)
            end
         end;
        local newChildren=newProps.children;
        reconcileChildren(current,workInProgress,newChildren,renderLanes);
        return workInProgress.child
     end;
    local hasWarnedAbout={["usingContextAsConsumer"]=false,["usingLegacyConsumer"]=false};
    function updateContextConsumer(current,workInProgress,renderLanes)
        local context=workInProgress.type;
        if __DEV__ then
             if((context)._context)==(nil)then
                 if(context)~=(context.Consumer)then
                     if not(hasWarnedAbout.usingContextAsConsumer)then
                         hasWarnedAbout.usingContextAsConsumer=true;
                        console.error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")
                    end
                 end
             else
                 context=(context)._context
             end
         end;
        local newProps=workInProgress.pendingProps;
        local render;
        if newProps.render then
             if(__DEV__)and(__COMPAT_WARNINGS__)then
                 if not(hasWarnedAbout.usingLegacyConsumer)then
                     hasWarnedAbout.usingLegacyConsumer=true;
                    console.warn("Your Context.Consumer component is using legacy Roact syntax, which won't be supported in future versions of Roact. \x0aPlease provide no props and supply the 'render' function as a child (the 3rd argument of createElement). For example: \x0a       createElement(ContextConsumer, {render = function(...) end})\x0abecomes:\x0a       createElement(ContextConsumer, nil, function(...) end)\x0aFor more info, reference the React documentation here: \x0ahttps://reactjs.org/docs/context.html\x23contextconsumer")
                end
             end;
            render=newProps.render
         else
             render=newProps.children
         end;
        if __DEV__ then
             if(type(render))~=("function")then
                 console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.")
            end
         end;
        prepareToReadContext(workInProgress,renderLanes,exports.markWorkInProgressReceivedUpdate);
        local newValue=readContext(context,newProps.unstable_observedBits);
        local newChildren;
        if __DEV__ then
             ReactCurrentOwner.current=workInProgress;
            setIsRendering(true);
            newChildren=render(newValue);
            setIsRendering(false)
        else
             newChildren=render(newValue)
        end;
        workInProgress.flags=bit32.bor(workInProgress.flags,PerformedWork);
        reconcileChildren(current,workInProgress,newChildren,renderLanes);
        return workInProgress.child
     end;
    exports.markWorkInProgressReceivedUpdate=function()
        didReceiveUpdate=true
     end;
    function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
        if current then
             workInProgress.dependencies=current.dependencies
         end;
        if enableProfilerTimer then
             stopProfilerTimerIfRunning(workInProgress)
        end;
        markSkippedUpdateLanes(workInProgress.lanes);
        if not(ReactFiberLane.includesSomeLane(renderLanes,workInProgress.childLanes))then
             return nil
         else
             cloneChildFibers(current,workInProgress);
            return workInProgress.child
         end
     end;
    function remountFiber(current,oldWorkInProgress,newWorkInProgress)
        if __DEV__ then
             local returnFiber=oldWorkInProgress.return_;
            if(returnFiber)==(nil)then
                 error("Cannot swap the root fiber.")
            end;
            assert((returnFiber)~=(nil),"returnFiber was nil in remountFiber");
            current.alternate=nil;
            oldWorkInProgress.alternate=nil;
            newWorkInProgress.index=oldWorkInProgress.index;
            newWorkInProgress.sibling=oldWorkInProgress.sibling;
            newWorkInProgress.return_=oldWorkInProgress.return_;
            newWorkInProgress.ref=oldWorkInProgress.ref;
            if(oldWorkInProgress)==(returnFiber.child)then
                 returnFiber.child=newWorkInProgress
             else
                 local prevSibling=returnFiber.child;
                if(prevSibling)==(nil)then
                     error("Expected parent to have a child.")
                end;
                assert((prevSibling)~=(nil),"prevSibling was nil in remountFiber");
                while(prevSibling.sibling)~=(oldWorkInProgress)do
                     prevSibling=prevSibling.sibling;
                    if(prevSibling)==(nil)then
                         error("Expected to find the previous sibling.")
                    end
                 end;
                prevSibling.sibling=newWorkInProgress
             end;
            local deletions=returnFiber.deletions;
            if(deletions)==(nil)then
                 returnFiber.deletions={current};
                returnFiber.flags=bit32.bor(returnFiber.flags,Deletion)
            else
                 table.insert(deletions,current)
            end;
            newWorkInProgress.flags=bit32.bor(newWorkInProgress.flags,Placement);
            return newWorkInProgress
         else
             error("Did not expect this call in production. This is a bug in React. Please file an issue.")
        end
     end;
    local function beginWork(current,workInProgress,renderLanes)
        local updateLanes=workInProgress.lanes;
        if __DEV__ then
             if(workInProgress._debugNeedsRemount)and((current)~=(nil))then
                 return remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,(workInProgress._debugOwner)or(nil),workInProgress.mode,workInProgress.lanes))
            end
         end;
        if(current)~=(nil)then
             local oldProps=current.memoizedProps;
            local newProps=workInProgress.pendingProps;
            if(((oldProps)~=(newProps))or(hasLegacyContextChanged()))or(if __DEV__ then(workInProgress.type)~=(current.type)else false)then
                 didReceiveUpdate=true
             elseif not(ReactFiberLane.includesSomeLane(renderLanes,updateLanes))then
                 didReceiveUpdate=false;
                if(workInProgress.tag)==(HostRoot)then
                     pushHostRootContext(workInProgress);
                    resetHydrationState()
                elseif(workInProgress.tag)==(HostComponent)then
                     pushHostContext(workInProgress)
                elseif(workInProgress.tag)==(ClassComponent)then
                     local Component=workInProgress.type;
                    if isLegacyContextProvider(Component)then
                         pushLegacyContextProvider(workInProgress)
                    end
                 elseif(workInProgress.tag)==(HostPortal)then
                     pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo)
                elseif(workInProgress.tag)==(ContextProvider)then
                     local newValue=workInProgress.memoizedProps.value;
                    pushProvider(workInProgress,newValue)
                elseif(workInProgress.tag)==(Profiler)then
                     if enableProfilerTimer then
                         local stateNode=workInProgress.stateNode;
                        stateNode.effectDuration=0;
                        stateNode.passiveEffectDuration=0
                     end
                 elseif(workInProgress.tag)==(SuspenseComponent)then
                     local state=workInProgress.memoizedState;
                    if(state)~=(nil)then
                         if enableSuspenseServerRenderer then
                             if((state).dehydrated)~=(nil)then
                                 pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                                workInProgress.flags=bit32.bor(workInProgress.flags,DidCapture);
                                return nil
                             end
                         end;
                        local primaryChildFragment=workInProgress.child;
                        local primaryChildLanes=primaryChildFragment.childLanes;
                        if ReactFiberLane.includesSomeLane(renderLanes,primaryChildLanes)then
                             return updateSuspenseComponent(current,workInProgress,renderLanes)
                        else
                             pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                            local child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);
                            if(child)~=(nil)then
                                 return child.sibling
                             else
                                 return nil
                             end
                         end
                     else
                         pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current))
                    end
                 elseif(workInProgress.tag)==(SuspenseListComponent)then
                     unimplemented("beginWork: SuspenseListComponent")
                elseif((workInProgress.tag)==(OffscreenComponent))or((workInProgress.tag)==(LegacyHiddenComponent))then
                     workInProgress.lanes=ReactFiberLane.NoLanes;
                    return updateOffscreenComponent(current,workInProgress,renderLanes)
                end;
                return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)
            else
                 if(bit32.band(current.flags,ForceUpdateForLegacySuspense))~=(NoFlags)then
                     didReceiveUpdate=true
                 else
                     didReceiveUpdate=false
                 end
             end
         else
             didReceiveUpdate=false
         end;
        workInProgress.lanes=ReactFiberLane.NoLanes;
        if(workInProgress.tag)==(ReactWorkTags.IndeterminateComponent)then
             return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes)
        elseif(workInProgress.tag)==(LazyComponent)then
             local elementType=workInProgress.elementType;
            return mountLazyComponent(current,workInProgress,elementType,updateLanes,renderLanes)
        elseif(workInProgress.tag)==(FunctionComponent)then
             local Component=workInProgress.type;
            local unresolvedProps=workInProgress.pendingProps;
            local resolvedProps;
            if(workInProgress.elementType)==(Component)then
                 resolvedProps=unresolvedProps
             else
                 resolvedProps=resolveDefaultProps(Component,unresolvedProps)
            end;
            return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes)
        elseif(workInProgress.tag)==(ClassComponent)then
             local Component=workInProgress.type;
            local unresolvedProps=workInProgress.pendingProps;
            local resolvedProps=(((workInProgress.elementType)==(Component))and(unresolvedProps))or(resolveDefaultProps(Component,unresolvedProps));
            return updateClassComponent(current,workInProgress,Component,resolvedProps,renderLanes)
        elseif(workInProgress.tag)==(HostRoot)then
             return updateHostRoot(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(HostComponent)then
             return updateHostComponent(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(HostText)then
             return updateHostText(current,workInProgress)
        elseif(workInProgress.tag)==(SuspenseComponent)then
             return updateSuspenseComponent(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(HostPortal)then
             return updatePortalComponent(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(ForwardRef)then
             local type=workInProgress.type;
            local unresolvedProps=workInProgress.pendingProps;
            local resolvedProps=unresolvedProps;
            if(workInProgress.elementType)~=(type)then
                 resolvedProps=resolveDefaultProps(type,unresolvedProps)
            end;
            return updateForwardRef(current,workInProgress,type,resolvedProps,renderLanes)
        elseif(workInProgress.tag)==(Fragment)then
             return updateFragment(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(Mode)then
             return updateMode(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(Profiler)then
             return updateProfiler(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(ContextProvider)then
             return updateContextProvider(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(ContextConsumer)then
             return updateContextConsumer(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(MemoComponent)then
             local type_=workInProgress.type;
            local unresolvedProps=workInProgress.pendingProps;
            local resolvedProps=resolveDefaultProps(type_,unresolvedProps);
            if(__DEV__)or(__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__)then
                 if(workInProgress.type)~=(workInProgress.elementType)then
                     local outerPropTypes;
                    local validateProps;
                    if(type(type_))==("table")then
                         outerPropTypes=type_.propTypes;
                        validateProps=type_.validateProps
                     end;
                    if(outerPropTypes)or(validateProps)then
                         checkPropTypes(outerPropTypes,validateProps,resolvedProps,"prop",getComponentName(type_))
                    end
                 end
             end;
            resolvedProps=resolveDefaultProps(type_.type,resolvedProps);
            return updateMemoComponent(current,workInProgress,type_,resolvedProps,updateLanes,renderLanes)
        elseif(workInProgress.tag)==(SimpleMemoComponent)then
             return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,updateLanes,renderLanes)
        elseif(workInProgress.tag)==(IncompleteClassComponent)then
             local Component=workInProgress.type;
            local unresolvedProps=workInProgress.pendingProps;
            local resolvedProps=(((workInProgress.elementType)==(Component))and(unresolvedProps))or(resolveDefaultProps(Component,unresolvedProps));
            return mountIncompleteClassComponent(current,workInProgress,Component,resolvedProps,renderLanes)
        elseif(workInProgress.tag)==(OffscreenComponent)then
             return updateOffscreenComponent(current,workInProgress,renderLanes)
        elseif(workInProgress.tag)==(LegacyHiddenComponent)then
             return updateLegacyHiddenComponent(current,workInProgress,renderLanes)
        end;
        invariant(false,"Unknown unit of work tag (%s). This error is likely caused by a bug in React. Please file an issue.",tostring(workInProgress.tag));
        return nil
     end;
    exports.beginWork=beginWork;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberCompleteWork.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberCompleteWork.new",function()
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(tostring(message)));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")),2)
    end;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local OffscreenLane=ReactFiberLane.OffscreenLane;
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberOffscreenComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberOffscreenComponent");
    type("not printable... yet");
    local ReactMutableSource=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactMutableSource.new");
    local resetMutableSourceWorkInProgressVersions=ReactMutableSource.resetWorkInProgressVersions;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local IndeterminateComponent=ReactWorkTags.IndeterminateComponent;
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostRoot=ReactWorkTags.HostRoot;
    local HostComponent=ReactWorkTags.HostComponent;
    local HostText=ReactWorkTags.HostText;
    local HostPortal=ReactWorkTags.HostPortal;
    local ContextProvider=ReactWorkTags.ContextProvider;
    local ContextConsumer=ReactWorkTags.ContextConsumer;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local Fragment=ReactWorkTags.Fragment;
    local Mode=ReactWorkTags.Mode;
    local Profiler=ReactWorkTags.Profiler;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local MemoComponent=ReactWorkTags.MemoComponent;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local LazyComponent=ReactWorkTags.LazyComponent;
    local IncompleteClassComponent=ReactWorkTags.IncompleteClassComponent;
    local FundamentalComponent=ReactWorkTags.FundamentalComponent;
    local ScopeComponent=ReactWorkTags.ScopeComponent;
    local Block=ReactWorkTags.Block;
    local OffscreenComponent=ReactWorkTags.OffscreenComponent;
    local LegacyHiddenComponent=ReactWorkTags.LegacyHiddenComponent;
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    type("not printable... yet");
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local NoMode=ReactTypeOfMode.NoMode;
    local ConcurrentMode=ReactTypeOfMode.ConcurrentMode;
    local BlockingMode=ReactTypeOfMode.BlockingMode;
    local ProfileMode=ReactTypeOfMode.ProfileMode;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local Ref=ReactFiberFlags.Ref;
    local Update=ReactFiberFlags.Update;
    local Callback=ReactFiberFlags.Callback;
    local Passive=ReactFiberFlags.Passive;
    local Deletion=ReactFiberFlags.Deletion;
    local NoFlags=ReactFiberFlags.NoFlags;
    local DidCapture=ReactFiberFlags.DidCapture;
    local Snapshot=ReactFiberFlags.Snapshot;
    local MutationMask=ReactFiberFlags.MutationMask;
    local LayoutMask=ReactFiberFlags.LayoutMask;
    local PassiveMask=ReactFiberFlags.PassiveMask;
    local StaticMask=ReactFiberFlags.StaticMask;
    local PerformedWork=ReactFiberFlags.PerformedWork;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local createInstance=ReactFiberHostConfig.createInstance;
    local createTextInstance=ReactFiberHostConfig.createTextInstance;
    local appendInitialChild=ReactFiberHostConfig.appendInitialChild;
    local finalizeInitialChildren=ReactFiberHostConfig.finalizeInitialChildren;
    local prepareUpdate=ReactFiberHostConfig.prepareUpdate;
    local supportsMutation=ReactFiberHostConfig.supportsMutation;
    local supportsPersistence=ReactFiberHostConfig.supportsPersistence;
    local createContainerChildSet=ReactFiberHostConfig.createContainerChildSet;
    local finalizeContainerChildren=ReactFiberHostConfig.finalizeContainerChildren;
    local preparePortalMount=ReactFiberHostConfig.preparePortalMount;
    local ReactFiberHostContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostContext.new");
    local getRootHostContainer=ReactFiberHostContext.getRootHostContainer;
    local popHostContext=ReactFiberHostContext.popHostContext;
    local getHostContext=ReactFiberHostContext.getHostContext;
    local popHostContainer=ReactFiberHostContext.popHostContainer;
    local ReactFiberSuspenseContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseContext.new");
    local popSuspenseContext=ReactFiberSuspenseContext.popSuspenseContext;
    local suspenseStackCursor=ReactFiberSuspenseContext.suspenseStackCursor;
    local InvisibleParentSuspenseContext=ReactFiberSuspenseContext.InvisibleParentSuspenseContext;
    local hasSuspenseContext=ReactFiberSuspenseContext.hasSuspenseContext;
    type("not printable... yet");
    local ReactFiberContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new");
    local isLegacyContextProvider=ReactFiberContext.isContextProvider;
    local popLegacyContext=ReactFiberContext.popContext;
    local popTopLevelLegacyContextObject=ReactFiberContext.popTopLevelContextObject;
    local popProvider=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new").popProvider;
    local ReactFiberHydrationContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHydrationContext.new");
    local prepareToHydrateHostSuspenseInstance=ReactFiberHydrationContext.prepareToHydrateHostSuspenseInstance;
    local popHydrationState=ReactFiberHydrationContext.popHydrationState;
    local resetHydrationState=ReactFiberHydrationContext.resetHydrationState;
    local prepareToHydrateHostInstance=ReactFiberHydrationContext.prepareToHydrateHostInstance;
    local prepareToHydrateHostTextInstance=ReactFiberHydrationContext.prepareToHydrateHostTextInstance;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableSchedulerTracing=ReactFeatureFlags.enableSchedulerTracing;
    local enableSuspenseCallback=ReactFeatureFlags.enableSuspenseCallback;
    local enableSuspenseServerRenderer=ReactFeatureFlags.enableSuspenseServerRenderer;
    local enableFundamentalAPI=ReactFeatureFlags.enableFundamentalAPI;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
    local popRenderLanes=ReactFiberWorkLoop.popRenderLanes;
    local markSpawnedWork=ReactFiberWorkLoop.markSpawnedWork;
    local renderDidSuspend=ReactFiberWorkLoop.renderDidSuspend;
    local renderDidSuspendDelayIfPossible=ReactFiberWorkLoop.renderDidSuspendDelayIfPossible;
    local NoLanes=ReactFiberLane.NoLanes;
    local includesSomeLane=ReactFiberLane.includesSomeLane;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local ReactProfilerTimer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new");
    local transferActualDuration=ReactProfilerTimer.transferActualDuration;
    local function markUpdate(workInProgress)
        workInProgress.flags=bit32.bor(workInProgress.flags,Update)
    end;
    local function markRef(workInProgress)
        workInProgress.flags=bit32.bor(workInProgress.flags,Ref)
    end;
    local function hadNoMutationsEffects(current,completedWork)
        local didBailout=((current)~=(nil))and((current.child)==(completedWork.child));
        if didBailout then
             return true
         end;
        local child=completedWork.child;
        while(child)~=(nil)do
             if(bit32.band(child.flags,MutationMask))~=(NoFlags)then
                 return false
             end;
            if(bit32.band(child.subtreeFlags,MutationMask))~=(NoFlags)then
                 return false
             end;
            child=child.sibling
         end;
        return true
     end;
    local appendAllChildren;
    local updateHostContainer;
    local updateHostComponent;
    local updateHostText;
    if supportsMutation then
         appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden)
            local node=workInProgress.child;
            while(node)~=(nil)do
                 if((node.tag)==(HostComponent))or((node.tag)==(HostText))then
                     appendInitialChild(parent,node.stateNode)
                elseif(enableFundamentalAPI)and((node.tag)==(FundamentalComponent))then
                     appendInitialChild(parent,node.stateNode.instance)
                elseif(node.tag)==(HostPortal)then
                    
                 elseif(node.child)~=(nil)then
                     node.child.return_=node;
                    node=node.child;
                    continue
                 end;
                if(node)==(workInProgress)then
                     return
                 end;
                while(node.sibling)==(nil)do
                     if((node.return_)==(nil))or((node.return_)==(workInProgress))then
                         return
                     end;
                    node=node.return_
                 end;
                (node.sibling).return_=node.return_;
                node=node.sibling
             end
         end;
        updateHostContainer=function(current,workInProgress)
            
        end;
        function updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance)
            local oldProps=current.memoizedProps;
            if(oldProps)==(newProps)then
                 return
             end;
            local instance=workInProgress.stateNode;
            local currentHostContext=getHostContext();
            local updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);
            workInProgress.updateQueue=updatePayload;
            if updatePayload then
                 markUpdate(workInProgress)
            end
         end;
        function updateHostText(current,workInProgress,oldText,newText)
            if(oldText)~=(newText)then
                 markUpdate(workInProgress)
            end
         end
     elseif supportsPersistence then
         appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden)
            unimplemented("appendAllChildren")
        end;
        local function appendAllChildrenToContainer(containerChildSet,workInProgress,needsVisibilityToggle,isHidden)
            unimplemented("appendAllChildrenToContainer")
        end;
        function updateHostContainer(current,workInProgress)
            local portalOrRoot=workInProgress.stateNode;
            local childrenUnchanged=hadNoMutationsEffects(current,workInProgress);
            if childrenUnchanged then
                
             else
                 local container=portalOrRoot.containerInfo;
                local newChildSet=createContainerChildSet(container);
                appendAllChildrenToContainer(newChildSet,workInProgress,false,false);
                portalOrRoot.pendingChildren=newChildSet;
                markUpdate(workInProgress);
                finalizeContainerChildren(container,newChildSet)
            end
         end
     else
         updateHostContainer=function(current,workInProgress)
            
        end
     end;
    local function bubbleProperties(completedWork)
        local didBailout=((completedWork.alternate)~=(nil))and(((completedWork.alternate).child)==(completedWork.child));
        local newChildLanes=NoLanes;
        local subtreeFlags=NoFlags;
        if not(didBailout)then
             if(enableProfilerTimer)and((bit32.band(completedWork.mode,ProfileMode))~=(NoMode))then
                 local actualDuration=completedWork.actualDuration;
                local treeBaseDuration=completedWork.selfBaseDuration;
                local child=completedWork.child;
                while(child)~=(nil)do
                     newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));
                    subtreeFlags=bit32.bor(subtreeFlags,child.subtreeFlags);
                    subtreeFlags=bit32.bor(subtreeFlags,child.flags);
                    actualDuration+=child.actualDuration;
                    treeBaseDuration+=child.treeBaseDuration;
                    child=child.sibling
                 end;
                completedWork.actualDuration=actualDuration;
                completedWork.treeBaseDuration=treeBaseDuration
             else
                 local child=completedWork.child;
                while(child)~=(nil)do
                     newChildLanes=bit32.bor(newChildLanes,bit32.bor(child.lanes,child.childLanes));
                    subtreeFlags=bit32.bor(subtreeFlags,child.subtreeFlags);
                    subtreeFlags=bit32.bor(subtreeFlags,child.flags);
                    child.return_=completedWork;
                    child=child.sibling
                 end
             end;
            completedWork.subtreeFlags=bit32.bor(completedWork.subtreeFlags,subtreeFlags)
        else
             if(enableProfilerTimer)and((bit32.band(completedWork.mode,ProfileMode))~=(NoMode))then
                 local treeBaseDuration=completedWork.selfBaseDuration;
                local child=completedWork.child;
                while(child)~=(nil)do
                     newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));
                    subtreeFlags=bit32.bor(subtreeFlags,bit32.band(child.subtreeFlags,StaticMask));
                    subtreeFlags=bit32.bor(subtreeFlags,bit32.band(child.flags,StaticMask));
                    treeBaseDuration+=child.treeBaseDuration;
                    child=child.sibling
                 end;
                completedWork.treeBaseDuration=treeBaseDuration
             else
                 local child=completedWork.child;
                while(child)~=(nil)do
                     newChildLanes=bit32.bor(newChildLanes,bit32.bor(child.lanes,child.childLanes));
                    subtreeFlags=bit32.bor(subtreeFlags,bit32.band(child.subtreeFlags,StaticMask));
                    subtreeFlags=bit32.bor(subtreeFlags,bit32.band(child.flags,StaticMask));
                    child.return_=completedWork;
                    child=child.sibling
                 end
             end;
            completedWork.subtreeFlags=bit32.bor(completedWork.subtreeFlags,subtreeFlags)
        end;
        completedWork.childLanes=newChildLanes;
        return didBailout
     end;
    local function completeWork(current,workInProgress,renderLanes)
        local newProps=workInProgress.pendingProps;
        if(((((((((workInProgress.tag)==(IndeterminateComponent))or((workInProgress.tag)==(LazyComponent)))or((workInProgress.tag)==(SimpleMemoComponent)))or((workInProgress.tag)==(FunctionComponent)))or((workInProgress.tag)==(ForwardRef)))or((workInProgress.tag)==(Fragment)))or((workInProgress.tag)==(Mode)))or((workInProgress.tag)==(ContextConsumer)))or((workInProgress.tag)==(MemoComponent))then
             bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(ClassComponent)then
             local Component=workInProgress.type;
            if isLegacyContextProvider(Component)then
                 popLegacyContext(workInProgress)
            end;
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(HostRoot)then
             popHostContainer(workInProgress);
            popTopLevelLegacyContextObject(workInProgress);
            resetMutableSourceWorkInProgressVersions();
            local fiberRoot=workInProgress.stateNode;
            if fiberRoot.pendingContext then
                 fiberRoot.context=fiberRoot.pendingContext;
                fiberRoot.pendingContext=nil
             end;
            if((current)==(nil))or((current.child)==(nil))then
                 local wasHydrated=popHydrationState(workInProgress);
                if wasHydrated then
                     markUpdate(workInProgress)
                elseif not(fiberRoot.hydrate)then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Snapshot)
                end
             end;
            updateHostContainer(current,workInProgress);
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(HostComponent)then
             popHostContext(workInProgress);
            local rootContainerInstance=getRootHostContainer();
            local type=workInProgress.type;
            if((current)~=(nil))and((workInProgress.stateNode)~=(nil))then
                 updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance);
                if(current.ref)~=(workInProgress.ref)then
                     markRef(workInProgress)
                end
             else
                 if not(newProps)then
                     invariant((workInProgress.stateNode)~=(nil),"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    bubbleProperties(workInProgress);
                    return nil
                 end;
                local currentHostContext=getHostContext();
                local wasHydrated=popHydrationState(workInProgress);
                if wasHydrated then
                     if prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)then
                         markUpdate(workInProgress)
                    end
                 else
                     local instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);
                    appendAllChildren(instance,workInProgress,false,false);
                    workInProgress.stateNode=instance;
                    if finalizeInitialChildren(instance,type,newProps,rootContainerInstance,currentHostContext)then
                         markUpdate(workInProgress)
                    end
                 end;
                if(workInProgress.ref)~=(nil)then
                     markRef(workInProgress)
                end
             end;
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(HostText)then
             local newText=newProps;
            if(current)and((workInProgress.stateNode)~=(nil))then
                 local oldText=current.memoizedProps;
                updateHostText(current,workInProgress,oldText,newText)
            else
                 if(typeof(newText))~=("string")then
                     invariant((workInProgress.stateNode)~=(nil),"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.")
                end;
                local rootContainerInstance=getRootHostContainer();
                local currentHostContext=getHostContext();
                local wasHydrated=popHydrationState(workInProgress);
                if wasHydrated then
                     if prepareToHydrateHostTextInstance(workInProgress)then
                         markUpdate(workInProgress)
                    end
                 else
                     workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress)
                end
             end;
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(Profiler)then
             local didBailout=bubbleProperties(workInProgress);
            if not(didBailout)then
                 local OnRenderFlag=Update;
                local OnCommitFlag=Callback;
                local OnPostCommitFlag=Passive;
                local subtreeFlags=workInProgress.subtreeFlags;
                local flags=workInProgress.flags;
                local newFlags=flags;
                if((bit32.band(flags,PerformedWork))~=(NoFlags))or((bit32.band(subtreeFlags,PerformedWork))~=(NoFlags))then
                     newFlags=bit32.bor(newFlags,OnRenderFlag)
                end;
                if((bit32.band(flags,bit32.bor(LayoutMask,Deletion)))~=(NoFlags))or((bit32.band(subtreeFlags,bit32.bor(LayoutMask,Deletion)))~=(NoFlags))then
                     newFlags=bit32.bor(newFlags,OnCommitFlag)
                end;
                if((bit32.band(flags,PassiveMask))~=(NoFlags))or((bit32.band(subtreeFlags,PassiveMask))~=(NoFlags))then
                     newFlags=bit32.bor(newFlags,OnPostCommitFlag)
                end;
                workInProgress.flags=newFlags
             end;
            return nil
         elseif(workInProgress.tag)==(SuspenseComponent)then
             popSuspenseContext(workInProgress);
            local nextState=workInProgress.memoizedState;
            if enableSuspenseServerRenderer then
                 if((nextState)~=(nil))and(((nextState).dehydrated)~=(nil))then
                     if(current)==(nil)then
                         local wasHydrated=popHydrationState(workInProgress);
                        invariant(wasHydrated,"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                        prepareToHydrateHostSuspenseInstance(workInProgress);
                        if enableSchedulerTracing then
                             markSpawnedWork(OffscreenLane)
                        end;
                        bubbleProperties(workInProgress);
                        if enableProfilerTimer then
                             if(bit32.band(workInProgress.mode,ProfileMode))~=(NoMode)then
                                 local isTimedOutSuspense=(nextState)~=(nil);
                                if isTimedOutSuspense then
                                     local primaryChildFragment=workInProgress.child;
                                    if(primaryChildFragment)~=(nil)then
                                         workInProgress.treeBaseDuration=(primaryChildFragment.treeBaseDuration)
                                    end
                                 end
                             end
                         end;
                        return nil
                     else
                         resetHydrationState();
                        if(bit32.band(workInProgress.flags,DidCapture))==(NoFlags)then
                             workInProgress.memoizedState=nil
                         end;
                        workInProgress.flags=bit32.bor(workInProgress.flags,Update);
                        bubbleProperties(workInProgress);
                        if enableProfilerTimer then
                             if(bit32.band(workInProgress.mode,ProfileMode))~=(NoMode)then
                                 local isTimedOutSuspense=(nextState)~=(nil);
                                if isTimedOutSuspense then
                                     local primaryChildFragment=workInProgress.child;
                                    if(primaryChildFragment)~=(nil)then
                                         workInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration
                                     end
                                 end
                             end
                         end;
                        return nil
                     end
                 end
             end;
            if(bit32.band(workInProgress.flags,DidCapture))~=(NoFlags)then
                 workInProgress.lanes=renderLanes;
                if(enableProfilerTimer)and((bit32.band(workInProgress.mode,ProfileMode))~=(NoMode))then
                     transferActualDuration(workInProgress)
                end;
                return workInProgress
             end;
            local nextDidTimeout=(nextState)~=(nil);
            local prevDidTimeout=false;
            if(current)==(nil)then
                 if(workInProgress.memoizedProps.fallback)~=(nil)then
                     popHydrationState(workInProgress)
                end
             else
                 local prevState=current.memoizedState;
                prevDidTimeout=(prevState)~=(nil)
            end;
            if(nextDidTimeout)and(not(prevDidTimeout))then
                 if(bit32.band(workInProgress.mode,BlockingMode))~=(NoMode)then
                     local hasInvisibleChildContext=((current)==(nil))and((workInProgress.memoizedProps.unstable_avoidThisFallback)~=(true));
                    if(hasInvisibleChildContext)or(hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext))then
                         renderDidSuspend()
                    else
                         renderDidSuspendDelayIfPossible()
                    end
                 end
             end;
            if supportsPersistence then
                 if nextDidTimeout then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            if supportsMutation then
                 if(nextDidTimeout)or(prevDidTimeout)then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            if((enableSuspenseCallback)and((workInProgress.updateQueue)~=(nil)))and((workInProgress.memoizedProps.suspenseCallback)~=(nil))then
                 workInProgress.flags=bit32.bor(workInProgress.flags,Update)
            end;
            bubbleProperties(workInProgress);
            if enableProfilerTimer then
                 if(bit32.band(workInProgress.mode,ProfileMode))~=(NoMode)then
                     if nextDidTimeout then
                         local primaryChildFragment=workInProgress.child;
                        if(primaryChildFragment)~=(nil)then
                             workInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration
                         end
                     end
                 end
             end;
            return nil
         elseif(workInProgress.tag)==(HostPortal)then
             popHostContainer(workInProgress);
            updateHostContainer(current,workInProgress);
            if(current)==(nil)then
                 preparePortalMount(workInProgress.stateNode.containerInfo)
            end;
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(ContextProvider)then
             popProvider(workInProgress);
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(IncompleteClassComponent)then
             local Component=workInProgress.type;
            if isLegacyContextProvider(Component)then
                 popLegacyContext(workInProgress)
            end;
            bubbleProperties(workInProgress);
            return nil
         elseif(workInProgress.tag)==(SuspenseListComponent)then
             unimplemented("SuspenseListComponent")
        elseif(workInProgress.tag)==(FundamentalComponent)then
             unimplemented("FundamentalComponent")
        elseif(workInProgress.tag)==(ScopeComponent)then
             unimplemented("ScopeComponent")
        elseif(workInProgress.tag)==(Block)then
             unimplemented("Block")
        elseif((workInProgress.tag)==(OffscreenComponent))or((workInProgress.tag)==(LegacyHiddenComponent))then
             popRenderLanes(workInProgress);
            local nextState=workInProgress.memoizedState;
            local nextIsHidden=(nextState)~=(nil);
            if(current)~=(nil)then
                 local prevState=current.memoizedState;
                local prevIsHidden=(prevState)~=(nil);
                if((prevIsHidden)~=(nextIsHidden))and((newProps.mode)~=("unstable-defer-without-hiding"))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            if((not(nextIsHidden))or(includesSomeLane(ReactFiberWorkLoop.subtreeRenderLanes,OffscreenLane)))or((bit32.band(workInProgress.mode,ConcurrentMode))==(NoMode))then
                 bubbleProperties(workInProgress)
            end;
            return nil
         end;
        invariant(false,"Unknown unit of work tag (%s). This error is likely caused by a bug in React. Please file an issue.",tostring(workInProgress.tag));
        return nil
     end;
    return{["completeWork"]=completeWork}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberHooks.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHooks.new",function()
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(message));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")))
    end;
    local __DEV__=_G.__DEV__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local Error=LuauPolyfill.Error;
    local Object=LuauPolyfill.Object;
    local createRef=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react").createRef;
    local createBinding=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react").createBinding;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    local ReactHookEffectTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactHookEffectTags");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactSharedInternals=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSharedInternals;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableDebugTracing=ReactFeatureFlags.enableDebugTracing;
    local enableSchedulingProfiler=ReactFeatureFlags.enableSchedulingProfiler;
    local enableNewReconciler=ReactFeatureFlags.enableNewReconciler;
    local enableDoubleInvokingEffects=ReactFeatureFlags.enableDoubleInvokingEffects;
    local DebugTracingMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode").DebugTracingMode;
    local NoLane=ReactFiberLane.NoLane;
    local NoLanes=ReactFiberLane.NoLanes;
    local isSubsetOfLanes=ReactFiberLane.isSubsetOfLanes;
    local mergeLanes=ReactFiberLane.mergeLanes;
    local removeLanes=ReactFiberLane.removeLanes;
    local markRootEntangled=ReactFiberLane.markRootEntangled;
    local markRootMutableRead=ReactFiberLane.markRootMutableRead;
    local ReactFiberNewContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new");
    local readContext=ReactFiberNewContext.readContext;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local UpdateEffect=ReactFiberFlags.Update;
    local PassiveEffect=ReactFiberFlags.Passive;
    local PassiveStaticEffect=ReactFiberFlags.PassiveStatic;
    local MountLayoutDevEffect=ReactFiberFlags.MountLayoutDev;
    local MountPassiveDevEffect=ReactFiberFlags.MountPassiveDev;
    local HookHasEffect=ReactHookEffectTags.HasEffect;
    local HookLayout=ReactHookEffectTags.Layout;
    local HookPassive=ReactHookEffectTags.Passive;
    local ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
    local warnIfNotCurrentlyActingUpdatesInDEV=ReactFiberWorkLoop.warnIfNotCurrentlyActingUpdatesInDEV;
    local scheduleUpdateOnFiber=ReactFiberWorkLoop.scheduleUpdateOnFiber;
    local warnIfNotScopedWithMatchingAct=ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct;
    local requestEventTime=ReactFiberWorkLoop.requestEventTime;
    local requestUpdateLane=ReactFiberWorkLoop.requestUpdateLane;
    local markSkippedUpdateLanes=ReactFiberWorkLoop.markSkippedUpdateLanes;
    local getWorkInProgressRoot=ReactFiberWorkLoop.getWorkInProgressRoot;
    local warnIfNotCurrentlyActingEffectsInDEV=ReactFiberWorkLoop.warnIfNotCurrentlyActingEffectsInDEV;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local function is(x,y)
        return(((x)==(y))and((((x)~=(0))or(((1)/(x))==((1)/(y))))))or(((x)~=(x))and((y)~=(y)))
    end;
    local markWorkInProgressReceivedUpdate=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberBeginWork.new").markWorkInProgressReceivedUpdate;
    local getIsHydrating=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHydrationContext.new").getIsHydrating;
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local makeClientId=ReactFiberHostConfig.makeClientId;
    local ReactMutableSource=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactMutableSource.new");
    local warnAboutMultipleRenderersDEV=ReactMutableSource.warnAboutMultipleRenderersDEV;
    local getWorkInProgressVersion=ReactMutableSource.getWorkInProgressVersion;
    local setWorkInProgressVersion=ReactMutableSource.setWorkInProgressVersion;
    local markSourceAsDirty=ReactMutableSource.markSourceAsDirty;
    local logStateUpdateScheduled=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.DebugTracing").logStateUpdateScheduled;
    local markStateUpdateScheduled=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler").markStateUpdateScheduled;
    local ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local didWarnAboutMismatchedHooksForComponent;
    local _didWarnAboutUseOpaqueIdentifier;
    if __DEV__ then
         _didWarnAboutUseOpaqueIdentifier={};
        didWarnAboutMismatchedHooksForComponent={}
    end;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    local renderLanes=NoLanes;
    local currentlyRenderingFiber=nil;
    local currentHook;
    local workInProgressHook;
    local didScheduleRenderPhaseUpdate=false;
    local didScheduleRenderPhaseUpdateDuringThisPass=false;
    local RE_RENDER_LIMIT=25;
    local currentHookNameInDev;
    local hookTypesDev;
    local hookTypesUpdateIndexDev=0;
    local ignorePreviousDependencies=false;
    local HooksDispatcherOnMountInDEV;
    local HooksDispatcherOnMountWithHookTypesInDEV;
    local HooksDispatcherOnUpdateInDEV;
    local HooksDispatcherOnRerenderInDEV;
    local InvalidNestedHooksDispatcherOnMountInDEV;
    local InvalidNestedHooksDispatcherOnUpdateInDEV;
    local InvalidNestedHooksDispatcherOnRerenderInDEV;
    local function getHighestIndex(array)
        local highestIndex=0;
        for k,v in array do
             highestIndex=if(k)>(highestIndex)then k else highestIndex
         end;
        return highestIndex
     end;
    local function isArrayOrSparseArray(deps)
        if(type(deps))~=("table")then
             return false
         end;
        for k,_v in deps do
             if(type(k))~=("number")then
                 return false
             end
         end;
        return true
     end;
    local function mountHookTypesDev()
        if __DEV__ then
             local hookName=(currentHookNameInDev);
            if(hookTypesDev)==(nil)then
                 hookTypesDev=({hookName})
            else
                 table.insert(hookTypesDev,hookName)
            end
         end
     end;
    function updateHookTypesDev()
        if __DEV__ then
             local hookName=(currentHookNameInDev);
            if(hookTypesDev)~=(nil)then
                 hookTypesUpdateIndexDev+=1;
                if(hookTypesDev[hookTypesUpdateIndexDev])~=(hookName)then
                     warnOnHookMismatchInDev(hookName)
                end
             end
         end
     end;
    local function checkDepsAreArrayDev(deps)
        if __DEV__ then
             if((deps)~=(nil))and(not(isArrayOrSparseArray(deps)))then
                 console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",currentHookNameInDev,type(deps))
            end
         end
     end;
    function warnOnHookMismatchInDev(currentHookName)
        if __DEV__ then
             local componentName=(getComponentName(currentlyRenderingFiber.type))or("Component");
            if not(didWarnAboutMismatchedHooksForComponent[componentName])then
                 didWarnAboutMismatchedHooksForComponent[componentName]=true;
                if(hookTypesDev)~=(nil)then
                     local table_="";
                    local secondColumnStart=30;
                    for i=1,hookTypesUpdateIndexDev do
                         local oldHookName=(hookTypesDev)[i];
                        local newHookName;
                        if(i)==(hookTypesUpdateIndexDev)then
                             newHookName=currentHookName
                         else
                             newHookName=oldHookName
                         end;
                        local row=(tostring(i))..((". ")..(((oldHookName)or("undefined"))));
                        while(string.len(row))<(secondColumnStart)do
                             row..=" "
                        end;
                        row..=(newHookName)..("\x0a");
                        table_..=row
                     end;
                    console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\x0a\x0a   Previous render            Next render\x0a   ------------------------------------------------------\x0a%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\x0a",componentName,table_)
                end
             end
         end
     end;
    local function throwInvalidHookError()
        error(Error.new("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\x0a1. You might have mismatching versions of React and the renderer (such as React DOM)\x0a2. You might be breaking the Rules of Hooks\x0a3. You might have more than one copy of React in the same app\x0aSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."))
    end;
    local function areHookInputsEqual(nextDeps,prevDeps)
        if __DEV__ then
             if ignorePreviousDependencies then
                 return false
             end
         end;
        if(prevDeps)==(nil)then
             if __DEV__ then
                 console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",currentHookNameInDev)
            end;
            return false
         end;
        local nextDepsLength=getHighestIndex(nextDeps);
        local prevDepsLength=getHighestIndex(prevDeps);
        if(nextDepsLength)~=(prevDepsLength)then
             return false
         end;
        local minDependencyCount=math.min(prevDepsLength,nextDepsLength);
        for i=1,minDependencyCount do
             if is(nextDeps[i],prevDeps[i])then
                 continue
             end;
            return false
         end;
        return true
     end;
    exports.bailoutHooks=function(current,workInProgress,lanes)
        workInProgress.updateQueue=current.updateQueue;
        if(__DEV__)and(enableDoubleInvokingEffects)then
             workInProgress.flags=bit32.band(workInProgress.flags,bit32.bnot(bit32.bor(MountPassiveDevEffect,PassiveEffect,MountLayoutDevEffect,UpdateEffect)))
        else
             workInProgress.flags=bit32.band(workInProgress.flags,bit32.bnot(bit32.bor(PassiveEffect,UpdateEffect)))
        end;
        current.lanes=removeLanes(current.lanes,lanes)
    end;
    local _isUpdatingOpaqueValueInRenderPhase=false;
    exports.resetHooksAfterThrow=function()
        ReactCurrentDispatcher.current=exports.ContextOnlyDispatcher;
        if didScheduleRenderPhaseUpdate then
             local hook=currentlyRenderingFiber.memoizedState;
            while(hook)~=(nil)do
                 local queue=hook.queue;
                if(queue)~=(nil)then
                     queue.pending=nil
                 end;
                hook=hook.next
             end;
            didScheduleRenderPhaseUpdate=false
         end;
        renderLanes=NoLanes;
        currentlyRenderingFiber=nil;
        currentHook=nil;
        workInProgressHook=nil;
        if __DEV__ then
             hookTypesDev=nil;
            hookTypesUpdateIndexDev=0;
            currentHookNameInDev=nil;
            _isUpdatingOpaqueValueInRenderPhase=false
         end;
        didScheduleRenderPhaseUpdateDuringThisPass=false
     end;
    local function mountWorkInProgressHook()
        local hook={["memoizedState"]=nil,["baseState"]=nil,["baseQueue"]=nil,["queue"]=nil,["next"]=nil};
        if(workInProgressHook)==(nil)then
             currentlyRenderingFiber.memoizedState=hook;
            workInProgressHook=hook
         else
             workInProgressHook.next=hook;
            workInProgressHook=hook
         end;
        return workInProgressHook
     end;
    local function updateWorkInProgressHook()
        local nextCurrentHook;
        if(currentHook)==(nil)then
             local current=currentlyRenderingFiber.alternate;
            if(current)~=(nil)then
                 nextCurrentHook=current.memoizedState
             else
                 nextCurrentHook=nil
             end
         else
             nextCurrentHook=currentHook.next
         end;
        local nextWorkInProgressHook;
        if(workInProgressHook)==(nil)then
             nextWorkInProgressHook=currentlyRenderingFiber.memoizedState
         else
             nextWorkInProgressHook=workInProgressHook.next
         end;
        if(nextWorkInProgressHook)~=(nil)then
             workInProgressHook=nextWorkInProgressHook;
            nextWorkInProgressHook=workInProgressHook.next;
            currentHook=nextCurrentHook
         else
             if(nextCurrentHook)==(nil)then
                 error(Error.new("Rendered more hooks than during the previous render."))
            end;
            currentHook=nextCurrentHook;
            local newHook={["memoizedState"]=currentHook.memoizedState,["baseState"]=currentHook.baseState,["baseQueue"]=currentHook.baseQueue,["queue"]=currentHook.queue,["next"]=nil};
            if(workInProgressHook)==(nil)then
                 workInProgressHook=newHook;
                currentlyRenderingFiber.memoizedState=newHook
             else
                 workInProgressHook.next=newHook;
                workInProgressHook=newHook
             end
         end;
        return workInProgressHook
     end;
    function basicStateReducer(state,action)
        if(type(action))==("function")then
             return action(state)
        else
             return action
         end
     end;
    function mountReducer(reducer,initialArg,init)
        local hook=mountWorkInProgressHook();
        local initialState;
        if(init)~=(nil)then
             initialState=init(initialArg)
        else
             initialState=(initialArg)
        end;
        hook.baseState=initialState;
        hook.memoizedState=hook.baseState;
        local queue={["pending"]=nil,["dispatch"]=nil,["lastRenderedReducer"]=reducer,["lastRenderedState"]=initialState};
        hook.queue=queue;
        local cRF=currentlyRenderingFiber;
        local dispatch=function(action,...)
            dispatchAction(cRF,queue,action,...)
        end;
        queue.dispatch=dispatch;
        return hook.memoizedState,dispatch
     end;
    function updateReducer(reducer,initialArg,init)
        local hook=updateWorkInProgressHook();
        local queue=hook.queue;
        assert((queue)~=(nil),"Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer=reducer;
        local current=currentHook;
        local baseQueue=current.baseQueue;
        local pendingQueue=queue.pending;
        if(pendingQueue)~=(nil)then
             if(baseQueue)~=(nil)then
                 local baseFirst=baseQueue.next;
                local pendingFirst=pendingQueue.next;
                baseQueue.next=pendingFirst;
                pendingQueue.next=baseFirst
             end;
            baseQueue=pendingQueue;
            current.baseQueue=baseQueue;
            queue.pending=nil
         end;
        if(baseQueue)~=(nil)then
             local first=baseQueue.next;
            local newState=current.baseState;
            local newBaseState;
            local newBaseQueueFirst;
            local newBaseQueueLast;
            local update=first;
            repeat
                 local updateLane=update.lane;
                if(bit32.band(renderLanes,updateLane))~=(updateLane)then
                     local clone={["lane"]=updateLane,["action"]=update.action,["eagerReducer"]=update.eagerReducer,["eagerState"]=update.eagerState,["next"]=nil};
                    if(newBaseQueueLast)==(nil)then
                         newBaseQueueLast=clone;
                        newBaseQueueFirst=newBaseQueueLast;
                        newBaseState=newState
                     else
                         newBaseQueueLast.next=clone;
                        newBaseQueueLast=newBaseQueueLast.next
                     end;
                    currentlyRenderingFiber.lanes=mergeLanes(currentlyRenderingFiber.lanes,updateLane);
                    markSkippedUpdateLanes(updateLane)
                else
                     if(newBaseQueueLast)~=(nil)then
                         local clone={["lane"]=NoLane,["action"]=update.action,["eagerReducer"]=update.eagerReducer,["eagerState"]=update.eagerState,["next"]=nil};
                        newBaseQueueLast.next=clone;
                        newBaseQueueLast=newBaseQueueLast.next
                     end;
                    if(update.eagerReducer)==(reducer)then
                         newState=update.eagerState
                     else
                         local action=update.action;
                        newState=reducer(newState,action)
                    end
                 end;
                update=update.next
             until((update)==(nil))or((update)==(first));
            if(newBaseQueueLast)==(nil)then
                 newBaseState=newState
             else
                 newBaseQueueLast.next=newBaseQueueFirst
             end;
            if not(is(newState,hook.memoizedState))then
                 markWorkInProgressReceivedUpdate()
            end;
            hook.memoizedState=newState;
            hook.baseState=newBaseState;
            hook.baseQueue=newBaseQueueLast;
            queue.lastRenderedState=newState
         end;
        local dispatch=queue.dispatch;
        return hook.memoizedState,dispatch
     end;
    function rerenderReducer(reducer,initialArg,init)
        local hook=updateWorkInProgressHook();
        local queue=hook.queue;
        assert((queue)~=(nil),"Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer=reducer;
        local dispatch=queue.dispatch;
        local lastRenderPhaseUpdate=queue.pending;
        local newState=hook.memoizedState;
        if(lastRenderPhaseUpdate)~=(nil)then
             queue.pending=nil;
            local firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;
            local update=firstRenderPhaseUpdate;
            repeat
                 local action=update.action;
                newState=reducer(newState,action);
                update=update.next
             until(update)==(firstRenderPhaseUpdate);
            if not(is(newState,hook.memoizedState))then
                 markWorkInProgressReceivedUpdate()
            end;
            hook.memoizedState=newState;
            if(hook.baseQueue)==(nil)then
                 hook.baseState=newState
             end;
            queue.lastRenderedState=newState
         end;
        return newState,dispatch
     end;
    type("not printable... yet");
    function readFromUnsubcribedMutableSource(root,source,getSnapshot)
        if __DEV__ then
             warnAboutMultipleRenderersDEV(source)
        end;
        local getVersion=source._getVersion;
        local version_=getVersion(source._source);
        local isSafeToReadFromSource=false;
        local currentRenderVersion=getWorkInProgressVersion(source);
        if(currentRenderVersion)~=(nil)then
             isSafeToReadFromSource=(currentRenderVersion)==(version_)
        else
             isSafeToReadFromSource=isSubsetOfLanes(renderLanes,root.mutableReadLanes);
            if isSafeToReadFromSource then
                 setWorkInProgressVersion(source,version_)
            end
         end;
        if isSafeToReadFromSource then
             local snapshot=getSnapshot(source._source);
            if __DEV__ then
                 if(type(snapshot))==("function")then
                     console.error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.")
                end
             end;
            return snapshot
         else
             markSourceAsDirty(source);
            error(Error.new("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."))
        end
     end;
    function useMutableSource(hook,source,getSnapshot,subscribe)
        local root=getWorkInProgressRoot();
        invariant((root)~=(nil),"Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        local getVersion=source._getVersion;
        local version_=getVersion(source._source);
        local dispatcher=ReactCurrentDispatcher.current;
        assert((dispatcher)~=(nil),"dispatcher was nil, this is a bug in React");
        local currentSnapshot,setSnapshot=dispatcher.useState(function()
            return readFromUnsubcribedMutableSource(root,source,getSnapshot)
        end);
        local snapshot=currentSnapshot;
        local stateHook=workInProgressHook;
        local memoizedState=hook.memoizedState;
        if(memoizedState.refs)==(nil)then
             error(tostring(debug.traceback()))
        end;
        local refs=memoizedState.refs;
        local prevGetSnapshot=refs.getSnapshot;
        local prevSource=memoizedState.source;
        local prevSubscribe=memoizedState.subscribe;
        local fiber=currentlyRenderingFiber;
        hook.memoizedState={["refs"]=refs,["source"]=source,["subscribe"]=subscribe};
        dispatcher.useEffect(function()
            refs.getSnapshot=getSnapshot;
            refs.setSnapshot=setSnapshot;
            local maybeNewVersion=getVersion(source._source);
            if not(is(version_,maybeNewVersion))then
                 local maybeNewSnapshot=getSnapshot(source._source);
                if __DEV__ then
                     if(type(maybeNewSnapshot))==("function")then
                         console.error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.")
                    end
                 end;
                if not(is(snapshot,maybeNewSnapshot))then
                     setSnapshot(maybeNewSnapshot);
                    local lane=requestUpdateLane(fiber);
                    markRootMutableRead(root,lane)
                end;
                markRootEntangled(root,root.mutableReadLanes)
            end
         end,{getSnapshot,source,subscribe});
        dispatcher.useEffect(function()
            local handleChange=function()
                local latestGetSnapshot=refs.getSnapshot;
                local latestSetSnapshot=refs.setSnapshot;
                local ok,result=pcall(function()
                    latestSetSnapshot(latestGetSnapshot(source._source));
                    local lane=requestUpdateLane(fiber);
                    markRootMutableRead(root,lane)
                end);
                if not(ok)then
                     latestSetSnapshot(function()
                        error(result)
                    end)
                end
             end;
            local unsubscribe=subscribe(source._source,handleChange);
            if __DEV__ then
                 if(type(unsubscribe))~=("function")then
                     console.error("Mutable source subscribe function must return an unsubscribe function.")
                end
             end;
            return unsubscribe
         end,{source,subscribe});
        if((not(is(prevGetSnapshot,getSnapshot)))or(not(is(prevSource,source))))or(not(is(prevSubscribe,subscribe)))then
             local newQueue={["pending"]=nil,["dispatch"]=nil,["lastRenderedReducer"]=basicStateReducer,["lastRenderedState"]=snapshot};
            local cRF=currentlyRenderingFiber;
            setSnapshot=function(...)
                dispatchAction(cRF,newQueue,...)
            end;
            newQueue.dispatch=setSnapshot;
            stateHook.queue=newQueue;
            stateHook.baseQueue=nil;
            snapshot=readFromUnsubcribedMutableSource(root,source,getSnapshot);
            stateHook.baseState=snapshot;
            stateHook.memoizedState=stateHook.baseState
         end;
        return snapshot
     end;
    function mountMutableSource(source,getSnapshot,subscribe)
        local hook=mountWorkInProgressHook();
        hook.memoizedState={["refs"]={["getSnapshot"]=getSnapshot,["setSnapshot"]=nil},["source"]=source,["subscribe"]=subscribe};
        return useMutableSource(hook,source,getSnapshot,subscribe)
    end;
    function updateMutableSource(source,getSnapshot,subscribe)
        local hook=updateWorkInProgressHook();
        return useMutableSource(hook,source,getSnapshot,subscribe)
    end;
    function mountState(initialState)
        local hook=mountWorkInProgressHook();
        if(type(initialState))==("function")then
             local initialStateAsFunction=initialState;
            initialState=initialStateAsFunction()
        end;
        hook.baseState=initialState;
        hook.memoizedState=hook.baseState;
        local queue={["pending"]=nil,["dispatch"]=nil,["lastRenderedReducer"]=nil,["lastRenderedState"]=initialState};
        queue.lastRenderedReducer=basicStateReducer;
        hook.queue=queue;
        local cRF=currentlyRenderingFiber;
        local dispatch=function(action,...)
            dispatchAction(cRF,queue,action,...)
        end;
        queue.dispatch=dispatch;
        return hook.memoizedState,dispatch
     end;
    function updateState(initialState)
        return updateReducer(basicStateReducer,initialState)
    end;
    function rerenderState(initialState)
        return rerenderReducer(basicStateReducer,initialState)
    end;
    local function pushEffect(tag,create,destroy,deps)
        local effect={["tag"]=tag,["create"]=create,["destroy"]=destroy,["deps"]=deps,["next"]=nil};
        local componentUpdateQueue=currentlyRenderingFiber.updateQueue;
        if(componentUpdateQueue)==(nil)then
             componentUpdateQueue={["lastEffect"]=nil};
            currentlyRenderingFiber.updateQueue=componentUpdateQueue;
            effect.next=effect;
            componentUpdateQueue.lastEffect=effect
         else
             local lastEffect=componentUpdateQueue.lastEffect;
            if(lastEffect)==(nil)then
                 componentUpdateQueue.lastEffect=effect;
                effect.next=effect
             else
                 local firstEffect=lastEffect.next;
                lastEffect.next=effect;
                effect.next=firstEffect;
                componentUpdateQueue.lastEffect=effect
             end
         end;
        return effect
     end;
    function mountBinding(initialValue)
        local hook=mountWorkInProgressHook();
        local value,updateValue=createBinding(initialValue);
        hook.memoizedState={value,updateValue};
        return value,updateValue
     end;
    function updateBinding(initialValue)
        local hook=updateWorkInProgressHook();
        return unpack(hook.memoizedState)
    end;
    function mountRef(initialValue)
        local hook=mountWorkInProgressHook();
        local ref=createRef();
        ref.current=initialValue;
        hook.memoizedState=ref;
        return ref
     end;
    function updateRef(initialValue)
        local hook=updateWorkInProgressHook();
        return hook.memoizedState
     end;
    local function mountEffectImpl(fiberFlags,hookFlags,create,deps)
        local hook=mountWorkInProgressHook();
        local nextDeps=deps;
        currentlyRenderingFiber.flags=bit32.bor(currentlyRenderingFiber.flags,fiberFlags);
        hook.memoizedState=pushEffect(bit32.bor(HookHasEffect,hookFlags),create,nil,nextDeps)
    end;
    function updateEffectImpl(fiberFlags,hookFlags,create,deps)
        local hook=updateWorkInProgressHook();
        local nextDeps=deps;
        local destroy;
        if(currentHook)~=(nil)then
             local prevEffect=currentHook.memoizedState;
            destroy=prevEffect.destroy;
            if(nextDeps)~=(nil)then
                 local prevDeps=prevEffect.deps;
                if areHookInputsEqual(nextDeps,prevDeps)then
                     hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);
                    return
                 end
             end
         end;
        currentlyRenderingFiber.flags=bit32.bor(currentlyRenderingFiber.flags,fiberFlags);
        hook.memoizedState=pushEffect(bit32.bor(HookHasEffect,hookFlags),create,destroy,nextDeps)
    end;
    local function mountEffect(create,deps)
        if __DEV__ then
             if((type(_G.jest))~=("nil"))or(_G.__TESTEZ_RUNNING_TEST__)then
                 warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
            end
         end;
        if(__DEV__)and(enableDoubleInvokingEffects)then
             mountEffectImpl(bit32.bor(MountPassiveDevEffect,PassiveEffect,PassiveStaticEffect),HookPassive,create,deps)
        else
             mountEffectImpl(bit32.bor(PassiveEffect,PassiveStaticEffect),HookPassive,create,deps)
        end
     end;
    local function updateEffect(create,deps)
        if __DEV__ then
             if((type(_G.jest))~=("nil"))or(_G.__TESTEZ_RUNNING_TEST__)then
                 warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
            end
         end;
        updateEffectImpl(PassiveEffect,HookPassive,create,deps)
    end;
    local function mountLayoutEffect(create,deps)
        if(__DEV__)and(enableDoubleInvokingEffects)then
             mountEffectImpl(bit32.bor(MountLayoutDevEffect,UpdateEffect),HookLayout,create,deps)
        else
             mountEffectImpl(UpdateEffect,HookLayout,create,deps)
        end
     end;
    local function updateLayoutEffect(create,deps)
        updateEffectImpl(UpdateEffect,HookLayout,create,deps)
    end;
    function imperativeHandleEffect(create,ref)
        if((ref)~=(nil))and((type(ref))==("function"))then
             local refCallback=ref;
            local inst=create();
            refCallback(inst);
            return function()
                return refCallback(nil)
            end
         elseif(ref)~=(nil)then
             local refObject=ref;
            if __DEV__ then
                 local isRefObject=((getmetatable(refObject))~=(nil))and((#(Object.keys(refObject)))==(0));
                if not(isRefObject)then
                     console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",("an object with keys {")..((Array.join(Object.keys(refObject),", "))..("}")))
                end
             end;
            local inst=create();
            refObject.current=inst;
            return function()
                refObject.current=nil
             end
         else
             return nil
         end
     end;
    function mountImperativeHandle(ref,create,deps)
        if __DEV__ then
             if(type(create))~=("function")then
                 console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",if(create)~=(nil)then type(create)else"nil")
            end
         end;
        local effectDeps=if(deps)~=(nil)then Array.concat(deps,{ref})else nil;
        if(__DEV__)and(enableDoubleInvokingEffects)then
             return mountEffectImpl(bit32.bor(MountLayoutDevEffect,UpdateEffect),HookLayout,function()
                return imperativeHandleEffect(create,ref)
            end,effectDeps)
        else
             return mountEffectImpl(UpdateEffect,HookLayout,function()
                return imperativeHandleEffect(create,ref)
            end,effectDeps)
        end
     end;
    function updateImperativeHandle(ref,create,deps)
        if __DEV__ then
             if(type(create))~=("function")then
                 local errorArg="nil";
                if create then
                     errorArg=type(create)
                end;
                console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",errorArg)
            end
         end;
        local effectDeps;
        if(deps)~=(nil)then
             effectDeps=table.clone(deps);
            table.insert(effectDeps,ref)
        end;
        return updateEffectImpl(UpdateEffect,HookLayout,function()
            return imperativeHandleEffect(create,ref)
        end,effectDeps)
    end;
    function mountDebugValue(value,formatterFn)
        
    end;
    local updateDebugValue=mountDebugValue;
    function mountCallback(callback,deps)
        local hook=mountWorkInProgressHook();
        local nextDeps=deps;
        hook.memoizedState={callback,nextDeps};
        return callback
     end;
    function updateCallback(callback,deps)
        local hook=updateWorkInProgressHook();
        local nextDeps=deps;
        local prevState=hook.memoizedState;
        if(prevState)~=(nil)then
             if(nextDeps)~=(nil)then
                 local prevDeps=prevState[2];
                if areHookInputsEqual(nextDeps,prevDeps)then
                     return prevState[1]
                end
             end
         end;
        hook.memoizedState={callback,nextDeps};
        return callback
     end;
    function mountMemo(nextCreate,deps)
        local hook=mountWorkInProgressHook();
        local nextDeps=deps;
        local nextValue={nextCreate()};
        hook.memoizedState={nextValue,nextDeps};
        return unpack(nextValue)
    end;
    function updateMemo(nextCreate,deps)
        local hook=updateWorkInProgressHook();
        local nextDeps=deps;
        local prevState=hook.memoizedState;
        if(prevState)~=(nil)then
             if(nextDeps)~=(nil)then
                 local prevDeps=prevState[2];
                if areHookInputsEqual(nextDeps,prevDeps)then
                     return unpack(prevState[1])
                end
             end
         end;
        local nextValue={nextCreate()};
        hook.memoizedState={nextValue,nextDeps};
        return unpack(nextValue)
    end;
    local isUpdatingOpaqueValueInRenderPhase=false;
    exports.getIsUpdatingOpaqueValueInRenderPhaseInDEV=function()
        if __DEV__ then
             return isUpdatingOpaqueValueInRenderPhase
         end;
        return nil
     end;
    function mountOpaqueIdentifier()
        local makeId;
        if __DEV__ then
             console.warn("!!! unimplemented: warnOnOpaqueIdentifierAccessInDEV")
        else
             makeId=makeClientId
         end;
        if getIsHydrating()then
             unimplemented("ReactFiberHooks: getIsHydrating() true");
            return nil
         else
             local id=makeId();
            mountState(id);
            return id
         end
     end;
    function updateOpaqueIdentifier()
        local id,_=updateState(nil);
        return id
     end;
    function rerenderOpaqueIdentifier()
        local id,_=rerenderState(nil);
        return id
     end;
    function dispatchAction(fiber,queue,action,...)
        if __DEV__ then
             local childrenLength=select("\x23",...);
            local extraArg;
            if(childrenLength)==(1)then
                 extraArg=select(1,...)
            end;
            if(type(extraArg))==("function")then
                 console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().")
            end
         end;
        local eventTime=requestEventTime();
        local lane=requestUpdateLane(fiber);
        local update={["lane"]=lane,["action"]=action,["eagerReducer"]=nil,["eagerState"]=nil,["next"]=nil};
        local pending=queue.pending;
        if(pending)==(nil)then
             update.next=update
         else
             update.next=pending.next;
            pending.next=update
         end;
        queue.pending=update;
        local alternate=fiber.alternate;
        if((fiber)==(currentlyRenderingFiber))or((((alternate)~=(nil))and((alternate)==(currentlyRenderingFiber))))then
             didScheduleRenderPhaseUpdate=true;
            didScheduleRenderPhaseUpdateDuringThisPass=true
         else
             if((fiber.lanes)==(NoLanes))and((((alternate)==(nil))or((alternate.lanes)==(NoLanes))))then
                 local lastRenderedReducer=queue.lastRenderedReducer;
                if(lastRenderedReducer)~=(nil)then
                     local prevDispatcher;
                    if __DEV__ then
                         prevDispatcher=ReactCurrentDispatcher.current;
                        ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV
                     end;
                    local currentState=queue.lastRenderedState;
                    local ok,eagerState=pcall(lastRenderedReducer,currentState,action);
                    if ok then
                         update.eagerReducer=lastRenderedReducer;
                        update.eagerState=eagerState
                     end;
                    if __DEV__ then
                         ReactCurrentDispatcher.current=prevDispatcher
                     end;
                    if is(eagerState,currentState)then
                         return
                     end;
                    if not(ok)then
                        
                     end
                 end
             end;
            if __DEV__ then
                 if((type(_G.jest))~=("nil"))or(_G.__TESTEZ_RUNNING_TEST__)then
                     warnIfNotScopedWithMatchingAct(fiber);
                    warnIfNotCurrentlyActingUpdatesInDEV(fiber)
                end
             end;
            scheduleUpdateOnFiber(fiber,lane,eventTime)
        end;
        if __DEV__ then
             if enableDebugTracing then
                 if(bit32.band(fiber.mode,DebugTracingMode))~=(0)then
                     local name=(getComponentName(fiber.type))or("Unknown");
                    logStateUpdateScheduled(name,lane,action)
                end
             end
         end;
        if enableSchedulingProfiler then
             markStateUpdateScheduled(fiber,lane)
        end;
        return
     end;
    local ContextOnlyDispatcher={["readContext"]=readContext,["useCallback"]=throwInvalidHookError,["useContext"]=throwInvalidHookError,["useEffect"]=throwInvalidHookError,["useImperativeHandle"]=throwInvalidHookError,["useLayoutEffect"]=throwInvalidHookError,["useMemo"]=throwInvalidHookError,["useReducer"]=throwInvalidHookError,["useRef"]=throwInvalidHookError,["useBinding"]=throwInvalidHookError,["useState"]=throwInvalidHookError,["useDebugValue"]=throwInvalidHookError,["useMutableSource"]=throwInvalidHookError,["useOpaqueIdentifier"]=throwInvalidHookError,["unstable_isNewReconciler"]=enableNewReconciler};
    exports.ContextOnlyDispatcher=ContextOnlyDispatcher;
    local HooksDispatcherOnMount={["readContext"]=readContext,["useCallback"]=mountCallback,["useContext"]=readContext,["useEffect"]=mountEffect,["useImperativeHandle"]=mountImperativeHandle,["useLayoutEffect"]=mountLayoutEffect,["useMemo"]=mountMemo,["useReducer"]=mountReducer,["useRef"]=mountRef,["useBinding"]=mountBinding,["useState"]=mountState,["useDebugValue"]=mountDebugValue,["useMutableSource"]=mountMutableSource,["useOpaqueIdentifier"]=mountOpaqueIdentifier,["unstable_isNewReconciler"]=enableNewReconciler};
    local HooksDispatcherOnUpdate={["readContext"]=readContext,["useCallback"]=updateCallback,["useContext"]=readContext,["useEffect"]=updateEffect,["useImperativeHandle"]=updateImperativeHandle,["useLayoutEffect"]=updateLayoutEffect,["useMemo"]=updateMemo,["useReducer"]=updateReducer,["useRef"]=updateRef,["useBinding"]=updateBinding,["useState"]=updateState,["useDebugValue"]=updateDebugValue,["useMutableSource"]=updateMutableSource,["useOpaqueIdentifier"]=updateOpaqueIdentifier,["unstable_isNewReconciler"]=enableNewReconciler};
    local HooksDispatcherOnRerender={["readContext"]=readContext,["useCallback"]=updateCallback,["useContext"]=readContext,["useEffect"]=updateEffect,["useImperativeHandle"]=updateImperativeHandle,["useLayoutEffect"]=updateLayoutEffect,["useMemo"]=updateMemo,["useReducer"]=rerenderReducer,["useRef"]=updateRef,["useBinding"]=updateBinding,["useState"]=rerenderState,["useDebugValue"]=updateDebugValue,["useMutableSource"]=updateMutableSource,["useOpaqueIdentifier"]=rerenderOpaqueIdentifier,["unstable_isNewReconciler"]=enableNewReconciler};
    if __DEV__ then
         local warnInvalidContextAccess=function()
            console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")
        end;
        local warnInvalidHookAccess=function()
            console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks")
        end;
        HooksDispatcherOnMountInDEV={["readContext"]=function(context,observedBits)
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            mountHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local results={pcall(mountMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            mountHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            mountHookTypesDev();
            return mountRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            mountHookTypesDev();
            return mountBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            mountHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            mountHookTypesDev();
            return mountDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            mountHookTypesDev();
            return mountMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            mountHookTypesDev();
            return mountOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        HooksDispatcherOnMountWithHookTypesInDEV={["readContext"]=function(context,observedBits)
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            updateHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            updateHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            updateHookTypesDev();
            return mountEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local results={pcall(mountMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            updateHookTypesDev();
            return mountRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            updateHookTypesDev();
            return mountBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            updateHookTypesDev();
            return mountDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            updateHookTypesDev();
            return mountMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            updateHookTypesDev();
            return mountOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        HooksDispatcherOnUpdateInDEV={["readContext"]=function(context,observedBits)
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            updateHookTypesDev();
            return updateCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            updateHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            updateHookTypesDev();
            return updateEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local results={pcall(updateMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(updateReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            updateHookTypesDev();
            return updateRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            updateHookTypesDev();
            return updateBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(updateState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            updateHookTypesDev();
            return updateDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            updateHookTypesDev();
            return updateMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            updateHookTypesDev();
            return updateOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        HooksDispatcherOnRerenderInDEV={["readContext"]=function(context,observedBits)
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            updateHookTypesDev();
            return mountCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            updateHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            updateHookTypesDev();
            return updateEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;
            local results={pcall(updateMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;
            local ok,result,setResult=pcall(rerenderReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            updateHookTypesDev();
            return updateRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            updateHookTypesDev();
            return updateBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;
            local ok,result,setResult=pcall(rerenderState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            updateHookTypesDev();
            return updateDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            updateHookTypesDev();
            return updateMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            updateHookTypesDev();
            return rerenderOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        InvalidNestedHooksDispatcherOnMountInDEV={["readContext"]=function(context,observedBits)
            warnInvalidContextAccess();
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local results={pcall(mountMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;
            local ok,result,setResult=pcall(mountState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        InvalidNestedHooksDispatcherOnUpdateInDEV={["readContext"]=function(context,observedBits)
            warnInvalidContextAccess();
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return mountCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local results={pcall(updateMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(updateReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(updateState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler};
        InvalidNestedHooksDispatcherOnRerenderInDEV={["readContext"]=function(context,observedBits)
            warnInvalidContextAccess();
            return readContext(context,observedBits)
        end,["useCallback"]=function(callback,deps)
            currentHookNameInDev="useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback,deps)
        end,["useContext"]=function(context,observedBits)
            currentHookNameInDev="useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context,observedBits)
        end,["useEffect"]=function(create,deps)
            currentHookNameInDev="useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create,deps)
        end,["useImperativeHandle"]=function(ref,create,deps)
            currentHookNameInDev="useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref,create,deps)
        end,["useLayoutEffect"]=function(create,deps)
            currentHookNameInDev="useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create,deps)
        end,["useMemo"]=function(create,deps)
            currentHookNameInDev="useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local results={pcall(updateMemo,create,deps)};
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(results[1])then
                 error(results[2])
            end;
            return unpack(results,2)
        end,["useReducer"]=function(reducer,initialArg,init)
            currentHookNameInDev="useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(rerenderReducer,reducer,initialArg,init);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useRef"]=function(initialValue)
            currentHookNameInDev="useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef(initialValue)
        end,["useBinding"]=function(initialValue)
            currentHookNameInDev="useBinding";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateBinding(initialValue)
        end,["useState"]=function(initialState)
            currentHookNameInDev="useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            local prevDispatcher=ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
            local ok,result,setResult=pcall(rerenderState,initialState);
            ReactCurrentDispatcher.current=prevDispatcher;
            if not(ok)then
                 error(result)
            end;
            return result,setResult
         end,["useDebugValue"]=function(value,formatterFn)
            currentHookNameInDev="useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue(value,formatterFn)
        end,["useMutableSource"]=function(source,getSnapshot,subscribe)
            currentHookNameInDev="useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source,getSnapshot,subscribe)
        end,["useOpaqueIdentifier"]=function()
            currentHookNameInDev="useOpaqueIdentifier";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOpaqueIdentifier()
        end,["unstable_isNewReconciler"]=enableNewReconciler}
    end;
    local function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes)
        renderLanes=nextRenderLanes;
        currentlyRenderingFiber=workInProgress;
        if __DEV__ then
             hookTypesDev=if(current)~=(nil)then(current._debugHookTypes)else nil;
            hookTypesUpdateIndexDev=0
         end;
        workInProgress.memoizedState=nil;
        workInProgress.updateQueue=nil;
        workInProgress.lanes=NoLanes;
        if __DEV__ then
             if((current)~=(nil))and((current.memoizedState)~=(nil))then
                 ReactCurrentDispatcher.current=HooksDispatcherOnUpdateInDEV
             elseif(hookTypesDev)~=(nil)then
                 ReactCurrentDispatcher.current=HooksDispatcherOnMountWithHookTypesInDEV
             else
                 ReactCurrentDispatcher.current=HooksDispatcherOnMountInDEV
             end
         else
             ReactCurrentDispatcher.current=(((((current)==(nil))or((current.memoizedState)==(nil))))and(HooksDispatcherOnMount))or(HooksDispatcherOnUpdate)
        end;
        local children=Component(props,secondArg);
        if didScheduleRenderPhaseUpdateDuringThisPass then
             local numberOfReRenders=0;
            repeat
                 didScheduleRenderPhaseUpdateDuringThisPass=false;
                if(numberOfReRenders)>=(RE_RENDER_LIMIT)then
                     error(Error.new("Too many re-renders. React limits the number of renders to prevent an infinite loop."))
                end;
                numberOfReRenders+=1;
                currentHook=nil;
                workInProgressHook=nil;
                workInProgress.updateQueue=nil;
                if __DEV__ then
                     hookTypesUpdateIndexDev=0
                 end;
                ReactCurrentDispatcher.current=((__DEV__)and(HooksDispatcherOnRerenderInDEV))or(HooksDispatcherOnRerender);
                children=Component(props,secondArg)
            until not(didScheduleRenderPhaseUpdateDuringThisPass)
        end;
        ReactCurrentDispatcher.current=ContextOnlyDispatcher;
        if __DEV__ then
             workInProgress._debugHookTypes=hookTypesDev
         end;
        local didRenderTooFewHooks=((currentHook)~=(nil))and((currentHook.next)~=(nil));
        renderLanes=NoLanes;
        currentlyRenderingFiber=nil;
        currentHook=nil;
        workInProgressHook=nil;
        if __DEV__ then
             currentHookNameInDev=nil;
            hookTypesDev=nil;
            hookTypesUpdateIndexDev=0
         end;
        didScheduleRenderPhaseUpdate=false;
        if didRenderTooFewHooks then
             error(Error.new("Rendered fewer hooks than expected. This may be caused by an accidental early return statement."))
        end;
        return children
     end;
    exports.renderWithHooks=renderWithHooks;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactCapturedValue.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCapturedValue",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local getStackByFiberInDevAndProd=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberComponentStack").getStackByFiberInDevAndProd;
    type("not printable... yet");
    local exports={};
    exports.createCapturedValue=function(value,source)
        return{["value"]=value,["source"]=source,["stack"]=getStackByFiberInDevAndProd(source)}
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactProfilerTimer.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactProfilerTimer.new",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableProfilerTimer=ReactFeatureFlags.enableProfilerTimer;
    local enableProfilerCommitHooks=ReactFeatureFlags.enableProfilerCommitHooks;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local Profiler=ReactWorkTags.Profiler;
    local Scheduler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.scheduler");
    local now=Scheduler.unstable_now;
    type("not printable... yet");
    local commitTime=0;
    local layoutEffectStartTime=-(1);
    local profilerStartTime=-(1);
    local passiveEffectStartTime=-(1);
    function getCommitTime()
        return commitTime
     end;
    function recordCommitTime()
        if not(enableProfilerTimer)then
             return
         end;
        commitTime=now()
    end;
    function startProfilerTimer(fiber)
        if not(enableProfilerTimer)then
             return
         end;
        profilerStartTime=now();
        if((fiber.actualStartTime)~=(nil))and(((fiber.actualStartTime))<(0))then
             fiber.actualStartTime=now()
        end
     end;
    function stopProfilerTimerIfRunning(fiber)
        if not(enableProfilerTimer)then
             return
         end;
        profilerStartTime=-(1)
    end;
    function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime)
        if not(enableProfilerTimer)then
             return
         end;
        if(profilerStartTime)>=(0)then
             local elapsedTime_=(now())-(profilerStartTime);
            fiber.actualDuration+=elapsedTime_;
            if overrideBaseTime then
                 fiber.selfBaseDuration=elapsedTime_
             end;
            profilerStartTime=-(1)
        end
     end;
    function recordLayoutEffectDuration(fiber)
        if(not(enableProfilerTimer))or(not(enableProfilerCommitHooks))then
             return
         end;
        if(layoutEffectStartTime)>=(0)then
             local elapsedTime_=(now())-(layoutEffectStartTime);
            layoutEffectStartTime=-(1);
            local parentFiber=fiber.return_;
            while(parentFiber)~=(nil)do
                 if(parentFiber.tag)==(Profiler)then
                     local parentStateNode=parentFiber.stateNode;
                    parentStateNode.effectDuration+=elapsedTime_;
                    break
                 end;
                parentFiber=parentFiber.return_
             end
         end
     end;
    function recordPassiveEffectDuration(fiber)
        if(not(enableProfilerTimer))or(not(enableProfilerCommitHooks))then
             return
         end;
        if(passiveEffectStartTime)>=(0)then
             local elapsedTime_=(now())-(passiveEffectStartTime);
            passiveEffectStartTime=-(1);
            local parentFiber=fiber.return_;
            while(parentFiber)~=(nil)do
                 if(parentFiber.tag)==(Profiler)then
                     local parentStateNode=parentFiber.stateNode;
                    if(parentStateNode)~=(nil)then
                         parentStateNode.passiveEffectDuration+=elapsedTime_
                     end;
                    break
                 end;
                parentFiber=parentFiber.return_
             end
         end
     end;
    function startLayoutEffectTimer()
        if(not(enableProfilerTimer))or(not(enableProfilerCommitHooks))then
             return
         end;
        layoutEffectStartTime=now()
    end;
    function startPassiveEffectTimer()
        if(not(enableProfilerTimer))or(not(enableProfilerCommitHooks))then
             return
         end;
        passiveEffectStartTime=now()
    end;
    function transferActualDuration(fiber)
        local child=fiber.child;
        while child do
             fiber.actualDuration+=child.actualDuration;
            child=child.sibling
         end
     end;
    return{["getCommitTime"]=getCommitTime,["recordCommitTime"]=recordCommitTime,["recordLayoutEffectDuration"]=recordLayoutEffectDuration,["recordPassiveEffectDuration"]=recordPassiveEffectDuration,["startLayoutEffectTimer"]=startLayoutEffectTimer,["startPassiveEffectTimer"]=startPassiveEffectTimer,["startProfilerTimer"]=startProfilerTimer,["stopProfilerTimerIfRunning"]=stopProfilerTimerIfRunning,["stopProfilerTimerIfRunningAndRecordDelta"]=stopProfilerTimerIfRunningAndRecordDelta,["transferActualDuration"]=transferActualDuration}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactStrictModeWarnings.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactStrictModeWarnings.new",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactCurrentFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCurrentFiber");
    local resetCurrentDebugFiberInDEV=ReactCurrentFiber.resetCurrentFiber;
    local setCurrentDebugFiberInDEV=ReactCurrentFiber.setCurrentFiber;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local StrictMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode").StrictMode;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactStrictModeWarnings={["recordUnsafeLifecycleWarnings"]=function(fiber,instance)
        
    end,["flushPendingUnsafeLifecycleWarnings"]=function()
        
    end,["recordLegacyContextWarning"]=function(fiber,instance)
        
    end,["flushLegacyContextWarning"]=function()
        
    end,["discardPendingWarnings"]=function()
        
    end};
    if _G.__DEV__ then
         local findStrictRoot=function(fiber)
            local maybeStrictRoot;
            local node=fiber;
            while(node)~=(nil)do
                 if(bit32.band(node.mode,StrictMode))~=(0)then
                     maybeStrictRoot=node
                 end;
                node=node.return_
             end;
            return maybeStrictRoot
         end;
        local setToSortedString=function(set)
            local array={};
            for key,value in set do
                 table.insert(array,key)
            end;
            table.sort(array);
            return table.concat(array,", ")
        end;
        local pendingComponentWillMountWarnings={};
        local pendingUNSAFE_ComponentWillMountWarnings={};
        local pendingComponentWillReceivePropsWarnings={};
        local pendingUNSAFE_ComponentWillReceivePropsWarnings={};
        local pendingComponentWillUpdateWarnings={};
        local pendingUNSAFE_ComponentWillUpdateWarnings={};
        local didWarnAboutUnsafeLifecycles={};
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance)
            if didWarnAboutUnsafeLifecycles[fiber.type]then
                 return
             end;
            if(typeof(instance.componentWillMount))==("function")then
                 table.insert(pendingComponentWillMountWarnings,fiber)
            end;
            if((bit32.band(fiber.mode,StrictMode))~=(0))and((typeof(instance.UNSAFE_componentWillMount))==("function"))then
                 table.insert(pendingUNSAFE_ComponentWillMountWarnings,fiber)
            end;
            if(typeof(instance.componentWillReceiveProps))==("function")then
                 table.insert(pendingComponentWillReceivePropsWarnings,fiber)
            end;
            if((bit32.band(fiber.mode,StrictMode))~=(0))and((typeof(instance.UNSAFE_componentWillReceiveProps))==("function"))then
                 table.insert(pendingUNSAFE_ComponentWillReceivePropsWarnings,fiber)
            end;
            if(typeof(instance.componentWillUpdate))==("function")then
                 table.insert(pendingComponentWillUpdateWarnings,fiber)
            end;
            if((bit32.band(fiber.mode,StrictMode))~=(0))and((typeof(instance.UNSAFE_componentWillUpdate))==("function"))then
                 table.insert(pendingUNSAFE_ComponentWillUpdateWarnings,fiber)
            end
         end;
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function()
            local componentWillMountUniqueNames={};
            if(#(pendingComponentWillMountWarnings))>(0)then
                 for i,fiber in pendingComponentWillMountWarnings do
                     componentWillMountUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingComponentWillMountWarnings)
            end;
            local UNSAFE_componentWillMountUniqueNames={};
            if(#(pendingUNSAFE_ComponentWillMountWarnings))>(0)then
                 for i,fiber in pendingUNSAFE_ComponentWillMountWarnings do
                     UNSAFE_componentWillMountUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingUNSAFE_ComponentWillMountWarnings)
            end;
            local componentWillReceivePropsUniqueNames={};
            if(#(pendingComponentWillReceivePropsWarnings))>(0)then
                 for i,fiber in pendingComponentWillReceivePropsWarnings do
                     componentWillReceivePropsUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingComponentWillReceivePropsWarnings)
            end;
            local UNSAFE_componentWillReceivePropsUniqueNames={};
            if(#(pendingUNSAFE_ComponentWillReceivePropsWarnings))>(0)then
                 for i,fiber in pendingUNSAFE_ComponentWillReceivePropsWarnings do
                     UNSAFE_componentWillReceivePropsUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings)
            end;
            local componentWillUpdateUniqueNames={};
            if(#(pendingComponentWillUpdateWarnings))>(0)then
                 for i,fiber in pendingComponentWillUpdateWarnings do
                     componentWillUpdateUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingComponentWillUpdateWarnings)
            end;
            local UNSAFE_componentWillUpdateUniqueNames={};
            if(#(pendingUNSAFE_ComponentWillUpdateWarnings))>(0)then
                 for i,fiber in pendingUNSAFE_ComponentWillUpdateWarnings do
                     UNSAFE_componentWillUpdateUniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutUnsafeLifecycles[fiber.type]=true
                 end;
                table.clear(pendingUNSAFE_ComponentWillUpdateWarnings)
            end;
            if(next(UNSAFE_componentWillMountUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);
                console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move code with side effects to componentDidMount, and set initial state in the constructor.\x0a\x0aPlease update the following components: %s",sortedNames)
            end;
            if(next(UNSAFE_componentWillReceivePropsUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move data fetching code or side effects to componentDidUpdate.\x0a* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\x0a\x0aPlease update the following components: %s",sortedNames)
            end;
            if(next(UNSAFE_componentWillUpdateUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move data fetching code or side effects to componentDidUpdate.\x0a\x0aPlease update the following components: %s",sortedNames)
            end;
            if(next(componentWillMountUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(componentWillMountUniqueNames);
                console.warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move code with side effects to componentDidMount, and set initial state in the constructor.\x0a* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\x0a\x0aPlease update the following components: %s",sortedNames)
            end;
            if(next(componentWillReceivePropsUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(componentWillReceivePropsUniqueNames);
                console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move data fetching code or side effects to componentDidUpdate.\x0a* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\x0a* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\x0a\x0aPlease update the following components: %s",sortedNames)
            end;
            if(next(componentWillUpdateUniqueNames))~=(nil)then
                 local sortedNames=setToSortedString(componentWillUpdateUniqueNames);
                console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\x0a\x0a* Move data fetching code or side effects to componentDidUpdate.\x0a* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\x0a\x0aPlease update the following components: %s",sortedNames)
            end
         end;
        local pendingLegacyContextWarning={};
        local didWarnAboutLegacyContext={};
        ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance)
            local strictRoot=findStrictRoot(fiber);
            if(strictRoot)==(nil)then
                 console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return
             end;
            if didWarnAboutLegacyContext[fiber.type]then
                 return
             end;
            local warningsForRoot=pendingLegacyContextWarning[strictRoot];
            if((typeof(fiber.type))~=("function"))and(((((fiber.type.contextTypes)~=(nil))or((fiber.type.childContextTypes)~=(nil)))or((((instance)~=(nil))and((typeof(instance.getChildContext))==("function"))))))then
                 if(warningsForRoot)==(nil)then
                     warningsForRoot={};
                    pendingLegacyContextWarning[strictRoot]=warningsForRoot
                 end;
                table.insert(warningsForRoot,fiber)
            end
         end;
        ReactStrictModeWarnings.flushLegacyContextWarning=function()
            for strictRoot,fiberArray in pendingLegacyContextWarning do
                 if(#(fiberArray))==(0)then
                     return
                 end;
                local firstFiber=fiberArray[1];
                local uniqueNames={};
                for i,fiber in fiberArray do
                     uniqueNames[(getComponentName(fiber.type))or("Component")]=true;
                    didWarnAboutLegacyContext[fiber.type]=true
                 end;
                local sortedNames=setToSortedString(uniqueNames);
                local ok,error_=pcall(function()
                    setCurrentDebugFiberInDEV(firstFiber);
                    console.error("Legacy context API has been detected within a strict-mode tree.\x0a\x0aThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\x0a\x0aPlease update the following components: %s\x0a\x0aLearn more about this warning here: https://reactjs.org/link/legacy-context",sortedNames)
                end);
                resetCurrentDebugFiberInDEV();
                if not(ok)then
                     error(error_)
                end
             end
         end;
        ReactStrictModeWarnings.discardPendingWarnings=function()
            table.clear(pendingComponentWillMountWarnings);
            table.clear(pendingUNSAFE_ComponentWillMountWarnings);
            table.clear(pendingComponentWillReceivePropsWarnings);
            table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings);
            table.clear(pendingComponentWillUpdateWarnings);
            table.clear(pendingUNSAFE_ComponentWillUpdateWarnings);
            table.clear(pendingLegacyContextWarning)
        end
     end;
    return ReactStrictModeWarnings

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactTestSelectors.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTestSelectors",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    local supportsTestSelectors=ReactFiberHostConfig.supportsTestSelectors;
    local exports={};
    type("not printable... yet");
    local commitHooks={};
    exports.onCommitRoot=function()
        if supportsTestSelectors then
             for i,commitHook in commitHooks do
                 commitHook()
            end
         end
     end;
    type("not printable... yet");
    type("not printable... yet");
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberWorkInProgress.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkInProgress",function()
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    local _workInProgressRootSkippedLanes=ReactFiberLane.NoLanes;
    local mergeLanes=ReactFiberLane.mergeLanes;
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    exports.workInProgressRootSkippedLanes=function(value)
        if(value)==(nil)then
             return _workInProgressRootSkippedLanes
         end;
        _workInProgressRootSkippedLanes=value;
        return _workInProgressRootSkippedLanes
     end;
    exports.markSkippedUpdateLanes=function(lane)
        _workInProgressRootSkippedLanes=mergeLanes(lane,_workInProgressRootSkippedLanes)
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberComponentStack.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberComponentStack",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local HostComponent=ReactWorkTags.HostComponent;
    local LazyComponent=ReactWorkTags.LazyComponent;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local SuspenseListComponent=ReactWorkTags.SuspenseListComponent;
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local IndeterminateComponent=ReactWorkTags.IndeterminateComponent;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local ReactComponentStackFrame=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactComponentStackFrame;
    local describeBuiltInComponentFrame=ReactComponentStackFrame.describeBuiltInComponentFrame;
    local describeFunctionComponentFrame=ReactComponentStackFrame.describeFunctionComponentFrame;
    local describeClassComponentFrame=ReactComponentStackFrame.describeClassComponentFrame;
    local function describeFiber(fiber)
        local owner;
        if _G.__DEV__ then
             local debugOwner=fiber._debugOwner;
            if debugOwner then
                 owner=debugOwner.type
             end
         end;
        local source;
        if _G.__DEV__ then
             source=fiber._debugSource
         end;
        if(fiber.tag)==(HostComponent)then
             return describeBuiltInComponentFrame(fiber.type,source,owner)
        elseif(fiber.tag)==(LazyComponent)then
             return describeBuiltInComponentFrame("Lazy",source,owner)
        elseif(fiber.tag)==(SuspenseComponent)then
             return describeBuiltInComponentFrame("Suspense",source,owner)
        elseif(fiber.tag)==(SuspenseListComponent)then
             return describeBuiltInComponentFrame("SuspenseList",source,owner)
        elseif(((fiber.tag)==(FunctionComponent))or((fiber.tag)==(IndeterminateComponent)))or((fiber.tag)==(SimpleMemoComponent))then
             return describeFunctionComponentFrame(fiber.type,source,owner)
        elseif(fiber.tag)==(ForwardRef)then
             return describeFunctionComponentFrame(fiber.type.render,source,owner)
        elseif(fiber.tag)==(ClassComponent)then
             return describeClassComponentFrame(fiber.type,source,owner)
        else
             return""
        end
     end;
    return{["getStackByFiberInDevAndProd"]=function(workInProgress)
        local ok,result=pcall(function()
            local info="";
            local node=workInProgress;
            repeat
                 info..=describeFiber(node);
                node=(node).return_
             until(node)==(nil);
            return info
         end);
        if not(ok)then
             local message="\x0aError generating stack: ";
            if(((typeof(result))==("table"))and((result).message))and((result).stack)then
                 return(message)..(((result).message)..(("\x0a")..(tostring((result).stack))))
            end;
            return(message)..(tostring(result))
        end;
        return result
     end}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\shared.lua
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared",function()
    return tkpack.include("game.Packages._Index.jsdotlua_shared@17.2.1.shared")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\SchedulerFeatureFlags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerFeatureFlags",function()
    return{["enableSchedulerDebugging"]=false,["enableIsInputPending"]=false,["enableProfiling"]=_G.__PROFILE__}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\SchedulerHostConfig.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerHostConfig",function()
    return tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.forks.SchedulerHostConfig.default")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\SchedulerPriorities.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerPriorities",function()
    type("not printable... yet");
    return{["NoPriority"]=0,["ImmediatePriority"]=1,["UserBlockingPriority"]=2,["NormalPriority"]=3,["LowPriority"]=4,["IdlePriority"]=5}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\SchedulerProfiling.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerProfiling",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").console;
    local exports={};
    local SchedulerPriorities=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerPriorities");
    type("not printable... yet");
    local ScheduleFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.SchedulerFeatureFlags");
    local enableProfiling=ScheduleFeatureFlags.enableProfiling;
    local runIdCounter=0;
    local mainThreadIdCounter=0;
    local INITIAL_EVENT_LOG_SIZE=131072;
    local MAX_EVENT_LOG_SIZE=524288;
    type("not printable... yet");
    local eventLogSize=0;
    local eventLogBuffer;
    local eventLog;
    local eventLogIndex=1;
    local TaskStartEvent=1;
    local TaskCompleteEvent=2;
    local TaskErrorEvent=3;
    local TaskCancelEvent=4;
    local TaskRunEvent=5;
    local TaskYieldEvent=6;
    local SchedulerSuspendEvent=7;
    local SchedulerResumeEvent=8;
    local function logEvent(entries)
        if(eventLog)~=(nil)then
             eventLogIndex+=#(entries);
            if((eventLogIndex)+(1))>(eventLogSize)then
                 eventLogSize*=2;
                if(eventLogSize)>(MAX_EVENT_LOG_SIZE)then
                     console["error"]("Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`.");
                    exports.stopLoggingProfilingEvents();
                    return
                 end;
                local newEventLog={};
                table.insert(newEventLog,eventLog);
                eventLogBuffer=newEventLog;
                eventLog=newEventLog
             end;
            table.insert(eventLog,entries)
        end
     end;
    exports.startLoggingProfilingEvents=function()
        eventLogSize=INITIAL_EVENT_LOG_SIZE;
        eventLogBuffer={};
        eventLog=eventLogBuffer;
        eventLogIndex=1
     end;
    exports.stopLoggingProfilingEvents=function()
        local buffer=eventLogBuffer;
        eventLogSize=0;
        eventLogBuffer=nil;
        eventLog=nil;
        eventLogIndex=1;
        return buffer
     end;
    exports.markTaskStart=function(task,ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({TaskStartEvent,(ms)*(1000),task.id,task.priorityLevel})
            end
         end
     end;
    exports.markTaskCompleted=function(task,ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({TaskCompleteEvent,(ms)*(1000),task.id})
            end
         end
     end;
    exports.markTaskCanceled=function(task,ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({TaskCancelEvent,(ms)*(1000),task.id})
            end
         end
     end;
    exports.markTaskErrored=function(task,ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({TaskErrorEvent,(ms)*(1000),task.id})
            end
         end
     end;
    exports.markTaskRun=function(task,ms)
        if enableProfiling then
             runIdCounter+=1;
            if(eventLog)~=(nil)then
                 logEvent({TaskRunEvent,(ms)*(1000),task.id,runIdCounter})
            end
         end
     end;
    exports.markTaskYield=function(task,ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({TaskYieldEvent,(ms)*(1000),task.id,runIdCounter})
            end
         end
     end;
    exports.markSchedulerSuspended=function(ms)
        if enableProfiling then
             mainThreadIdCounter+=1;
            if(eventLog)~=(nil)then
                 logEvent({SchedulerSuspendEvent,(ms)*(1000),mainThreadIdCounter})
            end
         end
     end;
    exports.markSchedulerUnsuspended=function(ms)
        if enableProfiling then
             if(eventLog)~=(nil)then
                 logEvent({SchedulerResumeEvent,(ms)*(1000),mainThreadIdCounter})
            end
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\luau-polyfill.lua
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.luau-polyfill",function()
    return tkpack.include("game.Packages._Index.jsdotlua_luau-polyfill@1.2.7.luau-polyfill")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\forks\SchedulerHostConfig.mock.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.forks.SchedulerHostConfig.mock",function()
    local exports={};
    local currentTime=0;
    local scheduledCallback;
    local scheduledTimeout;
    local timeoutTime=-(1);
    local yieldedValues;
    local expectedNumberOfYields=-(1);
    local didStop=false;
    local isFlushing=false;
    local needsPaint=false;
    local shouldYieldForPaint=false;
    local console=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").console;
    local ConsolePatchingDev=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared").ConsolePatchingDev;
    local disabledLog=ConsolePatchingDev.disabledLog;
    exports.requestHostCallback=function(callback)
        scheduledCallback=callback
     end;
    exports.cancelHostCallback=function()
        scheduledCallback=nil
     end;
    exports.requestHostTimeout=function(callback,ms)
        scheduledTimeout=callback;
        timeoutTime=(currentTime)+(ms)
    end;
    exports.cancelHostTimeout=function()
        scheduledTimeout=nil;
        timeoutTime=-(1)
    end;
    exports.shouldYieldToHost=function()
        local values=yieldedValues;
        if(((((expectedNumberOfYields)~=(-(1)))and((values)~=(nil)))and((#(values))>=(expectedNumberOfYields))))or(((shouldYieldForPaint)and(needsPaint)))then
             didStop=true;
            return true
         end;
        return false
     end;
    exports.getCurrentTime=function()
        return currentTime
     end;
    exports.forceFrameRate=function()
        
    end;
    exports.reset=function()
        if isFlushing then
             error("Cannot reset while already flushing work.")
        end;
        currentTime=0;
        scheduledCallback=nil;
        scheduledTimeout=nil;
        timeoutTime=-(1);
        yieldedValues=nil;
        expectedNumberOfYields=-(1);
        didStop=false;
        isFlushing=false;
        needsPaint=false
     end;
    exports.unstable_flushNumberOfYields=function(count)
        if isFlushing then
             error("Already flushing work.")
        end;
        if(scheduledCallback)~=(nil)then
             local cb=scheduledCallback;
            expectedNumberOfYields=count;
            isFlushing=true;
            local ok,result=pcall(function()
                local hasMoreWork=true;
                repeat
                     hasMoreWork=cb(true,currentTime)
                until(not(hasMoreWork))or(didStop);
                if not(hasMoreWork)then
                     scheduledCallback=nil
                 end
             end);
            expectedNumberOfYields=-(1);
            didStop=false;
            isFlushing=false;
            if not(ok)then
                 error(result)
            end
         end
     end;
    exports.unstable_flushUntilNextPaint=function()
        if isFlushing then
             error("Already flushing work.")
        end;
        if(scheduledCallback)~=(nil)then
             local cb=scheduledCallback;
            shouldYieldForPaint=true;
            needsPaint=false;
            isFlushing=true;
            local ok,result=pcall(function()
                local hasMoreWork=true;
                repeat
                     hasMoreWork=cb(true,currentTime)
                until(not(hasMoreWork))or(didStop);
                if not(hasMoreWork)then
                     scheduledCallback=nil
                 end
             end);
            shouldYieldForPaint=false;
            didStop=false;
            isFlushing=false;
            if not(ok)then
                 error(result)
            end
         end
     end;
    exports.unstable_flushExpired=function()
        if isFlushing then
             error("Already flushing work.")
        end;
        if(scheduledCallback)~=(nil)then
             isFlushing=true;
            local ok,result=pcall(function()
                local callback=scheduledCallback;
                local hasMoreWork=callback(false,currentTime);
                if not(hasMoreWork)then
                     scheduledCallback=nil
                 end
             end);
            isFlushing=false;
            if not(ok)then
                 error(result)
            end
         end
     end;
    exports.unstable_flushAllWithoutAsserting=function()
        if isFlushing then
             error("Already flushing work.")
        end;
        if(scheduledCallback)~=(nil)then
             local cb=scheduledCallback;
            isFlushing=true;
            local ok,result=pcall(function()
                local hasMoreWork=true;
                repeat
                     hasMoreWork=cb(true,currentTime)
                until not(hasMoreWork);
                if not(hasMoreWork)then
                     scheduledCallback=nil
                 end
             end);
            isFlushing=false;
            if not(ok)then
                 error(result)
            end;
            return true
         else
             return false
         end
     end;
    exports.unstable_clearYields=function()
        if(yieldedValues)==(nil)then
             return{}
        end;
        local values=yieldedValues;
        yieldedValues=nil;
        return values
     end;
    exports.unstable_flushAll=function()
        if(yieldedValues)~=(nil)then
             error("Log is not empty. Assert on the log of yielded values before flushing additional work.")
        end;
        exports.unstable_flushAllWithoutAsserting();
        if(yieldedValues)~=(nil)then
             error("While flushing work, something yielded a value. Use an assertion helper to assert on the log of yielded values, e.g. expect(Scheduler).toFlushAndYield([...])")
        end
     end;
    exports.unstable_yieldValue=function(value)
        if(console.log)==(disabledLog)then
             return
         end;
        if(yieldedValues)==(nil)then
             yieldedValues={value}
        else
             local values=yieldedValues;
            table.insert(values,value)
        end
     end;
    exports.unstable_advanceTime=function(ms)
        if(console.log)==(disabledLog)then
             return
         end;
        currentTime+=ms;
        if((scheduledTimeout)~=(nil))and((timeoutTime)<=(currentTime))then
             local timeout=scheduledTimeout;
            timeout(currentTime);
            timeoutTime=-(1);
            scheduledTimeout=nil
         end
     end;
    exports.requestPaint=function()
        needsPaint=true
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberOffscreenComponent.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberOffscreenComponent",function()
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local ReactFiberLanes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    return{}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberHotReloading.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHotReloading.new",function()
    local ReactElementType=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols;
    local REACT_FORWARD_REF_TYPE=ReactSymbols.REACT_FORWARD_REF_TYPE;
    type("not printable... yet");
    type("not printable... yet");
    local resolveFamily;
    local failedBoundaries;
    local exports={};
    local function resolveFunctionForHotReloading(type)
        if _G.__DEV__ then
             if(resolveFamily)==(nil)then
                 return type
             end;
            local family=resolveFamily(type);
            if(family)==(nil)then
                 return type
             end;
            return family.current
         else
             return type
         end
     end;
    exports.resolveFunctionForHotReloading=resolveFunctionForHotReloading;
    local function resolveClassForHotReloading(type)
        return resolveFunctionForHotReloading(type)
    end;
    exports.resolveClassForHotReloading=resolveClassForHotReloading;
    local function resolveForwardRefForHotReloading(type)
        if _G.__DEV__ then
             if(resolveFamily)==(nil)then
                 return type
             end;
            local family=resolveFamily(type);
            if(family)==(nil)then
                 if((type)~=(nil))and((typeof(type.render))==("function"))then
                     local currentRender=resolveFunctionForHotReloading(type.render);
                    if(type.render)~=(currentRender)then
                         local syntheticType={["\x24\x24typeof"]=REACT_FORWARD_REF_TYPE,["render"]=currentRender,["displayName"]=nil};
                        if(type.displayName)~=(nil)then
                             syntheticType.displayName=type.displayName
                         end;
                        return syntheticType
                     end
                 end;
                return type
             end;
            return family.current
         else
             return type
         end
     end;
    exports.resolveForwardRefForHotReloading=resolveForwardRefForHotReloading;
    exports.isCompatibleFamilyForHotReloading=function(fiber,element)
        warn("isCompatibleFamilyForHotReloading is stubbed (returns false)");
        return false
     end;
    exports.markFailedErrorBoundaryForHotReloading=function(fiber)
        if _G.__DEV__ then
             if(resolveFamily)==(nil)then
                 return
             end;
            if(failedBoundaries)==(nil)then
                 failedBoundaries={}
            end;
            table.insert(failedBoundaries,fiber)
        end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactMutableSource.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactMutableSource.new",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    type("not printable... yet");
    local exports={};
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local isPrimaryRenderer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig").isPrimaryRenderer;
    local workInProgressSources={};
    local rendererSigil;
    if _G.__DEV__ then
         rendererSigil={}
    end;
    exports.markSourceAsDirty=function(mutableSource)
        table.insert(workInProgressSources,mutableSource)
    end;
    exports.resetWorkInProgressVersions=function()
        for i,mutableSource in workInProgressSources do
             if isPrimaryRenderer then
                 mutableSource._workInProgressVersionPrimary=nil
             else
                 mutableSource._workInProgressVersionSecondary=nil
             end
         end;
        table.clear(workInProgressSources)
    end;
    exports.getWorkInProgressVersion=function(mutableSource)
        if isPrimaryRenderer then
             return mutableSource._workInProgressVersionPrimary
         else
             return mutableSource._workInProgressVersionSecondary
         end
     end;
    exports.setWorkInProgressVersion=function(mutableSource,version_)
        if isPrimaryRenderer then
             mutableSource._workInProgressVersionPrimary=version_
         else
             mutableSource._workInProgressVersionSecondary=version_
         end;
        table.insert(workInProgressSources,mutableSource)
    end;
    exports.warnAboutMultipleRenderersDEV=function(mutableSource)
        if _G.__DEV__ then
             if isPrimaryRenderer then
                 if(mutableSource._currentPrimaryRenderer)==(nil)then
                     mutableSource._currentPrimaryRenderer=rendererSigil
                 elseif(mutableSource._currentPrimaryRenderer)~=(rendererSigil)then
                     console.error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.")
                end
             else
                 if(mutableSource._currentSecondaryRenderer)==(nil)then
                     mutableSource._currentSecondaryRenderer=rendererSigil
                 elseif(mutableSource._currentSecondaryRenderer)~=(rendererSigil)then
                     console.error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.")
                end
             end
         end
     end;
    exports.registerMutableSourceForHydration=function(root,mutableSource)
        local getVersion=mutableSource._getVersion;
        local version_=getVersion(mutableSource._source);
        if(root.mutableSourceEagerHydrationData)==(nil)then
             root.mutableSourceEagerHydrationData={mutableSource,version_}
        end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberHostContext.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostContext.new",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    local getChildHostContext=ReactFiberHostConfig.getChildHostContext;
    local getRootHostContext=ReactFiberHostConfig.getRootHostContext;
    local createCursor=ReactFiberStack.createCursor;
    local push=ReactFiberStack.push;
    local pop=ReactFiberStack.pop;
    type("not printable... yet");
    local NO_CONTEXT={};
    local contextStackCursor=createCursor(NO_CONTEXT);
    local contextFiberStackCursor=createCursor(NO_CONTEXT);
    local rootInstanceStackCursor=createCursor(NO_CONTEXT);
    function requiredContext(c)
        return c
     end;
    function getRootHostContainer()
        return rootInstanceStackCursor.current
     end;
    function pushHostContainer(fiber,nextRootInstance)
        push(rootInstanceStackCursor,nextRootInstance,fiber);
        push(contextFiberStackCursor,fiber,fiber);
        push(contextStackCursor,NO_CONTEXT,fiber);
        local nextRootContext=getRootHostContext(nextRootInstance);
        pop(contextStackCursor,fiber);
        push(contextStackCursor,nextRootContext,fiber)
    end;
    function popHostContainer(fiber)
        pop(contextStackCursor,fiber);
        pop(contextFiberStackCursor,fiber);
        pop(rootInstanceStackCursor,fiber)
    end;
    function getHostContext()
        return contextStackCursor.current
     end;
    function pushHostContext(fiber)
        local rootInstance=requiredContext(rootInstanceStackCursor.current);
        local context=requiredContext(contextStackCursor.current);
        local nextContext=getChildHostContext(context,fiber.type,rootInstance);
        if(context)==(nextContext)then
             return
         end;
        push(contextFiberStackCursor,fiber,fiber);
        push(contextStackCursor,nextContext,fiber)
    end;
    function popHostContext(fiber)
        if(contextFiberStackCursor.current)~=(fiber)then
             return
         end;
        pop(contextStackCursor,fiber);
        pop(contextFiberStackCursor,fiber)
    end;
    return{["getHostContext"]=getHostContext,["getRootHostContainer"]=getRootHostContainer,["popHostContainer"]=popHostContainer,["popHostContext"]=popHostContext,["pushHostContainer"]=pushHostContainer,["pushHostContext"]=pushHostContext}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberSuspenseContext.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseContext.new",function()
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberStack=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberStack.new");
    type("not printable... yet");
    local createCursor=ReactFiberStack.createCursor;
    local push=ReactFiberStack.push;
    local pop=ReactFiberStack.pop;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local exports={};
    local DefaultSuspenseContext=0;
    local SubtreeSuspenseContextMask=1;
    local InvisibleParentSuspenseContext=1;
    exports.InvisibleParentSuspenseContext=InvisibleParentSuspenseContext;
    local ForceSuspenseFallback=2;
    exports.ForceSuspenseFallback=ForceSuspenseFallback;
    local suspenseStackCursor=createCursor(DefaultSuspenseContext);
    exports.suspenseStackCursor=suspenseStackCursor;
    function exports.hasSuspenseContext(parentContext,flag)
        return(bit32.band(parentContext,flag))~=(0)
    end;
    function exports.setDefaultShallowSuspenseContext(parentContext)
        return bit32.band(parentContext,SubtreeSuspenseContextMask)
    end;
    function exports.setShallowSuspenseContext(parentContext,shallowContext)
        return bit32.bor(bit32.band(parentContext,SubtreeSuspenseContextMask),shallowContext)
    end;
    function exports.addSubtreeSuspenseContext(parentContext,subtreeContext)
        return bit32.bor(parentContext,subtreeContext)
    end;
    function exports.pushSuspenseContext(fiber,newContext)
        push(suspenseStackCursor,newContext,fiber)
    end;
    function exports.popSuspenseContext(fiber)
        pop(suspenseStackCursor,fiber)
    end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberHydrationContext.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHydrationContext.new",function()
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local function unimplemented(message)
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        print(("UNIMPLEMENTED ERROR: ")..(message));
        error(("FIXME (roblox): ")..((message)..(" is unimplemented")),2)
    end;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberHostConfig=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberHostConfig");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberSuspenseComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberSuspenseComponent.new");
    type("not printable... yet");
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local HostComponent=ReactWorkTags.HostComponent;
    local HostText=ReactWorkTags.HostText;
    local HostRoot=ReactWorkTags.HostRoot;
    local SuspenseComponent=ReactWorkTags.SuspenseComponent;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local Placement=ReactFiberFlags.Placement;
    local Hydrating=ReactFiberFlags.Hydrating;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local ReactFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new");
    local createFiberFromDehydratedFragment=ReactFiber.createFiberFromDehydratedFragment;
    local supportsHydration=ReactFiberHostConfig.supportsHydration;
    local getNextHydratableSibling=ReactFiberHostConfig.getNextHydratableSibling;
    local getFirstHydratableChild=ReactFiberHostConfig.getFirstHydratableChild;
    local canHydrateInstance=ReactFiberHostConfig.canHydrateInstance;
    local canHydrateTextInstance=ReactFiberHostConfig.canHydrateTextInstance;
    local canHydrateSuspenseInstance=ReactFiberHostConfig.canHydrateSuspenseInstance;
    local hydrateInstance=ReactFiberHostConfig.hydrateInstance;
    local hydrateTextInstance=ReactFiberHostConfig.hydrateTextInstance;
    local hydrateSuspenseInstance=ReactFiberHostConfig.hydrateSuspenseInstance;
    local getNextHydratableInstanceAfterSuspenseInstance=ReactFiberHostConfig.getNextHydratableInstanceAfterSuspenseInstance;
    local didNotMatchHydratedContainerTextInstance=ReactFiberHostConfig.didNotMatchHydratedContainerTextInstance;
    local didNotMatchHydratedTextInstance=ReactFiberHostConfig.didNotMatchHydratedTextInstance;
    local shouldSetTextContent=ReactFiberHostConfig.shouldSetTextContent;
    local enableSuspenseServerRenderer=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags.enableSuspenseServerRenderer;
    local OffscreenLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane").OffscreenLane;
    local hydrationParentFiber;
    local nextHydratableInstance;
    local isHydrating=false;
    function warnIfHydrating()
        if _G.__DEV__ then
             if isHydrating then
                 console.error("We should not be hydrating here. This is a bug in React. Please file a bug.")
            end
         end
     end;
    function enterHydrationState(fiber)
        if not(supportsHydration)then
             return false
         end;
        local parentInstance=fiber.stateNode.containerInfo;
        nextHydratableInstance=getFirstHydratableChild(parentInstance);
        hydrationParentFiber=fiber;
        isHydrating=true;
        return true
     end;
    function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance)
        if not(supportsHydration)then
             return false
         end;
        nextHydratableInstance=getNextHydratableSibling(suspenseInstance);
        popToNextHostParent(fiber);
        isHydrating=true;
        return true
     end;
    function deleteHydratableInstance(returnFiber,instance)
        unimplemented("deleteHydratableInstance")
    end;
    function insertNonHydratedInstance(returnFiber,fiber)
        unimplemented("insertNonHydratedInstance");
        fiber.flags=bit32.bor(bit32.band(fiber.flags,bit32.bnot(Hydrating)),Placement);
        if _G.__DEV__ then
            
         end
     end;
    function tryHydrate(fiber,nextInstance)
        if(fiber.tag)==(HostComponent)then
             local type_=fiber.type;
            local props=fiber.pendingProps;
            local instance=canHydrateInstance(nextInstance,type_,props);
            if(instance)~=(nil)then
                 fiber.stateNode=instance;
                return true
             end;
            return false
         elseif(fiber.tag)==(HostText)then
             local text=fiber.pendingProps;
            local textInstance=canHydrateTextInstance(nextInstance,text);
            if(textInstance)~=(nil)then
                 fiber.stateNode=textInstance;
                return true
             end;
            return false
         elseif(fiber.tag)==(SuspenseComponent)then
             if enableSuspenseServerRenderer then
                 local suspenseInstance=canHydrateSuspenseInstance(nextInstance);
                if(suspenseInstance)~=(nil)then
                     local suspenseState={["dehydrated"]=suspenseInstance,["retryLane"]=OffscreenLane};
                    fiber.memoizedState=suspenseState;
                    local dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);
                    dehydratedFragment.return_=fiber;
                    fiber.child=dehydratedFragment;
                    return true
                 end
             end;
            return false
         else
             return false
         end
     end;
    function tryToClaimNextHydratableInstance(fiber)
        if not(isHydrating)then
             return
         end;
        local nextInstance=nextHydratableInstance;
        if not(nextInstance)then
             insertNonHydratedInstance(hydrationParentFiber,fiber);
            isHydrating=false;
            hydrationParentFiber=fiber;
            return
         end;
        local firstAttemptedInstance=nextInstance;
        if not(tryHydrate(fiber,nextInstance))then
             nextInstance=getNextHydratableSibling(firstAttemptedInstance);
            if(not(nextInstance))or(not(tryHydrate(fiber,nextInstance)))then
                 insertNonHydratedInstance(hydrationParentFiber,fiber);
                isHydrating=false;
                hydrationParentFiber=fiber;
                return
             end;
            deleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance)
        end;
        hydrationParentFiber=fiber;
        nextHydratableInstance=getFirstHydratableChild(nextInstance)
    end;
    function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext)
        if not(supportsHydration)then
             invariant(false,"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.")
        end;
        local instance=fiber.stateNode;
        local updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);
        fiber.updateQueue=updatePayload;
        if(updatePayload)~=(nil)then
             return true
         end;
        return false
     end;
    function prepareToHydrateHostTextInstance(fiber)
        if not(supportsHydration)then
             invariant(false,"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.")
        end;
        local textInstance=fiber.stateNode;
        local textContent=fiber.memoizedProps;
        local shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);
        if _G.__DEV__ then
             if shouldUpdate then
                 local returnFiber=hydrationParentFiber;
                if(returnFiber)~=(nil)then
                     if(returnFiber.tag)==(HostRoot)then
                         local parentContainer=returnFiber.stateNode.containerInfo;
                        didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent)
                    elseif(returnFiber.tag)==(HostComponent)then
                         local parentType=returnFiber.type;
                        local parentProps=returnFiber.memoizedProps;
                        local parentInstance=returnFiber.stateNode;
                        didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent)
                    end
                 end
             end
         end;
        return shouldUpdate
     end;
    function prepareToHydrateHostSuspenseInstance(fiber)
        if not(supportsHydration)then
             invariant(false,"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.")
        end;
        local suspenseState=fiber.memoizedState;
        local suspenseInstance;
        if(suspenseState)~=(nil)then
             suspenseInstance=suspenseState.dehydrated
         else
             suspenseInstance=nil
         end;
        invariant(suspenseInstance,"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        hydrateSuspenseInstance(suspenseInstance,fiber)
    end;
    function skipPastDehydratedSuspenseInstance(fiber)
        if not(supportsHydration)then
             invariant(false,"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.")
        end;
        local suspenseState=fiber.memoizedState;
        local suspenseInstance;
        if(suspenseState)~=(nil)then
             suspenseInstance=suspenseState.dehydrated
         else
             suspenseInstance=nil
         end;
        invariant(suspenseInstance,"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)
    end;
    function popToNextHostParent(fiber)
        local parent=fiber.return_;
        while((((parent)~=(nil))and((parent.tag)~=(HostComponent)))and((parent.tag)~=(HostRoot)))and((parent.tag)~=(SuspenseComponent))do
             parent=parent.return_
         end;
        hydrationParentFiber=parent
     end;
    function popHydrationState(fiber)
        if not(supportsHydration)then
             return false
         end;
        if(fiber)~=(hydrationParentFiber)then
             return false
         end;
        if not(isHydrating)then
             popToNextHostParent(fiber);
            isHydrating=true;
            return false
         end;
        local type_=fiber.type;
        if((fiber.tag)~=(HostComponent))or(((((type_)~=("head"))and((type_)~=("body")))and(not(shouldSetTextContent(type_,fiber.memoizedProps)))))then
             local nextInstance=nextHydratableInstance;
            while nextInstance do
                 deleteHydratableInstance(fiber,nextInstance);
                nextInstance=getNextHydratableSibling(nextInstance)
            end
         end;
        popToNextHostParent(fiber);
        if(fiber.tag)==(SuspenseComponent)then
             nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber)
        else
             if hydrationParentFiber then
                 nextHydratableInstance=getNextHydratableSibling(fiber.stateNode)
            else
                 nextHydratableInstance=nil
             end
         end;
        return true
     end;
    function resetHydrationState()
        if not(supportsHydration)then
             return
         end;
        hydrationParentFiber=nil;
        nextHydratableInstance=nil;
        isHydrating=false
     end;
    function getIsHydrating()
        return isHydrating
     end;
    return{["warnIfHydrating"]=warnIfHydrating,["enterHydrationState"]=enterHydrationState,["getIsHydrating"]=getIsHydrating,["reenterHydrationStateFromDehydratedSuspenseInstance"]=reenterHydrationStateFromDehydratedSuspenseInstance,["resetHydrationState"]=resetHydrationState,["tryToClaimNextHydratableInstance"]=tryToClaimNextHydratableInstance,["prepareToHydrateHostInstance"]=prepareToHydrateHostInstance,["prepareToHydrateHostTextInstance"]=prepareToHydrateHostTextInstance,["prepareToHydrateHostSuspenseInstance"]=prepareToHydrateHostSuspenseInstance,["popHydrationState"]=popHydrationState}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberErrorLogger.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberErrorLogger",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    type("not printable... yet");
    local inspect=LuauPolyfill.util.inspect;
    local setTimeout=LuauPolyfill.setTimeout;
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    local console=Shared.console;
    local errorToString=Shared.errorToString;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactCapturedValue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactCapturedValue");
    type("not printable... yet");
    local showErrorDialog=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberErrorDialog").showErrorDialog;
    local ClassComponent=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags").ClassComponent;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local exports={};
    exports.logCapturedError=function(boundary,errorInfo)
        local ok,e=pcall(function()
            local logError=showErrorDialog(boundary,errorInfo);
            if(logError)==(false)then
                 return nil
             end;
            local error_=errorInfo.value;
            if _G.__DEV__ then
                 local source=errorInfo.source;
                local stack=errorInfo.stack;
                local componentStack=(stack)or("");
                if((error_)~=(nil))and(error_._suppressLogging)then
                     if(boundary.tag)==(ClassComponent)then
                         return
                     end;
                    console["error"](error_)
                end;
                local componentName;
                if(source)~=(nil)then
                     componentName=getComponentName(source.type)
                else
                     componentName=nil
                 end;
                local componentNameMessage;
                if componentName then
                     componentNameMessage=("The above error occurred in the <")..((tostring(componentName))..("> component:"))
                else
                     componentNameMessage="The above error occurred in one of your React components:"
                end;
                local errorBoundaryMessage;
                local errorBoundaryName=getComponentName(boundary.type);
                if errorBoundaryName then
                     errorBoundaryMessage=("React will try to recreate this component tree from scratch ")..(("using the error boundary you provided, ")..((errorBoundaryName)..(".")))
                else
                     errorBoundaryMessage="Consider adding an error boundary to your tree to customize error handling behavior.\x0aVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries."
                end;
                local combinedMessage=(componentNameMessage)..(("\x0a")..((componentStack)..(("\x0a\x0a")..(errorBoundaryMessage))));
                console["error"](combinedMessage)
            else
                 console["error"](inspect(error_))
            end;
            return nil
         end);
        if not(ok)then
             warn(("failed to error with error: ")..(inspect(e)));
            setTimeout(function()
                error(errorToString(e))
            end)
        end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactHookEffectTags.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactHookEffectTags",function()
    type("not printable... yet");
    return{["NoFlags"]=0,["HasEffect"]=1,["Layout"]=2,["Passive"]=4}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberLazyComponent.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLazyComponent.new",function()
    type("not printable... yet");
    local function resolveDefaultProps(Component,baseProps)
        if((Component)and((typeof(Component))==("table")))and(Component.defaultProps)then
             local props=table.clone(baseProps);
            local defaultProps=Component.defaultProps;
            for propName,_ in defaultProps do
                 if(props[propName])==(nil)then
                     props[propName]=defaultProps[propName]
                end
             end;
            return props
         end;
        return baseProps
     end;
    return{["resolveDefaultProps"]=resolveDefaultProps}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_promise@3.5.2\promise\lib\init.lua
 tkpack.declare("game.Packages._Index.jsdotlua_promise@3.5.2.promise",function()
    local ERROR_NON_PROMISE_IN_LIST="Non-promise value passed into %s at index %s";
    local ERROR_NON_LIST="Please pass a list of promises to %s";
    local ERROR_NON_FUNCTION="Please pass a handler function to %s!";
    local MODE_KEY_METATABLE={["__mode"]="k"};
    local function isCallable(value)
        if(type(value))==("function")then
             return true
         end;
        if(type(value))==("table")then
             local metatable=getmetatable(value);
            if(metatable)and((type(rawget(metatable,"__call")))==("function"))then
                 return true
             end
         end;
        return false
     end;
    local function makeEnum(enumName,members)
        local enum={};
        for _,memberName in ipairs(members)do
             enum[memberName]=memberName
         end;
        return setmetatable(enum,{["__index"]=function(_,k)
            error(string.format("%s is not in %s!",k,enumName),2)
        end,["__newindex"]=function()
            error(string.format("Creating new members in %s is not allowed!",enumName),2)
        end})
    end;
    local Error;
    do
         Error={["Kind"]=makeEnum("Promise.Error.Kind",{"ExecutionError","AlreadyCancelled","NotResolvedInTime","TimedOut"})};
        Error.__index=Error;
        function Error.new(options,parent)
            options=(options)or({});
            return setmetatable({["error"]=(tostring(options.error))or("[This error has no error text.]"),["trace"]=options.trace,["context"]=options.context,["kind"]=options.kind,["parent"]=parent,["createdTick"]=os.clock(),["createdTrace"]=debug.traceback()},Error)
        end;
        function Error.is(anything)
            if(type(anything))==("table")then
                 local metatable=getmetatable(anything);
                if(type(metatable))==("table")then
                     return((rawget(anything,"error"))~=(nil))and((type(rawget(metatable,"extend")))==("function"))
                end
             end;
            return false
         end;
        function Error.isKind(anything,kind)
            assert((kind)~=(nil),"Argument \x232 to Promise.Error.isKind must not be nil");
            return(Error.is(anything))and((anything.kind)==(kind))
        end;
        function Error:extend(options)
            options=(options)or({});
            options.kind=(options.kind)or(self.kind);
            return Error.new(options,self)
        end;
        function Error:getErrorChain()
            local runtimeErrors={self};
            while runtimeErrors[#(runtimeErrors)].parent do
                 table.insert(runtimeErrors,runtimeErrors[#(runtimeErrors)].parent)
            end;
            return runtimeErrors
         end;
        function Error:__tostring()
            local errorStrings={string.format("-- Promise.Error(%s) --",(self.kind)or("?"))};
            for _,runtimeError in ipairs(self:getErrorChain())do
                 table.insert(errorStrings,table.concat({(runtimeError.trace)or(runtimeError.error),runtimeError.context},"\x0a"))
            end;
            return table.concat(errorStrings,"\x0a")
        end
     end;
    local function pack(...)
        return select("\x23",...),{...}
    end;
    local function packResult(success,...)
        return success,select("\x23",...),{...}
    end;
    local function makeErrorHandler(traceback)
        assert((traceback)~=(nil),"traceback is nil");
        return function(err)
            if(type(err))==("table")then
                 return err
             end;
            return Error.new({["error"]=err,["kind"]=Error.Kind.ExecutionError,["trace"]=debug.traceback(tostring(err),2),["context"]=("Promise created at:\x0a\x0a")..(traceback)})
        end
     end;
    local function runExecutor(traceback,callback,...)
        return packResult(xpcall(callback,makeErrorHandler(traceback),...))
    end;
    local function createAdvancer(traceback,callback,resolve,reject)
        return function(...)
            local ok,resultLength,result=runExecutor(traceback,callback,...);
            if ok then
                 resolve(unpack(result,1,resultLength))
            else
                 reject(result[1])
            end
         end
     end;
    local function isEmpty(t)
        return(next(t))==(nil)
    end;
    local Promise={["Error"]=Error,["Status"]=makeEnum("Promise.Status",{"Started","Resolved","Rejected","Cancelled"}),["_getTime"]=os.clock,["_timeEvent"]=game:GetService("RunService").Heartbeat,["_unhandledRejectionCallbacks"]={}};
    Promise.prototype={};
    Promise.__index=Promise.prototype;
    function Promise._new(traceback,callback,parent)
        if((parent)~=(nil))and(not(Promise.is(parent)))then
             error("Argument \x232 to Promise.new must be a promise or nil",2)
        end;
        local self={["_thread"]=nil,["_source"]=traceback,["_status"]=Promise.Status.Started,["_values"]=nil,["_valuesLength"]=-(1),["_unhandledRejection"]=true,["_queuedResolve"]={},["_queuedReject"]={},["_queuedFinally"]={},["_cancellationHook"]=nil,["_parent"]=parent,["_consumers"]=setmetatable({},MODE_KEY_METATABLE)};
        if(parent)and((parent._status)==(Promise.Status.Started))then
             parent._consumers[self]=true
         end;
        setmetatable(self,Promise);
        local function resolve(...)
            self:_resolve(...)
        end;
        local function reject(...)
            self:_reject(...)
        end;
        local function onCancel(cancellationHook)
            if cancellationHook then
                 if(self._status)==(Promise.Status.Cancelled)then
                     cancellationHook()
                else
                     self._cancellationHook=cancellationHook
                 end
             end;
            return(self._status)==(Promise.Status.Cancelled)
        end;
        self._thread=coroutine.create(function()
            local ok,_,result=runExecutor(self._source,callback,resolve,reject,onCancel);
            if not(ok)then
                 reject(result[1])
            end
         end);
        task.spawn(self._thread);
        return self
     end;
    function Promise.new(executor)
        return Promise._new(debug.traceback(nil,2),executor)
    end;
    function Promise:__tostring()
        return string.format("Promise(%s)",self._status)
    end;
    function Promise.defer(executor)
        local traceback=debug.traceback(nil,2);
        local promise;
        promise=Promise._new(traceback,function(resolve,reject,onCancel)
            local connection;
            connection=Promise._timeEvent:Connect(function()
                connection:Disconnect();
                local ok,_,result=runExecutor(traceback,executor,resolve,reject,onCancel);
                if not(ok)then
                     reject(result[1])
                end
             end)
        end);
        return promise
     end;
    Promise.async=Promise.defer;
    function Promise.resolve(...)
        local length,values=pack(...);
        return Promise._new(debug.traceback(nil,2),function(resolve)
            resolve(unpack(values,1,length))
        end)
    end;
    function Promise.reject(...)
        local length,values=pack(...);
        return Promise._new(debug.traceback(nil,2),function(_,reject)
            reject(unpack(values,1,length))
        end)
    end;
    function Promise._try(traceback,callback,...)
        local valuesLength,values=pack(...);
        return Promise._new(traceback,function(resolve)
            resolve(callback(unpack(values,1,valuesLength)))
        end)
    end;
    function Promise.try(callback,...)
        return Promise._try(debug.traceback(nil,2),callback,...)
    end;
    function Promise._all(traceback,promises,amount)
        if(type(promises))~=("table")then
             error(string.format(ERROR_NON_LIST,"Promise.all"),3)
        end;
        for i,promise in pairs(promises)do
             if not(Promise.is(promise))then
                 error(string.format(ERROR_NON_PROMISE_IN_LIST,"Promise.all",tostring(i)),3)
            end
         end;
        if((#(promises))==(0))or((amount)==(0))then
             return Promise.resolve({})
        end;
        return Promise._new(traceback,function(resolve,reject,onCancel)
            local resolvedValues={};
            local newPromises={};
            local resolvedCount=0;
            local rejectedCount=0;
            local done=false;
            local function cancel()
                for _,promise in ipairs(newPromises)do
                     promise:cancel()
                end
             end;
            local function resolveOne(i,...)
                if done then
                     return
                 end;
                resolvedCount=(resolvedCount)+(1);
                if(amount)==(nil)then
                     resolvedValues[i]=...
                else
                     resolvedValues[resolvedCount]=...
                end;
                if(resolvedCount)>=(((amount)or(#(promises))))then
                     done=true;
                    resolve(resolvedValues);
                    cancel()
                end
             end;
            onCancel(cancel);
            for i,promise in ipairs(promises)do
                 newPromises[i]=promise:andThen(function(...)
                    resolveOne(i,...)
                end,function(...)
                    rejectedCount=(rejectedCount)+(1);
                    if((amount)==(nil))or(((#(promises))-(rejectedCount))<(amount))then
                         cancel();
                        done=true;
                        reject(...)
                    end
                 end)
            end;
            if done then
                 cancel()
            end
         end)
    end;
    function Promise.all(...)
        local promises={...};
        if((type(promises[1]))==("table"))and(not(Promise.is(promises[1])))then
             promises=promises[1]
        end;
        return Promise._all(debug.traceback(nil,2),promises)
    end;
    function Promise.fold(list,reducer,initialValue)
        assert((type(list))==("table"),"Bad argument \x231 to Promise.fold: must be a table");
        assert(isCallable(reducer),"Bad argument \x232 to Promise.fold: must be a function");
        local accumulator=Promise.resolve(initialValue);
        return Promise.each(list,function(resolvedElement,i)
            accumulator=accumulator:andThen(function(previousValueResolved)
                return reducer(previousValueResolved,resolvedElement,i)
            end)
        end):andThen(function()
            return accumulator
         end)
    end;
    function Promise.some(promises,count)
        assert((type(count))==("number"),"Bad argument \x232 to Promise.some: must be a number");
        return Promise._all(debug.traceback(nil,2),promises,count)
    end;
    function Promise.any(promises)
        return Promise._all(debug.traceback(nil,2),promises,1):andThen(function(values)
            return values[1]
        end)
    end;
    function Promise.allSettled(promises)
        if(type(promises))~=("table")then
             error(string.format(ERROR_NON_LIST,"Promise.allSettled"),2)
        end;
        for i,promise in pairs(promises)do
             if not(Promise.is(promise))then
                 error(string.format(ERROR_NON_PROMISE_IN_LIST,"Promise.allSettled",tostring(i)),2)
            end
         end;
        if(#(promises))==(0)then
             return Promise.resolve({})
        end;
        return Promise._new(debug.traceback(nil,2),function(resolve,_,onCancel)
            local fates={};
            local newPromises={};
            local finishedCount=0;
            local function resolveOne(i,...)
                finishedCount=(finishedCount)+(1);
                fates[i]=...;
                if(finishedCount)>=(#(promises))then
                     resolve(fates)
                end
             end;
            onCancel(function()
                for _,promise in ipairs(newPromises)do
                     promise:cancel()
                end
             end);
            for i,promise in ipairs(promises)do
                 newPromises[i]=promise:finally(function(...)
                    resolveOne(i,...)
                end)
            end
         end)
    end;
    function Promise.race(promises)
        assert((type(promises))==("table"),string.format(ERROR_NON_LIST,"Promise.race"));
        for i,promise in pairs(promises)do
             assert(Promise.is(promise),string.format(ERROR_NON_PROMISE_IN_LIST,"Promise.race",tostring(i)))
        end;
        return Promise._new(debug.traceback(nil,2),function(resolve,reject,onCancel)
            local newPromises={};
            local finished=false;
            local function cancel()
                for _,promise in ipairs(newPromises)do
                     promise:cancel()
                end
             end;
            local function finalize(callback)
                return function(...)
                    cancel();
                    finished=true;
                    return callback(...)
                end
             end;
            if onCancel(finalize(reject))then
                 return
             end;
            for i,promise in ipairs(promises)do
                 newPromises[i]=promise:andThen(finalize(resolve),finalize(reject))
            end;
            if finished then
                 cancel()
            end
         end)
    end;
    function Promise.each(list,predicate)
        assert((type(list))==("table"),string.format(ERROR_NON_LIST,"Promise.each"));
        assert(isCallable(predicate),string.format(ERROR_NON_FUNCTION,"Promise.each"));
        return Promise._new(debug.traceback(nil,2),function(resolve,reject,onCancel)
            local results={};
            local promisesToCancel={};
            local cancelled=false;
            local function cancel()
                for _,promiseToCancel in ipairs(promisesToCancel)do
                     promiseToCancel:cancel()
                end
             end;
            onCancel(function()
                cancelled=true;
                cancel()
            end);
            local preprocessedList={};
            for index,value in ipairs(list)do
                 if Promise.is(value)then
                     if(value:getStatus())==(Promise.Status.Cancelled)then
                         cancel();
                        return reject(Error.new({["error"]="Promise is cancelled",["kind"]=Error.Kind.AlreadyCancelled,["context"]=string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\x0a\x0aThat Promise was created at:\x0a\x0a%s",index,value._source)}))
                    elseif(value:getStatus())==(Promise.Status.Rejected)then
                         cancel();
                        return reject(select(2,value:await()))
                    end;
                    local ourPromise=value:andThen(function(...)
                        return...
                    end);
                    table.insert(promisesToCancel,ourPromise);
                    preprocessedList[index]=ourPromise
                 else
                     preprocessedList[index]=value
                 end
             end;
            for index,value in ipairs(preprocessedList)do
                 if Promise.is(value)then
                     local success;
                    success,value=value:await();
                    if not(success)then
                         cancel();
                        return reject(value)
                    end
                 end;
                if cancelled then
                     return
                 end;
                local predicatePromise=Promise.resolve(predicate(value,index));
                table.insert(promisesToCancel,predicatePromise);
                local success,result=predicatePromise:await();
                if not(success)then
                     cancel();
                    return reject(result)
                end;
                results[index]=result
             end;
            resolve(results)
        end)
    end;
    function Promise.is(object)
        if(type(object))~=("table")then
             return false
         end;
        local objectMetatable=getmetatable(object);
        if(objectMetatable)==(Promise)then
             return true
         elseif(objectMetatable)==(nil)then
             return isCallable(object.andThen)
        elseif(((type(objectMetatable))==("table"))and((type(rawget(objectMetatable,"__index")))==("table")))and(isCallable(rawget(rawget(objectMetatable,"__index"),"andThen")))then
             return true
         end;
        return false
     end;
    function Promise.promisify(callback)
        return function(...)
            return Promise._try(debug.traceback(nil,2),callback,...)
        end
     end;
    do
         local first;
        local connection;
        function Promise.delay(seconds)
            assert((type(seconds))==("number"),"Bad argument \x231 to Promise.delay, must be a number.");
            if(not(((seconds)>=((1)/(60)))))or((seconds)==(math.huge))then
                 seconds=(1)/(60)
            end;
            return Promise._new(debug.traceback(nil,2),function(resolve,_,onCancel)
                local startTime=Promise._getTime();
                local endTime=(startTime)+(seconds);
                local node={["resolve"]=resolve,["startTime"]=startTime,["endTime"]=endTime};
                if(connection)==(nil)then
                     first=node;
                    connection=Promise._timeEvent:Connect(function()
                        local threadStart=Promise._getTime();
                        while((first)~=(nil))and((first.endTime)<(threadStart))do
                             local current=first;
                            first=current.next;
                            if(first)==(nil)then
                                 connection:Disconnect();
                                connection=nil
                             else
                                 first.previous=nil
                             end;
                            current.resolve((Promise._getTime())-(current.startTime))
                        end
                     end)
                else
                     if(first.endTime)<(endTime)then
                         local current=first;
                        local next=current.next;
                        while((next)~=(nil))and((next.endTime)<(endTime))do
                             current=next;
                            next=current.next
                         end;
                        current.next=node;
                        node.previous=current;
                        if(next)~=(nil)then
                             node.next=next;
                            next.previous=node
                         end
                     else
                         node.next=first;
                        first.previous=node;
                        first=node
                     end
                 end;
                onCancel(function()
                    local next=node.next;
                    if(first)==(node)then
                         if(next)==(nil)then
                             connection:Disconnect();
                            connection=nil
                         else
                             next.previous=nil
                         end;
                        first=next
                     else
                         local previous=node.previous;
                        previous.next=next;
                        if(next)~=(nil)then
                             next.previous=previous
                         end
                     end
                 end)
            end)
        end
     end;
    function Promise.prototype:timeout(seconds,rejectionValue)
        local traceback=debug.traceback(nil,2);
        return Promise.race({Promise.delay(seconds):andThen(function()
            return Promise.reject((((rejectionValue)==(nil))and(Error.new({["kind"]=Error.Kind.TimedOut,["error"]="Timed out",["context"]=string.format("Timeout of %d seconds exceeded.\x0a:timeout() called at:\x0a\x0a%s",seconds,traceback)})))or(rejectionValue))
        end),self})
    end;
    function Promise.prototype:getStatus()
        return self._status
     end;
    function Promise.prototype:_andThen(traceback,successHandler,failureHandler)
        self._unhandledRejection=false;
        return Promise._new(traceback,function(resolve,reject)
            local successCallback=resolve;
            if successHandler then
                 successCallback=createAdvancer(traceback,successHandler,resolve,reject)
            end;
            local failureCallback=reject;
            if failureHandler then
                 failureCallback=createAdvancer(traceback,failureHandler,resolve,reject)
            end;
            if(self._status)==(Promise.Status.Started)then
                 table.insert(self._queuedResolve,successCallback);
                table.insert(self._queuedReject,failureCallback)
            elseif(self._status)==(Promise.Status.Resolved)then
                 successCallback(unpack(self._values,1,self._valuesLength))
            elseif(self._status)==(Promise.Status.Rejected)then
                 failureCallback(unpack(self._values,1,self._valuesLength))
            elseif(self._status)==(Promise.Status.Cancelled)then
                 reject(Error.new({["error"]="Promise is cancelled",["kind"]=Error.Kind.AlreadyCancelled,["context"]=("Promise created at\x0a\x0a")..(traceback)}))
            end
         end,self)
    end;
    function Promise.prototype:andThen(successHandler,failureHandler)
        assert(((successHandler)==(nil))or(isCallable(successHandler)),string.format(ERROR_NON_FUNCTION,"Promise:andThen"));
        assert(((failureHandler)==(nil))or(isCallable(failureHandler)),string.format(ERROR_NON_FUNCTION,"Promise:andThen"));
        return self:_andThen(debug.traceback(nil,2),successHandler,failureHandler)
    end;
    function Promise.prototype:andThenAsync(successHandler,failureHandler)
        assert(((successHandler)==(nil))or(isCallable(successHandler)),string.format(ERROR_NON_FUNCTION,"Promise:andThenAsync"));
        assert(((failureHandler)==(nil))or(isCallable(failureHandler)),string.format(ERROR_NON_FUNCTION,"Promise:andThenAsync"));
        return self:_andThen(debug.traceback(nil,2),function(...)
            local length,values=pack(...);
            return Promise.defer(function(resolve)
                resolve(unpack(values,1,length))
            end)
        end,function(...)
            local length,values=pack(...);
            return Promise.defer(function(_,reject)
                reject(unpack(values,1,length))
            end)
        end):andThen(successHandler,failureHandler)
    end;
    function Promise.prototype:catch(failureHandler)
        assert(((failureHandler)==(nil))or(isCallable(failureHandler)),string.format(ERROR_NON_FUNCTION,"Promise:catch"));
        return self:_andThen(debug.traceback(nil,2),nil,failureHandler)
    end;
    function Promise.prototype:tap(tapHandler)
        assert(isCallable(tapHandler),string.format(ERROR_NON_FUNCTION,"Promise:tap"));
        return self:_andThen(debug.traceback(nil,2),function(...)
            local callbackReturn=tapHandler(...);
            if Promise.is(callbackReturn)then
                 local length,values=pack(...);
                return callbackReturn:andThen(function()
                    return unpack(values,1,length)
                end)
            end;
            return...
        end)
    end;
    function Promise.prototype:andThenCall(callback,...)
        assert(isCallable(callback),string.format(ERROR_NON_FUNCTION,"Promise:andThenCall"));
        local length,values=pack(...);
        return self:_andThen(debug.traceback(nil,2),function()
            return callback(unpack(values,1,length))
        end)
    end;
    function Promise.prototype:andThenReturn(...)
        local length,values=pack(...);
        return self:_andThen(debug.traceback(nil,2),function()
            return unpack(values,1,length)
        end)
    end;
    function Promise.prototype:cancel()
        if(self._status)~=(Promise.Status.Started)then
             return
         end;
        self._status=Promise.Status.Cancelled;
        if self._cancellationHook then
             self._cancellationHook()
        end;
        coroutine.close(self._thread);
        if self._parent then
             self._parent:_consumerCancelled(self)
        end;
        for child in pairs(self._consumers)do
             child:cancel()
        end;
        self:_finalize()
    end;
    function Promise.prototype:_consumerCancelled(consumer)
        if(self._status)~=(Promise.Status.Started)then
             return
         end;
        self._consumers[consumer]=nil;
        if(next(self._consumers))==(nil)then
             self:cancel()
        end
     end;
    function Promise.prototype:_finally(traceback,finallyHandler,onlyOk)
        if not(onlyOk)then
             self._unhandledRejection=false
         end;
        return Promise._new(traceback,function(resolve,reject)
            local finallyCallback=resolve;
            if finallyHandler then
                 finallyCallback=createAdvancer(traceback,finallyHandler,resolve,reject)
            end;
            if onlyOk then
                 local callback=finallyCallback;
                finallyCallback=function(...)
                    if(self._status)==(Promise.Status.Rejected)then
                         return resolve(self)
                    end;
                    return callback(...)
                end
             end;
            if(self._status)==(Promise.Status.Started)then
                 table.insert(self._queuedFinally,finallyCallback)
            else
                 finallyCallback(self._status)
            end
         end,self)
    end;
    function Promise.prototype:finally(finallyHandler)
        assert(((finallyHandler)==(nil))or(isCallable(finallyHandler)),string.format(ERROR_NON_FUNCTION,"Promise:finally"));
        return self:_finally(debug.traceback(nil,2),finallyHandler)
    end;
    function Promise.prototype:finallyCall(callback,...)
        assert(isCallable(callback),string.format(ERROR_NON_FUNCTION,"Promise:finallyCall"));
        local length,values=pack(...);
        return self:_finally(debug.traceback(nil,2),function()
            return callback(unpack(values,1,length))
        end)
    end;
    function Promise.prototype:finallyReturn(...)
        local length,values=pack(...);
        return self:_finally(debug.traceback(nil,2),function()
            return unpack(values,1,length)
        end)
    end;
    function Promise.prototype:done(finallyHandler)
        assert(((finallyHandler)==(nil))or(isCallable(finallyHandler)),string.format(ERROR_NON_FUNCTION,"Promise:done"));
        return self:_finally(debug.traceback(nil,2),finallyHandler,true)
    end;
    function Promise.prototype:doneCall(callback,...)
        assert(isCallable(callback),string.format(ERROR_NON_FUNCTION,"Promise:doneCall"));
        local length,values=pack(...);
        return self:_finally(debug.traceback(nil,2),function()
            return callback(unpack(values,1,length))
        end,true)
    end;
    function Promise.prototype:doneReturn(...)
        local length,values=pack(...);
        return self:_finally(debug.traceback(nil,2),function()
            return unpack(values,1,length)
        end,true)
    end;
    function Promise.prototype:awaitStatus()
        self._unhandledRejection=false;
        if(self._status)==(Promise.Status.Started)then
             local thread=coroutine.running();
            self:finally(function()
                task.spawn(thread)
            end);
            coroutine.yield()
        end;
        if(self._status)==(Promise.Status.Resolved)then
             return self._status,unpack(self._values,1,self._valuesLength)
        elseif(self._status)==(Promise.Status.Rejected)then
             return self._status,unpack(self._values,1,self._valuesLength)
        end;
        return self._status
     end;
    local function awaitHelper(status,...)
        return(status)==(Promise.Status.Resolved),...
    end;
    function Promise.prototype:await()
        return awaitHelper(self:awaitStatus())
    end;
    local function expectHelper(status,...)
        if(status)~=(Promise.Status.Resolved)then
             error(((((...))==(nil))and("Expected Promise rejected with no value."))or((...)),3)
        end;
        return...
    end;
    function Promise.prototype:expect()
        return expectHelper(self:awaitStatus())
    end;
    Promise.prototype.awaitValue=Promise.prototype.expect;
    function Promise.prototype:_unwrap()
        if(self._status)==(Promise.Status.Started)then
             error("Promise has not resolved or rejected.",2)
        end;
        local success=(self._status)==(Promise.Status.Resolved);
        return success,unpack(self._values,1,self._valuesLength)
    end;
    function Promise.prototype:_resolve(...)
        if(self._status)~=(Promise.Status.Started)then
             if Promise.is((...))then
                (...):_consumerCancelled(self)
            end;
            return
         end;
        if Promise.is((...))then
             if(select("\x23",...))>(1)then
                 local message=string.format(("When returning a Promise from andThen, extra arguments are ")..("discarded! See:\x0a\x0a%s"),self._source);
                warn(message)
            end;
            local chainedPromise=...;
            local promise=chainedPromise:andThen(function(...)
                self:_resolve(...)
            end,function(...)
                local maybeRuntimeError=chainedPromise._values[1];
                if chainedPromise._error then
                     maybeRuntimeError=Error.new({["error"]=chainedPromise._error,["kind"]=Error.Kind.ExecutionError,["context"]="[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"})
                end;
                if Error.isKind(maybeRuntimeError,Error.Kind.ExecutionError)then
                     return self:_reject(maybeRuntimeError:extend({["error"]="This Promise was chained to a Promise that errored.",["trace"]="",["context"]=string.format("The Promise at:\x0a\x0a%s\x0a...Rejected because it was chained to the following Promise, which encountered an error:\x0a",self._source)}))
                end;
                self:_reject(...)
            end);
            if(promise._status)==(Promise.Status.Cancelled)then
                 self:cancel()
            elseif(promise._status)==(Promise.Status.Started)then
                 self._parent=promise;
                promise._consumers[self]=true
             end;
            return
         end;
        self._status=Promise.Status.Resolved;
        self._valuesLength,self._values=pack(...);
        for _,callback in ipairs(self._queuedResolve)do
             coroutine.wrap(callback)(...)
        end;
        self:_finalize()
    end;
    function Promise.prototype:_reject(...)
        if(self._status)~=(Promise.Status.Started)then
             return
         end;
        self._status=Promise.Status.Rejected;
        self._valuesLength,self._values=pack(...);
        if not(isEmpty(self._queuedReject))then
             for _,callback in ipairs(self._queuedReject)do
                 coroutine.wrap(callback)(...)
            end
         else
             local err=tostring((...));
            coroutine.wrap(function()
                Promise._timeEvent:Wait();
                if not(self._unhandledRejection)then
                     return
                 end;
                local message=string.format("Unhandled Promise rejection:\x0a\x0a%s\x0a\x0a%s",err,self._source);
                for _,callback in ipairs(Promise._unhandledRejectionCallbacks)do
                     task.spawn(callback,self,unpack(self._values,1,self._valuesLength))
                end;
                if Promise.TEST then
                     return
                 end;
                warn(message)
            end)()
        end;
        self:_finalize()
    end;
    function Promise.prototype:_finalize()
        for _,callback in ipairs(self._queuedFinally)do
             coroutine.wrap(callback)(self._status)
        end;
        self._queuedFinally=nil;
        self._queuedReject=nil;
        self._queuedResolve=nil;
        if not(Promise.TEST)then
             self._parent=nil;
            self._consumers=nil
         end;
        task.defer(coroutine.close,self._thread)
    end;
    function Promise.prototype:now(rejectionValue)
        local traceback=debug.traceback(nil,2);
        if(self._status)==(Promise.Status.Resolved)then
             return self:_andThen(traceback,function(...)
                return...
            end)
        else
             return Promise.reject((((rejectionValue)==(nil))and(Error.new({["kind"]=Error.Kind.NotResolvedInTime,["error"]="This Promise was not resolved in time for :now()",["context"]=(":now() was called at:\x0a\x0a")..(traceback)})))or(rejectionValue))
        end
     end;
    function Promise.retry(callback,times,...)
        assert(isCallable(callback),"Parameter \x231 to Promise.retry must be a function");
        assert((type(times))==("number"),"Parameter \x232 to Promise.retry must be a number");
        local args,length={...},select("\x23",...);
        return Promise.resolve(callback(...)):catch(function(...)
            if(times)>(0)then
                 return Promise.retry(callback,(times)-(1),unpack(args,1,length))
            else
                 return Promise.reject(...)
            end
         end)
    end;
    function Promise.retryWithDelay(callback,times,seconds,...)
        assert(isCallable(callback),"Parameter \x231 to Promise.retry must be a function");
        assert((type(times))==("number"),"Parameter \x232 (times) to Promise.retry must be a number");
        assert((type(seconds))==("number"),"Parameter \x233 (seconds) to Promise.retry must be a number");
        local args,length={...},select("\x23",...);
        return Promise.resolve(callback(...)):catch(function(...)
            if(times)>(0)then
                 Promise.delay(seconds):await();
                return Promise.retryWithDelay(callback,(times)-(1),seconds,unpack(args,1,length))
            else
                 return Promise.reject(...)
            end
         end)
    end;
    function Promise.fromEvent(event,predicate)
        predicate=(predicate)or(function()
            return true
         end);
        return Promise._new(debug.traceback(nil,2),function(resolve,_,onCancel)
            local connection;
            local shouldDisconnect=false;
            local function disconnect()
                connection:Disconnect();
                connection=nil
             end;
            connection=event:Connect(function(...)
                local callbackValue=predicate(...);
                if(callbackValue)==(true)then
                     resolve(...);
                    if connection then
                         disconnect()
                    else
                         shouldDisconnect=true
                     end
                 elseif(type(callbackValue))~=("boolean")then
                     error("Promise.fromEvent predicate should always return a boolean")
                end
             end);
            if(shouldDisconnect)and(connection)then
                 return disconnect()
            end;
            onCancel(disconnect)
        end)
    end;
    function Promise.onUnhandledRejection(callback)
        table.insert(Promise._unhandledRejectionCallbacks,callback);
        return function()
            local index=table.find(Promise._unhandledRejectionCallbacks,callback);
            if index then
                 table.remove(Promise._unhandledRejectionCallbacks,index)
            end
         end
     end;
    return Promise

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\MaxInts.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.MaxInts",function()
    return{["MAX_SIGNED_31_BIT_INT"]=1073741823}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react.lua
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react",function()
    return tkpack.include("game.Packages._Index.jsdotlua_react@17.2.1.react")

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactChildFiber.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactChildFiber.new",function()
    local __DEV__=_G.__DEV__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Array=LuauPolyfill.Array;
    local Error=LuauPolyfill.Error;
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    type("not printable... yet");
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    type("not printable... yet");
    local React=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react");
    type("not printable... yet");
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    type("not printable... yet");
    local ReactFiberLanes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local Placement=ReactFiberFlags.Placement;
    local Deletion=ReactFiberFlags.Deletion;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols;
    local getIteratorFn=ReactSymbols.getIteratorFn;
    local REACT_ELEMENT_TYPE=ReactSymbols.REACT_ELEMENT_TYPE;
    local REACT_FRAGMENT_TYPE=ReactSymbols.REACT_FRAGMENT_TYPE;
    local REACT_PORTAL_TYPE=ReactSymbols.REACT_PORTAL_TYPE;
    local REACT_LAZY_TYPE=ReactSymbols.REACT_LAZY_TYPE;
    local REACT_BLOCK_TYPE=ReactSymbols.REACT_BLOCK_TYPE;
    local ReactWorkTags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactWorkTags");
    local FunctionComponent=ReactWorkTags.FunctionComponent;
    local ClassComponent=ReactWorkTags.ClassComponent;
    local HostText=ReactWorkTags.HostText;
    local HostPortal=ReactWorkTags.HostPortal;
    local ForwardRef=ReactWorkTags.ForwardRef;
    local Fragment=ReactWorkTags.Fragment;
    local SimpleMemoComponent=ReactWorkTags.SimpleMemoComponent;
    local Block=ReactWorkTags.Block;
    local invariant=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").invariant;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local enableLazyElements=ReactFeatureFlags.enableLazyElements;
    local enableBlocksAPI=ReactFeatureFlags.enableBlocksAPI;
    local ReactFiber=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiber.new");
    local createWorkInProgress=ReactFiber.createWorkInProgress;
    local resetWorkInProgress=ReactFiber.resetWorkInProgress;
    local createFiberFromElement=ReactFiber.createFiberFromElement;
    local createFiberFromFragment=ReactFiber.createFiberFromFragment;
    local createFiberFromText=ReactFiber.createFiberFromText;
    local createFiberFromPortal=ReactFiber.createFiberFromPortal;
    local exports={};
    local didWarnAboutMaps;
    local ownerHasKeyUseWarning;
    local ownerHasFunctionTypeWarning;
    local warnForMissingKey=function(child,returnFiber)
        
    end;
    if __DEV__ then
         didWarnAboutMaps=false;
        ownerHasKeyUseWarning={};
        ownerHasFunctionTypeWarning={};
        warnForMissingKey=function(child,returnFiber)
            if((child)==(nil))or((type(child))~=("table"))then
                 return
             end;
            if((not(child._store))or(child._store.validated))or((child.key)~=(nil))then
                 return
             end;
            invariant(((child._store)~=(nil))and((type(child._store))==("table")),"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            child._store.validated=true;
            local componentName=(getComponentName(returnFiber.type))or("Component");
            if ownerHasKeyUseWarning[componentName]then
                 return
             end;
            ownerHasKeyUseWarning[componentName]=true;
            console.error("Each child in a list should have a unique \"key\" prop. See https://reactjs.org/link/warning-keys for more information.")
        end
     end;
    local isArray=Array.isArray;
    function coerceRef(returnFiber,current,element)
        local mixedRef=element.ref;
        if((mixedRef)~=(nil))and((type(mixedRef))==("string"))then
             if((not(element._owner))or(not(element._self)))or((element._owner.stateNode)==(element._self))then
                 local componentName;
                if __DEV__ then
                     componentName=(getComponentName(returnFiber.type))or("Component")
                else
                     componentName="<enable __DEV__ mode for component names>"
                end;
                error(Error.new(string.format("Component \"%s\" contains the string ref \"%s\". Support for string refs has been removed. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref",componentName,tostring(mixedRef))))
            end;
            if not(element._owner)then
                 error("Expected ref to be a function or an object returned by React.createRef(), or nil.")
            end
         end;
        return mixedRef
     end;
    local function warnOnFunctionType(returnFiber)
        if __DEV__ then
             local componentName=(getComponentName(returnFiber.type))or("Component");
            if ownerHasFunctionTypeWarning[componentName]then
                 return
             end;
            ownerHasFunctionTypeWarning[componentName]=true;
            console.error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.")
        end
     end;
    function resolveLazyType(lazyComponent)
        local payload=lazyComponent._payload;
        local init=lazyComponent._init;
        local ok,result=xpcall(init,describeError,payload);
        if not(ok)then
             return lazyComponent
         end;
        return result
     end;
    local function ChildReconciler(shouldTrackSideEffects)
        local function deleteChild(returnFiber,childToDelete)
            if not(shouldTrackSideEffects)then
                 return
             end;
            local deletions=returnFiber.deletions;
            if(deletions)==(nil)then
                 returnFiber.deletions={childToDelete};
                returnFiber.flags=bit32.bor(returnFiber.flags,Deletion)
            else
                 table.insert(deletions,childToDelete)
            end
         end;
        local function deleteRemainingChildren(returnFiber,currentFirstChild)
            if not(shouldTrackSideEffects)then
                 return nil
             end;
            local childToDelete=currentFirstChild;
            while(childToDelete)~=(nil)do
                 deleteChild(returnFiber,childToDelete);
                childToDelete=childToDelete.sibling
             end;
            return nil
         end;
        local function mapRemainingChildren(returnFiber,currentFirstChild)
            local existingChildren={};
            local existingChild=currentFirstChild;
            while(existingChild)~=(nil)do
                 if(existingChild.key)~=(nil)then
                     existingChildren[existingChild.key]=existingChild
                 else
                     existingChildren[existingChild.index]=existingChild
                 end;
                existingChild=existingChild.sibling
             end;
            return existingChildren
         end;
        local function useFiber(fiber,pendingProps)
            local clone=createWorkInProgress(fiber,pendingProps);
            clone.index=1;
            clone.sibling=nil;
            return clone
         end;
        local function placeChild(newFiber,lastPlacedIndex,newIndex)
            newFiber.index=newIndex;
            if not(shouldTrackSideEffects)then
                 return lastPlacedIndex
             end;
            local current=newFiber.alternate;
            if(current)~=(nil)then
                 local oldIndex=current.index;
                if(oldIndex)<(lastPlacedIndex)then
                     newFiber.flags=bit32.bor(newFiber.flags,Placement);
                    return lastPlacedIndex
                 else
                     return oldIndex
                 end
             else
                 newFiber.flags=bit32.bor(newFiber.flags,Placement);
                return lastPlacedIndex
             end
         end;
        local function placeSingleChild(newFiber)
            if(shouldTrackSideEffects)and((newFiber.alternate)==(nil))then
                 newFiber.flags=bit32.bor(newFiber.flags,Placement)
            end;
            return newFiber
         end;
        local function updateTextNode(returnFiber,current,textContent,lanes)
            if((current)==(nil))or(((current).tag)~=(HostText))then
                 local created=createFiberFromText(textContent,returnFiber.mode,lanes);
                created.return_=returnFiber;
                return created
             else
                 local existing=useFiber(current,textContent);
                existing.return_=returnFiber;
                return existing
             end
         end;
        local function updateElement(returnFiber,current,element,lanes)
            if(current)~=(nil)then
                 if((current).elementType)==(element.type)then
                     local existing=useFiber(current,element.props);
                    existing.ref=coerceRef(returnFiber,current,element);
                    existing.return_=returnFiber;
                    if __DEV__ then
                         existing._debugSource=element._source;
                        existing._debugOwner=element._owner
                     end;
                    return existing
                 elseif(enableBlocksAPI)and(((current).tag)==(Block))then
                     local type_=element.type;
                    if((type(type_))==("table"))and((type_["\x24\x24typeof"])==(REACT_LAZY_TYPE))then
                         type_=resolveLazyType(type_)
                    end;
                    if((type_["\x24\x24typeof"])==(REACT_BLOCK_TYPE))and((type_._render)==((current).type._render))then
                         local existing=useFiber(current,element.props);
                        existing.return_=returnFiber;
                        existing.type=type_;
                        if __DEV__ then
                             existing._debugSource=element._source;
                            existing._debugOwner=element._owner
                         end;
                        return existing
                     end
                 end
             end;
            local created=createFiberFromElement(element,returnFiber.mode,lanes);
            created.ref=coerceRef(returnFiber,current,element);
            created.return_=returnFiber;
            return created
         end;
        local function updatePortal(returnFiber,current,portal,lanes)
            if((((current)==(nil))or(((current).tag)~=(HostPortal)))or(((current).stateNode.containerInfo)~=(portal.containerInfo)))or(((current).stateNode.implementation)~=(portal.implementation))then
                 local created=createFiberFromPortal(portal,returnFiber.mode,lanes);
                created.return_=returnFiber;
                return created
             else
                 local existing=useFiber(current,(portal.children)or({}));
                existing.return_=returnFiber;
                return existing
             end
         end;
        local function updateFragment(returnFiber,current,fragment,lanes,key)
            if((current)==(nil))or(((current).tag)~=(Fragment))then
                 local created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);
                created.return_=returnFiber;
                return created
             else
                 local existing=useFiber(current,fragment);
                existing.return_=returnFiber;
                return existing
             end
         end;
        local function assignStableKey(tableKey,newChild)
            if(newChild.key)==(nil)then
                 local typeOfTableKey=type(tableKey);
                if((typeOfTableKey)==("string"))or((typeOfTableKey)==("number"))then
                     newChild.key=tableKey
                 elseif(typeOfTableKey)==("table")then
                     newChild.key=tostring(tableKey)
                end
             end
         end;
        local function createChild(returnFiber,newChild,lanes,tableKey)
            if(newChild)==(nil)then
                 return nil
             end;
            local typeOfNewChild=type(newChild);
            if(typeOfNewChild)==("table")then
                 assignStableKey(tableKey,newChild);
                local newChildTypeof=newChild["\x24\x24typeof"];
                if(newChildTypeof)==(REACT_ELEMENT_TYPE)then
                     local created=createFiberFromElement(newChild,returnFiber.mode,lanes);
                    created.ref=coerceRef(returnFiber,nil,newChild);
                    created.return_=returnFiber;
                    return created
                 elseif(newChildTypeof)==(REACT_PORTAL_TYPE)then
                     local created=createFiberFromPortal(newChild,returnFiber.mode,lanes);
                    created.return_=returnFiber;
                    return created
                 elseif(newChildTypeof)==(REACT_LAZY_TYPE)then
                     if enableLazyElements then
                         local payload=newChild._payload;
                        local init=newChild._init;
                        return createChild(returnFiber,init(payload),lanes)
                    end
                 end;
                local created=createFiberFromFragment(newChild,returnFiber.mode,lanes,nil);
                created.return_=returnFiber;
                return created
             end;
            if((typeOfNewChild)==("string"))or((typeOfNewChild)==("number"))then
                 local created=createFiberFromText(tostring(newChild),returnFiber.mode,lanes);
                created.return_=returnFiber;
                return created
             end;
            if __DEV__ then
                 if(typeOfNewChild)==("function")then
                     warnOnFunctionType(returnFiber)
                end
             end;
            return nil
         end;
        local function updateSlot(returnFiber,oldFiber,newChild,lanes,tableKey)
            if(newChild)==(nil)then
                 return nil
             end;
            local key=if(oldFiber)~=(nil)then oldFiber.key else nil;
            local typeOfNewChild=type(newChild);
            if(typeOfNewChild)==("table")then
                 assignStableKey(tableKey,newChild);
                local newChildTypeof=newChild["\x24\x24typeof"];
                if(newChildTypeof)==(REACT_ELEMENT_TYPE)then
                     if(newChild.key)==(key)then
                         if(newChild.type)==(REACT_FRAGMENT_TYPE)then
                             return updateFragment(returnFiber,oldFiber,newChild.props.children,lanes,key)
                        end;
                        return updateElement(returnFiber,oldFiber,newChild,lanes)
                    else
                         return nil
                     end
                 elseif(newChildTypeof)==(REACT_PORTAL_TYPE)then
                     if(newChild.key)==(key)then
                         return updatePortal(returnFiber,oldFiber,newChild,lanes)
                    else
                         return nil
                     end
                 elseif(newChildTypeof)==(REACT_LAZY_TYPE)then
                     if enableLazyElements then
                         local payload=newChild._payload;
                        local init=newChild._init;
                        return updateSlot(returnFiber,oldFiber,init(payload),lanes)
                    end
                 end;
                if(key)~=(nil)then
                     return nil
                 end;
                return updateFragment(returnFiber,oldFiber,newChild,lanes)
            end;
            if((typeOfNewChild)==("string"))or((typeOfNewChild)==("number"))then
                 if(key)~=(nil)then
                     return nil
                 end;
                return updateTextNode(returnFiber,oldFiber,tostring(newChild),lanes)
            end;
            if __DEV__ then
                 if(typeOfNewChild)==("function")then
                     warnOnFunctionType(returnFiber)
                end
             end;
            return nil
         end;
        local function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes,tableKey)
            if(newChild)==(nil)then
                 return nil
             end;
            local typeOfNewChild=type(newChild);
            if(typeOfNewChild)==("table")then
                 assignStableKey(tableKey,newChild);
                local existingChildrenKey;
                local newChildTypeof=newChild["\x24\x24typeof"];
                if(newChildTypeof)==(REACT_ELEMENT_TYPE)then
                     if(newChild.key)==(nil)then
                         existingChildrenKey=newIdx
                     else
                         existingChildrenKey=newChild.key
                     end;
                    local matchedFiber=existingChildren[existingChildrenKey];
                    if(newChild.type)==(REACT_FRAGMENT_TYPE)then
                         return updateFragment(returnFiber,matchedFiber,newChild.props.children,lanes,newChild.key)
                    end;
                    return updateElement(returnFiber,matchedFiber,newChild,lanes)
                elseif(newChildTypeof)==(REACT_PORTAL_TYPE)then
                     if(newChild.key)==(nil)then
                         existingChildrenKey=newIdx
                     else
                         existingChildrenKey=newChild.key
                     end;
                    local matchedFiber=existingChildren[existingChildrenKey];
                    return updatePortal(returnFiber,matchedFiber,newChild,lanes)
                elseif(newChildTypeof)==(REACT_LAZY_TYPE)then
                     if enableLazyElements then
                         local payload=newChild._payload;
                        local init=newChild._init;
                        return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes)
                    end
                 end;
                local matchedFiber=existingChildren[newIdx];
                return updateFragment(returnFiber,matchedFiber,newChild,lanes)
            end;
            if((typeOfNewChild)==("string"))or((typeOfNewChild)==("number"))then
                 local matchedFiber=(existingChildren[newIdx])or(nil);
                return updateTextNode(returnFiber,matchedFiber,tostring(newChild),lanes)
            end;
            if __DEV__ then
                 if(typeOfNewChild)==("function")then
                     warnOnFunctionType(returnFiber)
                end
             end;
            return nil
         end;
        local function warnOnInvalidKey(child,knownKeys,returnFiber)
            if __DEV__ then
                 if((child)==(nil))or((type(child))~=("table"))then
                     return knownKeys
                 end;
                local childTypeof=child["\x24\x24typeof"];
                if((childTypeof)==(REACT_ELEMENT_TYPE))or((childTypeof)==(REACT_PORTAL_TYPE))then
                     warnForMissingKey(child,returnFiber);
                    local key=child.key;
                    if(type(key))~=("string")then
                        
                     elseif(knownKeys)==(nil)then
                         knownKeys={};
                        (knownKeys)[key]=true
                     elseif not((knownKeys)[key])then
                        (knownKeys)[key]=true
                     else
                         console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \xffffffe2\xffffff80\xffffff94 the behavior is unsupported and could change in a future version.",key)
                    end
                 elseif(childTypeof)==(REACT_LAZY_TYPE)then
                     if enableLazyElements then
                         local payload=child._payload;
                        local init=child._init;
                        warnOnInvalidKey(init(payload),knownKeys,returnFiber)
                    end
                 end
             end;
            return knownKeys
         end;
        local function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes)
            if __DEV__ then
                 local knownKeys;
                for i,child in newChildren do
                     knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)
                end
             end;
            local resultingFirstChild;
            local previousNewFiber;
            local oldFiber=currentFirstChild;
            local lastPlacedIndex=1;
            local newIdx=1;
            local nextOldFiber;
            local newChildrenCount=#(newChildren);
            while((oldFiber)~=(nil))and((newIdx)<=(newChildrenCount))do
                 if(oldFiber.index)>(newIdx)then
                     nextOldFiber=oldFiber;
                    oldFiber=nil
                 else
                     nextOldFiber=oldFiber.sibling
                 end;
                local newFiber;
                local newChildNewIdx=newChildren[newIdx];
                if(((newChildNewIdx)~=(nil))and((type(newChildNewIdx))==("table")))and((newChildNewIdx["\x24\x24typeof"])~=(nil))then
                     newFiber=updateSlot(returnFiber,oldFiber,newChildNewIdx,lanes,newIdx)
                else
                     newFiber=updateSlot(returnFiber,oldFiber,newChildNewIdx,lanes)
                end;
                if(newFiber)==(nil)then
                     if(oldFiber)==(nil)then
                         oldFiber=nextOldFiber
                     end;
                    break
                 end;
                if shouldTrackSideEffects then
                     if(oldFiber)and(((newFiber).alternate)==(nil))then
                         deleteChild(returnFiber,oldFiber)
                    end
                 end;
                lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                if(previousNewFiber)==(nil)then
                     resultingFirstChild=newFiber
                 else
                    (previousNewFiber).sibling=newFiber
                 end;
                previousNewFiber=newFiber;
                oldFiber=nextOldFiber;
                newIdx+=1
             end;
            if(newIdx)>(newChildrenCount)then
                 deleteRemainingChildren(returnFiber,oldFiber);
                return resultingFirstChild
             end;
            if(oldFiber)==(nil)then
                 while(newIdx)<=(newChildrenCount)do
                     local newFiber;
                    local newChildNewIdx=newChildren[newIdx];
                    if(((newChildNewIdx)~=(nil))and((type(newChildNewIdx))==("table")))and((newChildNewIdx["\x24\x24typeof"])~=(nil))then
                         newFiber=createChild(returnFiber,newChildNewIdx,lanes,newIdx)
                    else
                         newFiber=createChild(returnFiber,newChildNewIdx,lanes)
                    end;
                    if(newFiber)==(nil)then
                         newIdx+=1;
                        continue
                     end;
                    lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                    if(previousNewFiber)==(nil)then
                         resultingFirstChild=newFiber
                     else
                        (previousNewFiber).sibling=newFiber
                     end;
                    previousNewFiber=newFiber;
                    newIdx+=1
                 end;
                return resultingFirstChild
             end;
            local existingChildren=mapRemainingChildren(returnFiber,oldFiber);
            while(newIdx)<=(newChildrenCount)do
                 local newFiber=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes,newIdx);
                if(newFiber)~=(nil)then
                     if shouldTrackSideEffects then
                         if(newFiber.alternate)~=(nil)then
                             existingChildren[if(newFiber.key)==(nil)then newIdx else newFiber.key]=nil
                         end
                     end;
                    lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                    if(previousNewFiber)==(nil)then
                         resultingFirstChild=newFiber
                     else
                        (previousNewFiber).sibling=newFiber
                     end;
                    previousNewFiber=newFiber
                 end;
                newIdx+=1
             end;
            if shouldTrackSideEffects then
                 for _,child in existingChildren do
                     deleteChild(returnFiber,child)
                end
             end;
            return resultingFirstChild
         end;
        local function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes,iteratorFn)
            if __DEV__ then
                 if(newChildrenIterable.entries)==(iteratorFn)then
                     if not(didWarnAboutMaps)then
                         console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.")
                    end;
                    didWarnAboutMaps=true
                 end;
                local newChildren=iteratorFn(newChildrenIterable);
                if newChildren then
                     local knownKeys;
                    local step=newChildren.next();
                    while not(step.done)do
                         step=newChildren.next();
                        local child=step.value;
                        knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)
                    end
                 end
             end;
            local newChildren=iteratorFn(newChildrenIterable);
            local resultingFirstChild;
            local previousNewFiber;
            local oldFiber=currentFirstChild;
            local lastPlacedIndex=1;
            local newIdx=1;
            local nextOldFiber;
            local step=newChildren.next();
            while((oldFiber)~=(nil))and(not(step.done))do
                 if(oldFiber.index)>(newIdx)then
                     nextOldFiber=oldFiber;
                    oldFiber=nil
                 else
                     nextOldFiber=oldFiber.sibling
                 end;
                local newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes,step.key);
                if(newFiber)==(nil)then
                     if(oldFiber)==(nil)then
                         oldFiber=nextOldFiber
                     end;
                    break
                 end;
                if shouldTrackSideEffects then
                     if(oldFiber)and(((newFiber).alternate)==(nil))then
                         deleteChild(returnFiber,oldFiber)
                    end
                 end;
                lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                if(previousNewFiber)==(nil)then
                     resultingFirstChild=newFiber
                 else
                     previousNewFiber.sibling=newFiber
                 end;
                previousNewFiber=newFiber;
                oldFiber=nextOldFiber;
                newIdx+=1;
                step=newChildren.next()
            end;
            if step.done then
                 deleteRemainingChildren(returnFiber,oldFiber);
                return resultingFirstChild
             end;
            if(oldFiber)==(nil)then
                 while not(step.done)do
                     local newFiber=createChild(returnFiber,step.value,lanes,step.key);
                    if(newFiber)==(nil)then
                         newIdx+=1;
                        step=newChildren.next();
                        continue
                     end;
                    lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                    if(previousNewFiber)==(nil)then
                         resultingFirstChild=newFiber
                     else
                         previousNewFiber.sibling=newFiber
                     end;
                    previousNewFiber=newFiber;
                    newIdx+=1;
                    step=newChildren.next()
                end;
                return resultingFirstChild
             end;
            local existingChildren;
            while not(step.done)do
                 if not(existingChildren)then
                     existingChildren=mapRemainingChildren(returnFiber,oldFiber)
                end;
                local newFiber=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes,step.key);
                if(newFiber)~=(nil)then
                     if shouldTrackSideEffects then
                         if(newFiber.alternate)~=(nil)then
                             if(newFiber.key)==(nil)then
                                 existingChildren[newIdx]=nil
                             else
                                 existingChildren[newFiber.key]=nil
                             end
                         end
                     end;
                    lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);
                    if(previousNewFiber)==(nil)then
                         resultingFirstChild=newFiber
                     else
                         previousNewFiber.sibling=newFiber
                     end;
                    previousNewFiber=newFiber
                 end;
                newIdx+=1;
                step=newChildren.next()
            end;
            if shouldTrackSideEffects then
                 for _,child in existingChildren do
                     deleteChild(returnFiber,child)
                end
             end;
            return resultingFirstChild
         end;
        local function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes)
            if((currentFirstChild)~=(nil))and(((currentFirstChild).tag)==(HostText))then
                 deleteRemainingChildren(returnFiber,(currentFirstChild).sibling);
                local existing=useFiber(currentFirstChild,textContent);
                existing.return_=returnFiber;
                return existing
             end;
            deleteRemainingChildren(returnFiber,currentFirstChild);
            local created=createFiberFromText(textContent,returnFiber.mode,lanes);
            created.return_=returnFiber;
            return created
         end;
        local function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes)
            local key=element.key;
            local child=currentFirstChild;
            while(child)~=(nil)do
                 if(child.key)==(key)then
                     if(child.tag)==(Fragment)then
                         if(element.type)==(REACT_FRAGMENT_TYPE)then
                             deleteRemainingChildren(returnFiber,child.sibling);
                            local existing=useFiber(child,element.props.children);
                            existing.return_=returnFiber;
                            if __DEV__ then
                                 existing._debugSource=element._source;
                                existing._debugOwner=element._owner
                             end;
                            return existing
                         end
                     else
                         if(child.elementType)==(element.type)then
                             deleteRemainingChildren(returnFiber,child.sibling);
                            local existing=useFiber(child,element.props);
                            existing.ref=coerceRef(returnFiber,child,element);
                            existing.return_=returnFiber;
                            if __DEV__ then
                                 existing._debugSource=element._source;
                                existing._debugOwner=element._owner
                             end;
                            return existing
                         end
                     end;
                    deleteRemainingChildren(returnFiber,child);
                    break
                 else
                     deleteChild(returnFiber,child)
                end;
                child=child.sibling
             end;
            if(element.type)==(REACT_FRAGMENT_TYPE)then
                 local created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);
                created.return_=returnFiber;
                return created
             else
                 local created=createFiberFromElement(element,returnFiber.mode,lanes);
                created.ref=coerceRef(returnFiber,currentFirstChild,element);
                created.return_=returnFiber;
                return created
             end
         end;
        local function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes)
            local key=portal.key;
            local child=currentFirstChild;
            while(child)~=(nil)do
                 if(child.key)==(key)then
                     if(((child.tag)==(HostPortal))and((child.stateNode.containerInfo)==(portal.containerInfo)))and((child.stateNode.implementation)==(portal.implementation))then
                         deleteRemainingChildren(returnFiber,child.sibling);
                        local existing=useFiber(child,(portal.children)or({}));
                        existing.return_=returnFiber;
                        return existing
                     else
                         deleteRemainingChildren(returnFiber,child);
                        break
                     end
                 else
                     deleteChild(returnFiber,child)
                end;
                child=child.sibling
             end;
            local created=createFiberFromPortal(portal,returnFiber.mode,lanes);
            created.return_=returnFiber;
            return created
         end;
        local function reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes)
            local typeOfNewChild=type(newChild);
            local isUnkeyedTopLevelFragment=((((newChild)~=(nil))and((typeOfNewChild)==("table")))and((newChild.type)==(REACT_FRAGMENT_TYPE)))and((newChild.key)==(nil));
            if isUnkeyedTopLevelFragment then
                 newChild=newChild.props.children;
                typeOfNewChild=type(newChild)
            end;
            local newChildIsArray=isArray(newChild);
            local isObject=(((newChild)~=(nil))and((typeOfNewChild)==("table")))and(not(newChildIsArray));
            if isObject then
                 local newChildTypeof=newChild["\x24\x24typeof"];
                if(newChildTypeof)==(REACT_ELEMENT_TYPE)then
                     return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes))
                elseif(newChildTypeof)==(REACT_PORTAL_TYPE)then
                     return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes))
                elseif(newChildTypeof)==(REACT_LAZY_TYPE)then
                     if enableLazyElements then
                         local payload=newChild._payload;
                        local init=newChild._init;
                        return reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes)
                    end
                 end
             elseif newChildIsArray then
                 return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes)
            elseif((typeOfNewChild)==("string"))or((typeOfNewChild)==("number"))then
                 return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,tostring(newChild),lanes))
            end;
            local newChildIteratorFn=getIteratorFn(newChild);
            if newChildIteratorFn then
                 return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes,newChildIteratorFn)
            end;
            if __DEV__ then
                 if(typeOfNewChild)==("function")then
                     warnOnFunctionType(returnFiber)
                end
             end;
            if((newChild)==(nil))and(not(isUnkeyedTopLevelFragment))then
                 local shouldFallThrough=false;
                if(shouldFallThrough)and((((((returnFiber.tag)==(ClassComponent))or((returnFiber.tag)==(FunctionComponent)))or((returnFiber.tag)==(ForwardRef)))or((returnFiber.tag)==(SimpleMemoComponent))))then
                     invariant(false,"%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return nil.",(getComponentName(returnFiber.type))or("Component"))
                end
             end;
            return deleteRemainingChildren(returnFiber,currentFirstChild)
        end;
        return reconcileChildFibers
     end;
    exports.reconcileChildFibers=ChildReconciler(true);
    exports.mountChildFibers=ChildReconciler(false);
    exports.cloneChildFibers=function(current,workInProgress)
        if(workInProgress.child)==(nil)then
             return
         end;
        local currentChild=workInProgress.child;
        local newChild=createWorkInProgress(currentChild,currentChild.pendingProps);
        workInProgress.child=newChild;
        newChild.return_=workInProgress;
        while(currentChild.sibling)~=(nil)do
             currentChild=currentChild.sibling;
            newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);
            newChild=newChild.sibling;
            newChild.return_=workInProgress
         end;
        newChild.sibling=nil
     end;
    exports.resetChildFibers=function(workInProgress,lanes)
        local child=workInProgress.child;
        while(child)~=(nil)do
             resetWorkInProgress(child,lanes);
            child=child.sibling
         end
     end;
    return exports

 end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberClassComponent.new.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberClassComponent.new",function()
    local __DEV__=_G.__DEV__;
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.luau-polyfill");
    local Object=LuauPolyfill.Object;
    local console=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").console;
    local ReactInternalTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactInternalTypes");
    type("not printable... yet");
    local ReactFiberLane=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLane");
    type("not printable... yet");
    local ReactUpdateQueue=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactUpdateQueue.new");
    type("not printable... yet");
    local ReactTypes=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared");
    type("not printable... yet");
    local React=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react");
    local ReactFiberFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberFlags");
    local Update=ReactFiberFlags.Update;
    local Snapshot=ReactFiberFlags.Snapshot;
    local MountLayoutDev=ReactFiberFlags.MountLayoutDev;
    local ReactFeatureFlags=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactFeatureFlags;
    local debugRenderPhaseSideEffectsForStrictMode=ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode;
    local disableLegacyContext=ReactFeatureFlags.disableLegacyContext;
    local enableDebugTracing=ReactFeatureFlags.enableDebugTracing;
    local enableSchedulingProfiler=ReactFeatureFlags.enableSchedulingProfiler;
    local warnAboutDeprecatedLifecycles=ReactFeatureFlags.warnAboutDeprecatedLifecycles;
    local enableDoubleInvokingEffects=ReactFeatureFlags.enableDoubleInvokingEffects;
    local ReactStrictModeWarnings=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactStrictModeWarnings.new");
    local isMounted=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberTreeReflection").isMounted;
    local ReactInstanceMap=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactInstanceMap;
    local getInstance=ReactInstanceMap.get;
    local setInstance=ReactInstanceMap.set;
    local shallowEqual=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").shallowEqual;
    local getComponentName=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").getComponentName;
    local UninitializedState=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").UninitializedState;
    local describeError=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").describeError;
    local ReactSymbols=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ReactSymbols;
    local REACT_CONTEXT_TYPE=ReactSymbols.REACT_CONTEXT_TYPE;
    local REACT_PROVIDER_TYPE=ReactSymbols.REACT_PROVIDER_TYPE;
    local resolveDefaultProps=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberLazyComponent.new").resolveDefaultProps;
    local ReactTypeOfMode=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactTypeOfMode");
    local DebugTracingMode=ReactTypeOfMode.DebugTracingMode;
    local StrictMode=ReactTypeOfMode.StrictMode;
    local enqueueUpdate=ReactUpdateQueue.enqueueUpdate;
    local processUpdateQueue=ReactUpdateQueue.processUpdateQueue;
    local checkHasForceUpdateAfterProcessing=ReactUpdateQueue.checkHasForceUpdateAfterProcessing;
    local resetHasForceUpdateBeforeProcessing=ReactUpdateQueue.resetHasForceUpdateBeforeProcessing;
    local createUpdate=ReactUpdateQueue.createUpdate;
    local ReplaceState=ReactUpdateQueue.ReplaceState;
    local ForceUpdate=ReactUpdateQueue.ForceUpdate;
    local initializeUpdateQueue=ReactUpdateQueue.initializeUpdateQueue;
    local cloneUpdateQueue=ReactUpdateQueue.cloneUpdateQueue;
    local NoLanes=ReactFiberLane.NoLanes;
    local ReactFiberContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberContext.new");
    local cacheContext=ReactFiberContext.cacheContext;
    local getMaskedContext=ReactFiberContext.getMaskedContext;
    local getUnmaskedContext=ReactFiberContext.getUnmaskedContext;
    local hasContextChanged=ReactFiberContext.hasContextChanged;
    local emptyContextObject=ReactFiberContext.emptyContextObject;
    local ReactFiberNewContext=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberNewContext.new");
    local readContext=ReactFiberNewContext.readContext;
    local DebugTracing=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.DebugTracing");
    local logForceUpdateScheduled=DebugTracing.logForceUpdateScheduled;
    local logStateUpdateScheduled=DebugTracing.logStateUpdateScheduled;
    local ConsolePatchingDev=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.shared").ConsolePatchingDev;
    local disableLogs=ConsolePatchingDev.disableLogs;
    local reenableLogs=ConsolePatchingDev.reenableLogs;
    local SchedulingProfiler=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.SchedulingProfiler");
    local markForceUpdateScheduled=SchedulingProfiler.markForceUpdateScheduled;
    local markStateUpdateScheduled=SchedulingProfiler.markStateUpdateScheduled;
    local fakeInternalInstance={};
    local emptyRefsObject=React.Component:extend("").__refs;
    local didWarnAboutStateAssignmentForComponent;
    local didWarnAboutUninitializedState;
    local didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    local didWarnAboutLegacyLifecyclesAndDerivedState;
    local _didWarnAboutUndefinedDerivedState;
    local warnOnUndefinedDerivedState;
    local warnOnInvalidCallback;
    local didWarnAboutDirectlyAssigningPropsToState;
    local didWarnAboutContextTypeAndContextTypes;
    local didWarnAboutInvalidateContextType;
    if __DEV__ then
         didWarnAboutStateAssignmentForComponent={};
        didWarnAboutUninitializedState={};
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate={};
        didWarnAboutLegacyLifecyclesAndDerivedState={};
        didWarnAboutDirectlyAssigningPropsToState={};
        _didWarnAboutUndefinedDerivedState={};
        didWarnAboutContextTypeAndContextTypes={};
        didWarnAboutInvalidateContextType={};
        local didWarnOnInvalidCallback={};
        function warnOnInvalidCallback(callback,callerName)
            if((callback)==(nil))or((type(callback))==("function"))then
                 return
             end;
            local key=(callerName)..(("_")..(tostring(callback)));
            if not(didWarnOnInvalidCallback[key])then
                 didWarnOnInvalidCallback[key]=true;
                console.error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callerName,tostring(callback))
            end
         end;
        function warnOnUndefinedDerivedState(type_,partialState)
            
        end
     end;
    local function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps)
        local prevState=workInProgress.memoizedState;
        if __DEV__ then
             if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                 disableLogs();
                local ok,result=xpcall(getDerivedStateFromProps,describeError,nextProps,prevState);
                reenableLogs();
                if not(ok)then
                     error(result)
                end
             end
         end;
        local partialState=getDerivedStateFromProps(nextProps,prevState);
        if __DEV__ then
             warnOnUndefinedDerivedState(ctor,partialState)
        end;
        local memoizedState=if(partialState)==(nil)then prevState else Object.assign({},prevState,partialState);
        workInProgress.memoizedState=memoizedState;
        if(workInProgress.lanes)==(NoLanes)then
             local updateQueue=workInProgress.updateQueue;
            updateQueue.baseState=memoizedState
         end
     end;
    local classComponentUpdater;
    local function initializeClassComponentUpdater()
        local ReactFiberWorkLoop=tkpack.include("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberWorkLoop.new");
        local requestEventTime=ReactFiberWorkLoop.requestEventTime;
        local requestUpdateLane=ReactFiberWorkLoop.requestUpdateLane;
        local scheduleUpdateOnFiber=ReactFiberWorkLoop.scheduleUpdateOnFiber;
        classComponentUpdater={["isMounted"]=isMounted,["enqueueSetState"]=function(inst,payload,callback)
            local fiber=getInstance(inst);
            local eventTime=requestEventTime();
            local lane=requestUpdateLane(fiber);
            local update=createUpdate(eventTime,lane,payload,callback);
            if(callback)~=(nil)then
                 if __DEV__ then
                     warnOnInvalidCallback(callback,"setState")
                end
             end;
            enqueueUpdate(fiber,update);
            scheduleUpdateOnFiber(fiber,lane,eventTime);
            if __DEV__ then
                 if enableDebugTracing then
                     if(bit32.band(fiber.mode,DebugTracingMode))~=(0)then
                         local name=(getComponentName(fiber.type))or("Unknown");
                        logStateUpdateScheduled(name,lane,payload)
                    end
                 end
             end;
            if enableSchedulingProfiler then
                 markStateUpdateScheduled(fiber,lane)
            end
         end,["enqueueReplaceState"]=function(inst,payload,callback)
            local fiber=getInstance(inst);
            local eventTime=requestEventTime();
            local lane=requestUpdateLane(fiber);
            local update=createUpdate(eventTime,lane,payload,callback);
            update.tag=ReplaceState;
            if(callback)~=(nil)then
                 if __DEV__ then
                     warnOnInvalidCallback(callback,"replaceState")
                end
             end;
            enqueueUpdate(fiber,update);
            scheduleUpdateOnFiber(fiber,lane,eventTime);
            if __DEV__ then
                 if enableDebugTracing then
                     if(bit32.band(fiber.mode,DebugTracingMode))~=(0)then
                         local name=(getComponentName(fiber.type))or("Unknown");
                        logStateUpdateScheduled(name,lane,payload)
                    end
                 end
             end;
            if enableSchedulingProfiler then
                 markStateUpdateScheduled(fiber,lane)
            end
         end,["enqueueForceUpdate"]=function(inst,callback)
            local fiber=getInstance(inst);
            local eventTime=requestEventTime();
            local lane=requestUpdateLane(fiber);
            local update=createUpdate(eventTime,lane,nil,callback);
            update.tag=ForceUpdate;
            if(callback)~=(nil)then
                 if __DEV__ then
                     warnOnInvalidCallback(callback,"forceUpdate")
                end
             end;
            enqueueUpdate(fiber,update);
            scheduleUpdateOnFiber(fiber,lane,eventTime);
            if __DEV__ then
                 if enableDebugTracing then
                     if(bit32.band(fiber.mode,DebugTracingMode))~=(0)then
                         local name=(getComponentName(fiber.type))or("Unknown");
                        logForceUpdateScheduled(name,lane)
                    end
                 end
             end;
            if enableSchedulingProfiler then
                 markForceUpdateScheduled(fiber,lane)
            end
         end}
    end;
    local function getClassComponentUpdater()
        if(classComponentUpdater)==(nil)then
             initializeClassComponentUpdater()
        end;
        return classComponentUpdater
     end;
    function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)
        local instance=workInProgress.stateNode;
        if((instance.shouldComponentUpdate)~=(nil))and((type(instance.shouldComponentUpdate))==("function"))then
             if __DEV__ then
                 if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                     disableLogs();
                    local ok,result=xpcall(instance.shouldComponentUpdate,describeError,instance,newProps,newState,nextContext);
                    reenableLogs();
                    if not(ok)then
                         error(result)
                    end
                 end
             end;
            local shouldUpdate=instance:shouldComponentUpdate(newProps,newState,nextContext);
            if __DEV__ then
                 if(shouldUpdate)==(nil)then
                     console.error("%s.shouldComponentUpdate(): Returned nil instead of a boolean value. Make sure to return true or false.",(getComponentName(ctor))or("Component"))
                end
             end;
            return shouldUpdate
         end;
        if((type(ctor))==("table"))and(ctor.isPureReactComponent)then
             return((not(shallowEqual(oldProps,newProps)))or(not(shallowEqual(oldState,newState))))
        end;
        return true
     end;
    local function checkClassInstance(workInProgress,ctor,newProps)
        local instance=workInProgress.stateNode;
        if __DEV__ then
             local name=(getComponentName(ctor))or("Component");
            local renderPresent=instance.render;
            if not(renderPresent)then
                 if(type(ctor.render))==("function")then
                     console.error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?",name)
                else
                     console.error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.",name)
                end
             end;
            if((instance.getInitialState)and(not(instance.getInitialState.isReactClassApproved)))and(not(instance.state))then
                 console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",name)
            end;
            if(instance.getDefaultProps)and(not(instance.getDefaultProps.isReactClassApproved))then
                 console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",name)
            end;
            if(instance.propTypes)and(not(ctor.propTypes))then
                 console.error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.",name)
            end;
            if(instance.contextType)and(not(ctor.contextType))then
                 console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.",name)
            end;
            if disableLegacyContext then
                 if ctor.childContextTypes then
                     console.error("%s uses the legacy childContextTypes API which is no longer supported. Use React.createContext() instead.",name)
                end;
                if ctor.contextTypes then
                     console.error("%s uses the legacy contextTypes API which is no longer supported. Use React.createContext() with static contextType instead.",name)
                end
             else
                 if(instance.contextTypes)and(not(ctor.contextTypes))then
                     console.error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.",name)
                end;
                if((((type(ctor))==("table"))and(ctor.contextType))and(ctor.contextTypes))and(not(didWarnAboutContextTypeAndContextTypes[ctor]))then
                     didWarnAboutContextTypeAndContextTypes[ctor]=true;
                    console.error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.",name)
                end
             end;
            if(type(instance.componentShouldUpdate))==("function")then
                 console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",name)
            end;
            if(((type(ctor))==("table"))and(ctor.isPureReactComponent))and((instance.shouldComponentUpdate)~=(nil))then
                 console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",(getComponentName(ctor))or("A pure component"))
            end;
            if(type(instance.componentDidUnmount))==("function")then
                 console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",name)
            end;
            if(type(instance.componentDidReceiveProps))==("function")then
                 console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",name)
            end;
            if(type(instance.componentWillRecieveProps))==("function")then
                 console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",name)
            end;
            if(type(instance.UNSAFE_componentWillRecieveProps))==("function")then
                 console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",name)
            end;
            local hasMutatedProps=(instance.props)~=(newProps);
            if((instance.props)~=(nil))and(hasMutatedProps)then
                 console.error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",name,name)
            end;
            if rawget(instance,"defaultProps")then
                 console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",name,name)
            end;
            if(((type(instance.getSnapshotBeforeUpdate))==("function"))and((type(instance.componentDidUpdate))~=("function")))and(not(didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor]))then
                 didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor]=true;
                console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",getComponentName(ctor))
            end;
            local state=instance.state;
            if((state)~=(nil))and((type(state))~=("table"))then
                 console.error("%s.state: must be set to an object or nil",name)
            end;
            if(((type(ctor))==("table"))and((type(instance.getChildContext))==("function")))and((type(ctor.childContextTypes))~=("table"))then
                 console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",name)
            end
         end
     end;
    local function adoptClassInstance(workInProgress,instance)
        instance.__updater=getClassComponentUpdater();
        workInProgress.stateNode=instance;
        setInstance(instance,workInProgress);
        if __DEV__ then
             instance._reactInternalInstance=fakeInternalInstance
         end
     end;
    local function constructClassInstance(workInProgress,ctor,props)
        local isLegacyContextConsumer=false;
        local unmaskedContext=emptyContextObject;
        local context=emptyContextObject;
        local contextType=ctor.contextType;
        if __DEV__ then
             if(ctor["contextType"])~=(nil)then
                 local isValid=((contextType)==(nil))or((((contextType["\x24\x24typeof"])==(REACT_CONTEXT_TYPE))and((contextType._context)==(nil))));
                if(not(isValid))and(not(didWarnAboutInvalidateContextType[ctor]))then
                     didWarnAboutInvalidateContextType[ctor]=true;
                    local addendum="";
                    if(contextType)==(nil)then
                         addendum=" However, it is set to nil. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
                    elseif(type(contextType))~=("table")then
                         addendum=(" However, it is set to a ")..((type(contextType))..("."))
                    elseif(contextType["\x24\x24typeof"])==(REACT_PROVIDER_TYPE)then
                         addendum=" Did you accidentally pass the Context.Provider instead?"
                    elseif(contextType._context)~=(nil)then
                         addendum=" Did you accidentally pass the Context.Consumer instead?"
                    else
                         addendum..=" However, it is set to an object with keys {";
                        for key,_ in contextType do
                             addendum..=(key)..(", ")
                        end;
                        addendum..="}."
                    end;
                    console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",(getComponentName(ctor))or("Component"),addendum)
                end
             end
         end;
        if((contextType)~=(nil))and((type(contextType))==("table"))then
             context=readContext(contextType)
        elseif not(disableLegacyContext)then
             unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);
            local contextTypes=ctor.contextTypes;
            isLegacyContextConsumer=(contextTypes)~=(nil);
            context=((isLegacyContextConsumer)and(getMaskedContext(workInProgress,unmaskedContext)))or(emptyContextObject)
        end;
        if __DEV__ then
             if(debugRenderPhaseSideEffectsForStrictMode)and((bit32.band(workInProgress.mode,StrictMode))~=(0))then
                 disableLogs();
                local ok,result=xpcall(ctor.__ctor,describeError,props,context);
                reenableLogs();
                if not(ok)then
                     error(result)
                end
             end
         end;
        local instance=ctor.__ctor(props,context);
        workInProgress.memoizedState=instance.state;
        local state=workInProgress.memoizedState;
        adoptClassInstance(workInProgress,instance);
        if __DEV__ then
             if((type(ctor.getDerivedStateFromProps))==("function"))and((state)==(UninitializedState))then
                 local componentName=(getComponentName(ctor))or("Component");
                if not(didWarnAboutUninitializedState[componentName])then
                     didWarnAboutUninitializedState[componentName]=true;
                    console.error("`%s` uses `getDerivedStateFromProps` but its initial state has not been initialized. This is not recommended. Instead, define the initial state by passing an object to `self:setState` in the `init` method of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",componentName,componentName)
                end
             end;
            if((type(ctor.getDerivedStateFromProps))==("function"))or((type(instance.getSnapshotBeforeUpdate))==("function"))then
                 local foundWillMountName;
                local foundWillReceivePropsName;
                local foundWillUpdateName;
                if(type(instance.componentWillMount))==("function")then
                     foundWillMountName="componentWillMount"
                elseif(type(instance.UNSAFE_componentWillMount))==("function")then
                     foundWillMountName="UNSAFE_componentWillMount"
                end;
                if(type(instance.componentWillReceiveProps))==("function")then
                     foundWillReceivePropsName="componentWillReceiveProps"
                elseif(type(instance.UNSAFE_componentWillReceiveProps))==("function")then
                     foundWillReceivePropsName="UNSAFE_componentWillReceiveProps"
                end;
                if(type(instance.componentWillUpdate))==("function")then
                     foundWillUpdateName="componentWillUpdate"
                elseif(type(instance.UNSAFE_componentWillUpdate))==("function")then
                     foundWillUpdateName="UNSAFE_componentWillUpdate"
                end;
                if(((foundWillMountName)~=(nil))or((foundWillReceivePropsName)~=(nil)))or((foundWillUpdateName)~=(nil))then
                     local componentName=(getComponentName(ctor))or("Component");
                    local newApiName;
                    if(type(ctor.getDerivedStateFromProps))==("function")then
                         newApiName="getDerivedStateFromProps()"
                    else
                         newApiName="getSnapshotBeforeUpdate()"
                    end;
                    local willMountName;
                    if(foundWillMountName)~=(nil)then
                         willMountName=(("\x0a  ")..(tostring(foundWillMountName)))
                    else
                         willMountName=""
                    end;
                    local willReceievePropsName;
                    if(foundWillReceivePropsName)~=(nil)then
                         willReceievePropsName=(("\x0a  ")..(tostring(foundWillReceivePropsName)))
                    else
                         willReceievePropsName=""
                    end;
                    local willUpdateName;
                    if(foundWillUpdateName)~=(nil)then
                         willUpdateName=("\x0a  ")..(tostring(foundWillUpdateName))
                    else
                         willUpdateName=""
                    end;
                    if not(didWarnAboutLegacyLifecyclesAndDerivedState[componentName])then
                         didWarnAboutLegacyLifecyclesAndDerivedState[componentName]=true;
                        console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\x0a\x0a%s uses %s but also contains the following legacy lifecycles:%s%s%s\x0a\x0aThe above lifecycles should be removed. Learn more about this warning here:\x0ahttps://reactjs.org/link/unsafe-component-lifecycles",componentName,newApiName,willMountName,willReceievePropsName,willUpdateName)
                    end
                 end
             end
         end;
        if isLegacyContextConsumer then
             cacheContext(workInProgress,unmaskedContext,context)
        end;
        return instance
     end;
    local function callComponentWillMount(workInProgress,instance)
        local oldState=instance.state;
        if((instance.componentWillMount)~=(nil))and((type(instance.componentWillMount))==("function"))then
             instance:componentWillMount()
        end;
        if((instance.UNSAFE_componentWillMount)~=(nil))and((type(instance.UNSAFE_componentWillMount))==("function"))then
             instance:UNSAFE_componentWillMount()
        end;
        if(oldState)~=(instance.state)then
             if __DEV__ then
                 console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",(getComponentName(workInProgress.type))or("Component"))
            end;
            getClassComponentUpdater().enqueueReplaceState(instance,instance.state)
        end
     end;
    function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext)
        local oldState=instance.state;
        if((instance.componentWillReceiveProps)~=(nil))and((type(instance.componentWillReceiveProps))==("function"))then
             instance:componentWillReceiveProps(newProps,nextContext)
        end;
        if((instance.UNSAFE_componentWillReceiveProps)~=(nil))and((type(instance.UNSAFE_componentWillReceiveProps))==("function"))then
             instance:UNSAFE_componentWillReceiveProps(newProps,nextContext)
        end;
        if(instance.state)~=(oldState)then
             if __DEV__ then
                 local componentName=(getComponentName(workInProgress.type))or("Component");
                if not(didWarnAboutStateAssignmentForComponent[componentName])then
                     didWarnAboutStateAssignmentForComponent[componentName]=true;
                    console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",componentName)
                end
             end;
            getClassComponentUpdater().enqueueReplaceState(instance,instance.state)
        end
     end;
    local function mountClassInstance(workInProgress,ctor,newProps,renderLanes)
        if __DEV__ then
             checkClassInstance(workInProgress,ctor,newProps)
        end;
        local instance=workInProgress.stateNode;
        instance.props=newProps;
        instance.state=workInProgress.memoizedState;
        instance.__refs=emptyRefsObject;
        initializeUpdateQueue(workInProgress);
        local contextType;
        if(type(ctor))==("table")then
             contextType=ctor.contextType
         end;
        if((contextType)~=(nil))and((type(contextType))==("table"))then
             instance.context=readContext(contextType)
        elseif disableLegacyContext then
             instance.context=emptyContextObject
         else
             local unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);
            instance.context=getMaskedContext(workInProgress,unmaskedContext)
        end;
        if __DEV__ then
             if(instance.state)==(newProps)then
                 local componentName=(getComponentName(ctor))or("Component");
                if not(didWarnAboutDirectlyAssigningPropsToState[componentName])then
                     didWarnAboutDirectlyAssigningPropsToState[componentName]=true;
                    console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",componentName)
                end
             end;
            if(bit32.band(workInProgress.mode,StrictMode))~=(0)then
                 ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance)
            end;
            if warnAboutDeprecatedLifecycles then
                 ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance)
            end
         end;
        processUpdateQueue(workInProgress,newProps,instance,renderLanes);
        instance.state=workInProgress.memoizedState;
        local typeofCtor=type(ctor);
        local getDerivedStateFromProps;
        if(type(ctor))==("table")then
             getDerivedStateFromProps=ctor.getDerivedStateFromProps
         end;
        if((getDerivedStateFromProps)~=(nil))and((type(getDerivedStateFromProps))==("function"))then
             applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);
            instance.state=workInProgress.memoizedState
         end;
        if((((typeofCtor)==("table"))and((type(ctor.getDerivedStateFromProps))~=("function")))and((type(instance.getSnapshotBeforeUpdate))~=("function")))and((((type(instance.UNSAFE_componentWillMount))==("function"))or((type(instance.componentWillMount))==("function"))))then
             callComponentWillMount(workInProgress,instance);
            processUpdateQueue(workInProgress,newProps,instance,renderLanes);
            instance.state=workInProgress.memoizedState
         end;
        if(type(instance.componentDidMount))==("function")then
             if(__DEV__)and(enableDoubleInvokingEffects)then
                 workInProgress.flags=bit32.bor(workInProgress.flags,bit32.bor(MountLayoutDev,Update))
            else
                 workInProgress.flags=bit32.bor(workInProgress.flags,Update)
            end
         end
     end;
    function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes)
        local instance=workInProgress.stateNode;
        local oldProps=workInProgress.memoizedProps;
        instance.props=oldProps;
        local oldContext=instance.context;
        local contextType=ctor.contextType;
        local nextContext=emptyContextObject;
        if((contextType)~=(nil))and((type(contextType))==("table"))then
             nextContext=readContext(contextType)
        elseif not(disableLegacyContext)then
             local nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);
            nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext)
        end;
        local getDerivedStateFromProps=ctor.getDerivedStateFromProps;
        local hasNewLifecycles=((type(getDerivedStateFromProps))==("function"))or((type(instance.getSnapshotBeforeUpdate))==("function"));
        if(not(hasNewLifecycles))and((((type(instance.UNSAFE_componentWillReceiveProps))==("function"))or((type(instance.componentWillReceiveProps))==("function"))))then
             if((oldProps)~=(newProps))or((oldContext)~=(nextContext))then
                 callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext)
            end
         end;
        resetHasForceUpdateBeforeProcessing();
        local oldState=workInProgress.memoizedState;
        instance.state=oldState;
        local newState=oldState;
        processUpdateQueue(workInProgress,newProps,instance,renderLanes);
        newState=workInProgress.memoizedState;
        if((((oldProps)==(newProps))and((oldState)==(newState)))and(not(hasContextChanged())))and(not(checkHasForceUpdateAfterProcessing()))then
             if(type(instance.componentDidMount))==("function")then
                 if(__DEV__)and(enableDoubleInvokingEffects)then
                     workInProgress.flags=bit32.bor(workInProgress.flags,MountLayoutDev,Update)
                else
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            return false
         end;
        if((getDerivedStateFromProps)~=(nil))and((type(getDerivedStateFromProps))==("function"))then
             applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);
            newState=workInProgress.memoizedState
         end;
        local shouldUpdate=(checkHasForceUpdateAfterProcessing())or(checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext));
        if shouldUpdate then
             if(not(hasNewLifecycles))and((((type(instance.UNSAFE_componentWillMount))==("function"))or((type(instance.componentWillMount))==("function"))))then
                 if(type(instance.componentWillMount))==("function")then
                     instance:componentWillMount()
                end;
                if(type(instance.UNSAFE_componentWillMount))==("function")then
                     instance:UNSAFE_componentWillMount()
                end
             end;
            if(type(instance.componentDidMount))==("function")then
                 if(__DEV__)and(enableDoubleInvokingEffects)then
                     workInProgress.flags=bit32.bor(workInProgress.flags,MountLayoutDev,Update)
                else
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end
         else
             if(type(instance.componentDidMount))==("function")then
                 if(__DEV__)and(enableDoubleInvokingEffects)then
                     workInProgress.flags=bit32.bor(workInProgress.flags,MountLayoutDev,Update)
                else
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            workInProgress.memoizedProps=newProps;
            workInProgress.memoizedState=newState
         end;
        instance.props=newProps;
        instance.state=newState;
        instance.context=nextContext;
        return shouldUpdate
     end;
    local function updateClassInstance(current,workInProgress,ctor,newProps,renderLanes)
        local instance=workInProgress.stateNode;
        cloneUpdateQueue(current,workInProgress);
        local unresolvedOldProps=workInProgress.memoizedProps;
        local oldProps=if(workInProgress.type)==(workInProgress.elementType)then unresolvedOldProps else resolveDefaultProps(workInProgress.type,unresolvedOldProps);
        instance.props=oldProps;
        local unresolvedNewProps=workInProgress.pendingProps;
        local oldContext=instance.context;
        local contextType;
        local getDerivedStateFromProps;
        if(type(ctor))==("table")then
             contextType=ctor.contextType;
            getDerivedStateFromProps=ctor.getDerivedStateFromProps
         end;
        local nextContext=emptyContextObject;
        if(type(contextType))==("table")then
             nextContext=readContext(contextType)
        elseif not(disableLegacyContext)then
             local nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);
            nextContext=getMaskedContext(workInProgress,nextUnmaskedContext)
        end;
        local hasNewLifecycles=((((getDerivedStateFromProps)~=(nil))and((type(getDerivedStateFromProps))==("function"))))or((((instance.getSnapshotBeforeUpdate)~=(nil))and((type(instance.getSnapshotBeforeUpdate))==("function"))));
        if(not(hasNewLifecycles))and((((((instance.UNSAFE_componentWillReceiveProps)~=(nil))and((type(instance.UNSAFE_componentWillReceiveProps))==("function"))))or((((instance.componentWillReceiveProps)~=(nil))and((type(instance.componentWillReceiveProps))==("function"))))))then
             if((unresolvedOldProps)~=(unresolvedNewProps))or((oldContext)~=(nextContext))then
                 callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext)
            end
         end;
        resetHasForceUpdateBeforeProcessing();
        local oldState=workInProgress.memoizedState;
        instance.state=oldState;
        local newState=instance.state;
        processUpdateQueue(workInProgress,newProps,instance,renderLanes);
        newState=workInProgress.memoizedState;
        if((((unresolvedOldProps)==(unresolvedNewProps))and((oldState)==(newState)))and(not(hasContextChanged())))and(not(checkHasForceUpdateAfterProcessing()))then
             if((instance.componentDidUpdate)~=(nil))and((type(instance.componentDidUpdate))==("function"))then
                 if((unresolvedOldProps)~=(current.memoizedProps))or((oldState)~=(current.memoizedState))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            if((instance.getSnapshotBeforeUpdate)~=(nil))and((type(instance.getSnapshotBeforeUpdate))==("function"))then
                 if((unresolvedOldProps)~=(current.memoizedProps))or((oldState)~=(current.memoizedState))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Snapshot)
                end
             end;
            return false
         end;
        if((getDerivedStateFromProps)~=(nil))and((type(getDerivedStateFromProps))==("function"))then
             applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);
            newState=workInProgress.memoizedState
         end;
        local shouldUpdate=(checkHasForceUpdateAfterProcessing())or(checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext));
        if shouldUpdate then
             if(not(hasNewLifecycles))and((((((instance.UNSAFE_componentWillUpdate)~=(nil))and((type(instance.UNSAFE_componentWillUpdate))==("function"))))or((((instance.componentWillUpdate)~=(nil))and((type(instance.componentWillUpdate))==("function"))))))then
                 if((instance.componentWillUpdate)~=(nil))and((type(instance.componentWillUpdate))==("function"))then
                     instance:componentWillUpdate(newProps,newState,nextContext)
                end;
                if((instance.UNSAFE_componentWillUpdate)~=(nil))and((type(instance.UNSAFE_componentWillUpdate))==("function"))then
                     instance:UNSAFE_componentWillUpdate(newProps,newState,nextContext)
                end
             end;
            if((instance.componentDidUpdate)~=(nil))and((type(instance.componentDidUpdate))==("function"))then
                 workInProgress.flags=bit32.bor(workInProgress.flags,Update)
            end;
            if((instance.getSnapshotBeforeUpdate)~=(nil))and((type(instance.getSnapshotBeforeUpdate))==("function"))then
                 workInProgress.flags=bit32.bor(workInProgress.flags,Snapshot)
            end
         else
             if((instance.componentDidUpdate)~=(nil))and((type(instance.componentDidUpdate))==("function"))then
                 if((unresolvedOldProps)~=(current.memoizedProps))or((oldState)~=(current.memoizedState))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Update)
                end
             end;
            if((instance.getSnapshotBeforeUpdate)~=(nil))and((type(instance.getSnapshotBeforeUpdate))==("function"))then
                 if((unresolvedOldProps)~=(current.memoizedProps))or((oldState)~=(current.memoizedState))then
                     workInProgress.flags=bit32.bor(workInProgress.flags,Snapshot)
                end
             end;
            workInProgress.memoizedProps=newProps;
            workInProgress.memoizedState=newState
         end;
        instance.props=newProps;
        instance.state=newState;
        instance.context=nextContext;
        return shouldUpdate
     end;
    return{["adoptClassInstance"]=adoptClassInstance,["constructClassInstance"]=constructClassInstance,["mountClassInstance"]=mountClassInstance,["resumeMountClassInstance"]=resumeMountClassInstance,["updateClassInstance"]=updateClassInstance,["applyDerivedStateFromProps"]=applyDerivedStateFromProps,["emptyRefsObject"]=emptyRefsObject}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_scheduler@17.2.1\scheduler\src\forks\SchedulerHostConfig.default.luau
 tkpack.declare("game.Packages._Index.jsdotlua_scheduler@17.2.1.scheduler.forks.SchedulerHostConfig.default",function()
    local LuauPolyfill=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.luau-polyfill");
    type("not printable... yet");
    local Object=LuauPolyfill.Object;
    local Shared=tkpack.include("game.Packages._Index.jsdotlua_scheduler@17.2.1.shared");
    local console=Shared.console;
    local errorToString=Shared.errorToString;
    local describeError=Shared.describeError;
    local getCurrentTime=function()
        return(os.clock())*(1000)
    end;
    local setTimeout=LuauPolyfill.setTimeout;
    local clearTimeout=LuauPolyfill.clearTimeout;
    local isMessageLoopRunning=false;
    local scheduledHostCallback;
    local taskTimeoutID=Object.None;
    local yieldInterval=15;
    local deadline=0;
    local function shouldYieldToHost()
        return(getCurrentTime())>=(deadline)
    end;
    local function requestPaint()
        
    end;
    local function forceFrameRate(fps)
        if((fps)<(0))or((fps)>(125))then
             console.warn("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return
         end;
        if(fps)>(0)then
             yieldInterval=math.floor((1000)/(fps))
        else
             yieldInterval=5
         end
     end;
    local function performWorkUntilDeadline()
        if(scheduledHostCallback)~=(nil)then
             local currentTime=getCurrentTime();
            deadline=(currentTime)+(yieldInterval);
            local hasTimeRemaining=true;
            local ok,result;
            local function doWork()
                local hasMoreWork=(scheduledHostCallback)(hasTimeRemaining,currentTime);
                if not(hasMoreWork)then
                     isMessageLoopRunning=false;
                    scheduledHostCallback=nil
                 else
                     task.delay(0,performWorkUntilDeadline)
                end;
                return nil
             end;
            if not(_G.__YOLO__)then
                 ok,result=xpcall(doWork,describeError)
            else
                 result=doWork();
                ok=true
             end;
            if not(ok)then
                 task.delay(0,performWorkUntilDeadline);
                error(errorToString(result))
            end
         else
             isMessageLoopRunning=false
         end
     end;
    local function wrapPerformWorkWithCoroutine(performWork)
        local co=coroutine.create(function()
            while true do
                 local wrapped=coroutine.wrap(performWork);
                local ok,result=pcall(wrapped);
                coroutine.yield(ok,result)
            end
         end);
        return function()
            local _,ok,result=coroutine.resume(co);
            if not(ok)then
                 error(result)
            end
         end
     end;
    performWorkUntilDeadline=wrapPerformWorkWithCoroutine(performWorkUntilDeadline);
    local function requestHostCallback(callback)
        scheduledHostCallback=callback;
        if not(isMessageLoopRunning)then
             isMessageLoopRunning=true;
            task.delay(0,performWorkUntilDeadline)
        end
     end;
    local function cancelHostCallback()
        scheduledHostCallback=nil
     end;
    local function requestHostTimeout(callback,ms)
        taskTimeoutID=setTimeout(function()
            callback(getCurrentTime())
        end,ms)
    end;
    local function cancelHostTimeout()
        clearTimeout(taskTimeoutID);
        taskTimeoutID=Object.None
     end;
    return{["requestHostCallback"]=requestHostCallback,["cancelHostCallback"]=cancelHostCallback,["requestHostTimeout"]=requestHostTimeout,["cancelHostTimeout"]=cancelHostTimeout,["shouldYieldToHost"]=shouldYieldToHost,["requestPaint"]=requestPaint,["getCurrentTime"]=getCurrentTime,["forceFrameRate"]=forceFrameRate}

end)
-- D:\Programming\toolkit\studio\packages\_Index\jsdotlua_react-reconciler@17.2.1\react-reconciler\src\ReactFiberErrorDialog.luau
 tkpack.declare("game.Packages._Index.jsdotlua_react-reconciler@17.2.1.react-reconciler.ReactFiberErrorDialog",function()
    local exports={};
    exports.showErrorDialog=function(boundary,errorInfo)
        return true
     end;
    return exports

 end)
tkpack.include("game.TK");